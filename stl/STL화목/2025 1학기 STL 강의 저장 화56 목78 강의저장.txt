

==============================================
저장한 시간 :2025-03-06 오후 5:27:53 목요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 6일 목요일      (1주 2일차 강의) 
//-------------------------------------------------------------------------------------------
//컴파일환경 확인/ 한학기 강의를 저장 할 save 파일 만들기
// 과제 -save.cpp로 분리하세요
//-------------------------------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release 모드의 x64  / C++ 언어 표준 - /std:: c++ latest, sdl 검사 - 아니요
//-------------------------------------------------------------------------------------------
#include<iostream>
#include<string>
#include<fstream>
#include<filesystem>
#include<vector>
#include<algorithm>
#include<chrono>

//[문제] 문제없이 파일이 저장되도록 해라  
void save(const std::string& fileName); //데이터 이름을 안바꿀 거고 데이터 크기가 있다보니 복사해서 가져오지 않을 꺼야 const string&랑 같다
//----------
int main()
//----------
{
	std::cout << "2025 STL" << std::endl; //end of line 을 쓸 것이다

	save("메인.cpp");
}
//--------------------------------
void save(const std::string& fileName)
//--------------------------------
{
	//fileName을 읽기모드로 연다
	std::ifstream in{ fileName.data() }; //RAII
	// ! 대신 not 사용 권장
	if (not in) {
		std::cerr << "파일을 열 수가 없습니다" << std::endl;
		exit(20250306);
	}

	//쓰기 모드로 저장할 파일을 연다
	std::string nameToSave{ "2025 1학기 STL 강의 저장 화56 목78 강의저장.txt" };
	std::ofstream out{ nameToSave, std::ios::app }; //ios::app 로 해야 이쁘게 덧붙여짐

	//저장했다고 화면에 출력한다.`
	/*auto size = std::filesystem::file_size(fileName);*/
	auto size = 10000000;
	std::cout << nameToSave << "파일에 " << fileName << "을 덧붙였습니다 " << size << "바이트" << std::endl;

	// 저장한 시간을 파일에 기록하자
	auto now = std::chrono::system_clock::now(); //time_point를 얻는다 , epoch로 부터 기원됨
	using namespace std::chrono_literals;
	auto utc = std::chrono::system_clock::to_time_t(now); //UTC 시간으로 바꾼다
	auto lt = std::localtime(&utc); //너무 오래된 함수라서 &로 넘겨줘야한다 지역달력시간으로 변신
	auto old = out.imbue(std::locale("ko_KR"));

	out << '\n' << '\n';
	out << "==============================================" << '\n';
	out << "저장한 시간 :" << std::put_time(lt, "%c %A ") << '\n';
	out << "==============================================" << '\n';
	out << "\n";

	out.imbue(old); //원래 loacle로 복귀

	//읽을 파일에 있는 모든 내용을 읽어 쓸 파일에 덧붙여쓴다
	std::copy(std::istreambuf_iterator<char>{ in }, {}, std::ostreambuf_iterator<char>{ out });
}



==============================================
저장한 시간 :2025-03-06 오후 5:28:10 목요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 6일 목요일      (1주 2일차 강의) 
//-------------------------------------------------------------------------------------------
//컴파일환경 확인/ 한학기 강의를 저장 할 save 파일 만들기
// 과제 -save.cpp로 분리하세요
//-------------------------------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release 모드의 x64  / C++ 언어 표준 - /std:: c++ latest, sdl 검사 - 아니요
//-------------------------------------------------------------------------------------------
#include<iostream>
#include<string>
#include<fstream>
#include<filesystem>
#include<vector>
#include<algorithm>
#include<chrono>

//[문제] 문제없이 파일이 저장되도록 해라  
void save(const std::string& fileName); //데이터 이름을 안바꿀 거고 데이터 크기가 있다보니 복사해서 가져오지 않을 꺼야 const string&랑 같다
//----------
int main()
//----------
{
	std::cout << "2025 STL" << std::endl; //end of line 을 쓸 것이다

	save("메인.cpp");
}
//--------------------------------
void save(const std::string& fileName)
//--------------------------------
{
	//fileName을 읽기모드로 연다
	std::ifstream in{ fileName.data() }; //RAII
	// ! 대신 not 사용 권장
	if (not in) {
		std::cerr << "파일을 열 수가 없습니다" << std::endl;
		exit(20250306);
	}

	//쓰기 모드로 저장할 파일을 연다
	std::string nameToSave{ "2025 1학기 STL 강의 저장 화56 목78 강의저장.txt" };
	std::ofstream out{ nameToSave, std::ios::app }; //ios::app 로 해야 이쁘게 덧붙여짐

	//저장했다고 화면에 출력한다.`
	auto size = std::filesystem::file_size(fileName);
	std::cout << nameToSave << "파일에 " << fileName << "을 덧붙였습니다 " << size << "바이트" << std::endl;

	// 저장한 시간을 파일에 기록하자
	auto now = std::chrono::system_clock::now(); //time_point를 얻는다 , epoch로 부터 기원됨
	using namespace std::chrono_literals;
	auto utc = std::chrono::system_clock::to_time_t(now); //UTC 시간으로 바꾼다
	auto lt = std::localtime(&utc); //너무 오래된 함수라서 &로 넘겨줘야한다 지역달력시간으로 변신
	auto old = out.imbue(std::locale("ko_KR"));

	out << '\n' << '\n';
	out << "==============================================" << '\n';
	out << "저장한 시간 :" << std::put_time(lt, "%c %A ") << '\n';
	out << "==============================================" << '\n';
	out << "\n";

	out.imbue(old); //원래 loacle로 복귀

	//읽을 파일에 있는 모든 내용을 읽어 쓸 파일에 덧붙여쓴다
	std::copy(std::istreambuf_iterator<char>{ in }, {}, std::ostreambuf_iterator<char>{ out });
}



==============================================
저장한 시간 :2025-03-06 오후 9:25:51 목요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 6일 목요일      (1주 2일차 강의) 
//-------------------------------------------------------------------------------------------
//컴파일환경 확인/ 한학기 강의를 저장 할 save 파일 만들기
// 과제 -save.cpp로 분리하세요
//-------------------------------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release 모드의 x64  / C++ 언어 표준 - /std:: c++ latest, sdl 검사 - 아니요
//-------------------------------------------------------------------------------------------
#include<iostream>
#include<string>
#include<fstream>
#include<filesystem>
#include<vector>
#include<algorithm>
#include<chrono>
#include"save.h"
//[문제] 문제없이 파일이 저장되도록 해라  
void save(std::string_view fileName); //데이터 이름을 안바꿀 거고 데이터 크기가 있다보니 복사해서 가져오지 않을 꺼야 const string&랑 같다
//----------
int main()
//----------
{
	std::cout << "2025 STL" << std::endl; //end of line 을 쓸 것이다

	save("메인.cpp");
}




==============================================
저장한 시간 :2025-03-11 오후 1:28:34 화요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 6일 목요일      (1주 2일차 강의) 
//-------------------------------------------------------------------------------------------
//컴파일환경 확인/ 한학기 강의를 저장 할 save 파일 만들기
// 과제 -save.cpp로 분리하세요
//-------------------------------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release 모드의 x64  / C++ 언어 표준 - /std:: c++ latest, sdl 검사 - 아니요
//-------------------------------------------------------------------------------------------
#include<iostream>
#include<string>
#include<fstream>
#include<filesystem>
#include<vector>
#include<algorithm>
#include<chrono>
#include"save.h"
//[문제] 문제없이 파일이 저장되도록 해라  
void save(std::string_view fileName); //데이터 이름을 안바꿀 거고 데이터 크기가 있다보니 복사해서 가져오지 않을 꺼야 const string&랑 같다
//----------
int main()
//----------
{
	std::cout << "2025 STL" << std::endl; //end of line 을 쓸 것이다

	save("메인.cpp");
}




==============================================
저장한 시간 :2025-03-11 오후 1:40:26 화요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 11일 목요일      (1주 2일차 강의) 
//-------------------------------------------------------------------------------------------
// save 파일로 분리 / template 복습
//
//-------------------------------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release 모드의 x64  / C++ 언어 표준 - /std:: c++ latest, sdl 검사 - 아니요
//-------------------------------------------------------------------------------------------
#include<iostream>
#include<string>
#include<fstream>
#include<filesystem>
#include<vector>
#include<algorithm>
#include<chrono>
#include"save.h"
//[문제] 문제없이 파일이 저장되도록 해라  
void save(std::string_view fileName); //데이터 이름을 안바꿀 거고 데이터 크기가 있다보니 복사해서 가져오지 않을 꺼야 const string&랑 같다
//----------
int main()
//----------
{
	std::cout << "2025 STL" << std::endl; //end of line 을 쓸 것이다

	save("메인.cpp");
}




==============================================
저장한 시간 :2025-03-11 오후 1:40:41 화요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 11일 목요일      (1주 2일차 강의) 
//-------------------------------------------------------------------------------------------
// save 파일로 분리 / template 복습
//
//-------------------------------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release 모드의 x64  / C++ 언어 표준 - /std:: c++ latest, sdl 검사 - 아니요
//-------------------------------------------------------------------------------------------
#include<iostream>
#include<string>
#include<fstream>
#include<filesystem>
#include<vector>
#include<algorithm>
#include<chrono>
#include"save.h"
//[문제] 문제없이 파일이 저장되도록 해라  
void save(std::string_view fileName); //데이터 이름을 안바꿀 거고 데이터 크기가 있다보니 복사해서 가져오지 않을 꺼야 const string&랑 같다
//----------
int main()
//----------
{
	std::cout << "2025 STL" << std::endl; //end of line 을 쓸 것이다

	save("메인.cpp");
}




==============================================
저장한 시간 :2025-03-11 오후 1:40:56 화요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 11일 목요일      (1주 2일차 강의) 
//-------------------------------------------------------------------------------------------
// save 파일로 분리 / template 복습
//
//-------------------------------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release 모드의 x64  / C++ 언어 표준 - /std:: c++ latest, sdl 검사 - 아니요
//-------------------------------------------------------------------------------------------
#include<iostream>
#include<string>
#include<fstream>
#include<filesystem>
#include<vector>
#include<algorithm>
#include<chrono>
#include"save.h"
//[문제] 문제없이 파일이 저장되도록 해라  
void save(std::string_view fileName); //데이터 이름을 안바꿀 거고 데이터 크기가 있다보니 복사해서 가져오지 않을 꺼야 const string&랑 같다
//----------
int main()
//----------
{
	std::cout << "2025 STL" << std::endl; //end of line 을 쓸 것이다

	save("메인.cpp");
}




==============================================
저장한 시간 :2025-03-11 오후 1:41:27 화요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 11일 목요일      (1주 2일차 강의) 
//-------------------------------------------------------------------------------------------
// save 파일로 분리 / template 복습
//
//-------------------------------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release 모드의 x64  / C++ 언어 표준 - /std:: c++ latest, sdl 검사 - 아니요
//-------------------------------------------------------------------------------------------
#include<iostream>
#include<string>
#include<fstream>
#include<filesystem>
#include<vector>
#include<algorithm>
#include<chrono>
#include"save.h"
//[문제] 문제없이 파일이 저장되도록 해라  
void save(std::string_view fileName); //데이터 이름을 안바꿀 거고 데이터 크기가 있다보니 복사해서 가져오지 않을 꺼야 const string&랑 같다
//----------
int main()
//----------
{
	std::cout << "2025  STL" << std::endl; //end of line 을 쓸 것이다

	save("메인.cpp");
}




==============================================
저장한 시간 :2025-03-11 오후 1:44:02 화요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 11일 목요일      (1주 2일차 강의) 
//-------------------------------------------------------------------------------------------
// save 파일로 분리 / template 복습
//
//-------------------------------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release 모드의 x64  / C++ 언어 표준 - /std:: c++ latest, sdl 검사 - 아니요
//-------------------------------------------------------------------------------------------
#include<iostream>
#include<string>
#include<fstream>
#include<filesystem>
#include<vector>
#include<algorithm>
#include<chrono>
#include"save.h"
//[문제] 문제없이 파일이 저장되도록 해라  
void save(std::string_view fileName); //데이터 이름을 안바꿀 거고 데이터 크기가 있다보니 복사해서 가져오지 않을 꺼야 const string&랑 같다
//----------
int main()
//----------
{
	std::cout << "2025 STL" << std::endl; //end of line 을 쓸 것이다

	save("메인.cpp");
}




==============================================
저장한 시간 :2025-03-11 오후 1:48:13 화요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 11일 목요일      (1주 2일차 강의) 
//-------------------------------------------------------------------------------------------
// save 파일로 분리 / template 복습
//
//-------------------------------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release 모드의 x64  / C++ 언어 표준 - /std:: c++ latest, sdl 검사 - 아니요
//-------------------------------------------------------------------------------------------
#include<iostream>
#include<string>
#include<fstream>
#include<filesystem>
#include<vector>
#include<algorithm>
#include<chrono>
#include"save.h"
//[문제] 문제없이 파일이 저장되도록 해라  
void save(std::string_view fileName); //데이터 이름을 안바꿀 거고 데이터 크기가 있다보니 복사해서 가져오지 않을 꺼야 const string&랑 같다
//----------
int main()
//----------
{
	std::cout << "2025 STL" << std::endl; //end of line 을 쓸 것이다

	save("메인.cpp");
}




==============================================
저장한 시간 :2025-03-11 오후 1:48:51 화요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 11일 목요일      (1주 2일차 강의) 
//-------------------------------------------------------------------------------------------
// save 파일로 분리 / template 복습
//
//-------------------------------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release 모드의 x64  / C++ 언어 표준 - /std:: c++ latest, sdl 검사 - 아니요
//-------------------------------------------------------------------------------------------
#include<iostream>
#include"save.h"

//----------
int main()
//----------
{
	std::cout << "2025 STL" << std::endl; //end of line 을 쓸 것이다

	save("메인.cpp");
}




==============================================
저장한 시간 :2025-03-11 오후 1:51:17 화요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 11일 목요일      (1주 2일차 강의) 
//-------------------------------------------------------------------------------------------
// save 파일로 분리 / template 복습
//
//-------------------------------------------------------------------------------------------
// VS 버전 - 17.13 이상
// Release 모드의 x64  / C++ 언어 표준 - /std:: c++ latest, sdl 검사 - 아니요
//-------------------------------------------------------------------------------------------
#include<iostream>
#include"save.h"

//----------
int main()
//----------
{
	std::cout << "2025 STL" << std::endl; //end of line 을 쓸 것이다

	save("메인.cpp");
	save("save.h");
	save("save.cpp");
}




==============================================
저장한 시간 :2025-03-11 오후 1:51:17 화요일 
==============================================

//----------------------------------------------------------------------------------
// save.h                             2025년 3월 11일
//----------------------------------------------------------------------------------
#pragma once
void save(std::string_view fileName);

==============================================
저장한 시간 :2025-03-11 오후 1:51:17 화요일 
==============================================

//----------------------------------------------------------------------------------
// save.cpp                            2025년 3월 11일
// 한 학기 강의를 덧붙여 저장하는 함수입니다.
//----------------------------------------------------------------------------------
#include<iostream>
#include<string>
#include<fstream>
#include<filesystem>
#include<chrono>
#include"save.h"

//----------
//--------------------------------
void save(std::string_view fileName)
//--------------------------------
{
	//fileName을 읽기모드로 연다
	std::ifstream in{ fileName.data() }; //RAII
	// ! 대신 not 사용 권장
	if (not in) {
		std::cerr << "파일을 열 수가 없습니다" << std::endl;
		exit(20250306);
	}

	//쓰기 모드로 저장할 파일을 연다
	std::string nameToSave{ "2025 1학기 STL 강의 저장 화56 목78 강의저장.txt" };
	std::ofstream out{ nameToSave, std::ios::app }; //ios::app 로 해야 이쁘게 덧붙여짐

	//저장했다고 화면에 출력한다.`
	auto size = std::filesystem::file_size(fileName);
	std::cout << nameToSave << "파일에 " << fileName << "을 덧붙였습니다 " << size << "바이트" << std::endl;

	// 저장한 시간을 파일에 기록하자
	auto now = std::chrono::system_clock::now(); //time_point를 얻는다 , epoch로 부터 기원됨
	using namespace std::chrono_literals;
	auto utc = std::chrono::system_clock::to_time_t(now); //UTC 시간으로 바꾼다
	auto lt = std::localtime(&utc); //너무 오래된 함수라서 &로 넘겨줘야한다 지역달력시간으로 변신
	auto old = out.imbue(std::locale("ko_KR"));

	out << '\n' << '\n';
	out << "==============================================" << '\n';
	out << "저장한 시간 :" << std::put_time(lt, "%c %A ") << '\n';
	out << "==============================================" << '\n';
	out << "\n";

	out.imbue(old); //원래 loacle로 복귀

	//읽을 파일에 있는 모든 내용을 읽어 쓸 파일에 덧붙여쓴다
	std::copy(std::istreambuf_iterator<char>{ in }, {}, std::ostreambuf_iterator<char>{ out });
}



==============================================
저장한 시간 :2025-03-11 오후 1:56:51 화요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 11일 목요일      (1주 2일차 강의) 
//-------------------------------------------------------------------------------------------
//   template 복습
//
//-------------------------------------------------------------------------------------------
#include<iostream>
#include"save.h"
using namespace std;      //우리는 이렇게 하면 안되지만, 공부시간을 줄이기 위해
// [문제] main을 수정하지 말고 의도대로 실행되게 하라
void change(int& a, int& b);

//----------
int main()
//----------
{
	int a{ 1 }, b{ 2 };
	change(a, b);
	std::cout << a << " ," << b << endl;  //의도  -2,1
	save("메인.cpp");
	
}
void change(int& a, int& b)
{
	int c = a;
	a = b;
	b = c;
}




==============================================
저장한 시간 :2025-03-11 오후 2:14:54 화요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 11일 목요일      (1주 2일차 강의) 
//-------------------------------------------------------------------------------------------
//   template 복습
//
//-------------------------------------------------------------------------------------------
#include<iostream>
#include"save.h"
using namespace std;      //우리는 이렇게 하면 안되지만, 공부시간을 줄이기 위해
// [문제] main을 수정하지 말고 의도대로 실행되게 하라
class Dog {
private:
	
public:
	int num;
	Dog() = default;
	Dog(int n) :num(n) {};
	friend ostream& operator<<(ostream& os, const Dog& d) {
		os << d.num;
		return os;
	}
	void change(Dog& a, Dog& b) {
		int temp = a.num;
		a.num = b.num;
		b.num = temp;
	}
};

void change(int& a, int& b);
void change(Dog& a, Dog& b);
//----------
int main()
//----------
{
	{
		Dog a{ 1 }, b{ 2 };
		change(a, b);
		cout << a << " ," << b << endl;  //의도  -2,1
	}

	{
		int a{ 1 }, b{ 2 };
		change(a, b);
		cout << a << " ," << b << endl;  //의도  -2,1
	}
	save("메인.cpp");
	
}

void change(int& a , int& b)
{
	int temp{ a };
	a = b;
	b = temp;
}

void change(Dog& a, Dog& b) {
	int temp = a.num;
	a.num = b.num;
	b.num = temp;
}



==============================================
저장한 시간 :2025-03-11 오후 2:24:20 화요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 11일 목요일      (1주 2일차 강의) 
//-------------------------------------------------------------------------------------------
//   template 복습
//
//-------------------------------------------------------------------------------------------
#include<iostream>
#include"save.h"
using namespace std;      //우리는 이렇게 하면 안되지만, 공부시간을 줄이기 위해
// [문제] main을 수정하지 말고 의도대로 실행되게 하라
class Dog {
public:
	int num{ };
	Dog() = default;
	Dog(int n) :num{ n } { };
	friend ostream& operator<<(ostream& os, const Dog& d) {
		os << d.num;
		return os;
	}
	void change(Dog& a, Dog& b) {
		int temp = a.num;
		a.num = b.num;
		b.num = temp;
	}
};
//function overloading  함수의 이름만 같고 다른 것
void change(int&, int&);
void change(Dog&, Dog&);
//----------
int main()
//----------
{
	{
		Dog a{ 1 }, b{ 2 };
		change(a, b);
		cout << a << " ," << b << endl;  //의도  -2,1
	}

	{
		int a{ 1 }, b{ 2 };
		change(a, b);
		cout << a << " ," << b << endl;  //의도  -2,1
	}
	save("메인.cpp");
	
}

void change(int& a , int& b)
{
	int temp{ a };
	a = b;
	b = temp;
}

void change(Dog& a, Dog& b)
{
	Dog temp{ a }; //복사생성자 코딩 안했는데 이문장이 왜 돌아갈까?? 스페셜한 동작을 원할 떄 컴파일러가 해줌
	a = b;
	b = temp;
}



==============================================
저장한 시간 :2025-03-11 오후 2:25:55 화요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 11일 목요일      (1주 2일차 강의) 
//-------------------------------------------------------------------------------------------
//   template 복습
//
//-------------------------------------------------------------------------------------------
#include<iostream>
#include"save.h"
using namespace std;      //우리는 이렇게 하면 안되지만, 공부시간을 줄이기 위해
// [문제] main을 수정하지 말고 의도대로 실행되게 하라
class Dog {
private:
	int num{ };
public:
	
	Dog() = default;
	Dog(int n) :num{ n } { };
	friend ostream& operator<<(ostream& os, const Dog& d) {
		os << d.num;
		return os;
	}
};
//function overloading  함수의 이름만 같고 다른 것
void change(int&, int&);
void change(Dog&, Dog&);
//----------
int main()
//----------
{
	{
		Dog a{ 1 }, b{ 2 };
		change(a, b);
		cout << a << " ," << b << endl;  //의도  -2,1  연산자 오버로딩 하는 줄
	}

	{
		int a{ 1 }, b{ 2 };
		change(a, b);
		cout << a << " ," << b << endl;  //의도  -2,1
	}
	save("메인.cpp");
	
}

void change(int& a , int& b)
{
	int temp{ a };
	a = b;
	b = temp;
}

void change(Dog& a, Dog& b)
{
	Dog temp{ a }; //복사생성자 코딩 안했는데 이문장이 왜 돌아갈까?? 스페셜한 동작을 원할 떄 컴파일러가 해줌
	a.operator = (b); //copy assignment
	b = temp;
}



==============================================
저장한 시간 :2025-03-11 오후 2:36:42 화요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 11일 목요일      (1주 2일차 강의) 
//-------------------------------------------------------------------------------------------
//   template 복습
//
//-------------------------------------------------------------------------------------------
#include<iostream>
#include"save.h"
using namespace std;      //우리는 이렇게 하면 안되지만, 공부시간을 줄이기 위해


// C++에서 [문제] change 함수는 몇 번이나 overloading 해야 할까??
// C++ 언어의 자료형은 몇 개인가? 무한개

class Dog {
public:
	
	Dog() = default;
	Dog(int n) :num{ n } { };
	friend ostream& operator<<(ostream& os, const Dog& dog) {
		return os << dog.num;
	}
private:
	int num{ };
};


template<class T>
void change(T&, T&);
//----------
int main()
//----------
{
	{
		Dog a{ 1 }, b{ 2 };
		change(a, b);
		cout << a << " ," << b << endl;  //의도  -2,1  연산자 오버로딩 하는 줄
	}

	{
		int a{ 1 }, b{ 2 };
		change(a, b);
		cout << a << " ," << b << endl;  //의도  -2,1
	}
	save("메인.cpp");
	
}

template<class T>
void change(T& a , T& b)
{
	T temp{ a };
	a = b;
	b = temp;
}





==============================================
저장한 시간 :2025-03-11 오후 2:40:53 화요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 11일 목요일      (1주 2일차 강의) 
//-------------------------------------------------------------------------------------------
//   template 복습
//
//-------------------------------------------------------------------------------------------
#include<iostream>
#include"save.h"
using namespace std;      //우리는 이렇게 하면 안되지만, 공부시간을 줄이기 위해


// C++에서 [문제] change 함수는 몇 번이나 overloading 해야 할까??
// C++ 언어의 자료형은 몇 개인가? 무한개

class Dog {
public:
	
	Dog() = default;
	Dog(int n) :num{ n } { };
	friend ostream& operator<<(ostream& os, const Dog& dog) {
		return os << dog.num;
	}
private:
	int num{ };
};

//템플릿은 선언과 정의를 동시에 한다
template<class T>
void change(T& a, T& b)
{
	T temp{ a };
	a = b;
	b = temp;
}
//----------
int main()
//----------
{
	cout << sizeof(Dog);
	{
		Dog a{ 1 }, b{ 2 };
		change(a, b);
		cout << a << " ," << b << endl;  //의도  -2,1  연산자 오버로딩 하는 줄
	}

	{
		int a{ 1 }, b{ 2 };
		change(a, b);
		cout << a << " ," << b << endl;  //의도  -2,1
	}
	save("메인.cpp");
	
}







==============================================
저장한 시간 :2025-03-11 오후 2:57:16 화요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 11일 목요일      (1주 2일차 강의) 
//-------------------------------------------------------------------------------------------
//   많은 수의 자료를 처리하기
//
//-------------------------------------------------------------------------------------------
#include<iostream>
#include"save.h"
using namespace std;

//[문제] 랜덤 int 1000개를 생성하여 화면에 출력하라

//----------
int main()
//----------
{
	srand(time(0)); // 시드값을 현재 시간으로 설정  
	for (int i = 0; i < 1000; ++i) {
		cout << rand() << " "; // 랜덤한 정수 출력  
	}
	save("메인.cpp");	
}







==============================================
저장한 시간 :2025-03-11 오후 2:59:32 화요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 11일 목요일      (1주 2일차 강의) 
//-------------------------------------------------------------------------------------------
//   많은 수의 자료를 처리하기
//
//-------------------------------------------------------------------------------------------
#include<iostream>
#include"save.h"
#include <random>
using namespace std;

default_random_engine dre;
uniform_int_distribution uid{ 1,9999 };
//[문제] 랜덤 int 1000개를 생성하여 화면에 출력하라

//----------
int main()
//----------
{
	int p[1000];
	for (int i = 0; i < 1000; ++i)
		p[i] = uid(dre);
	for (auto i : p) {
		cout << i << " ";
	}
	save("메인.cpp");	
}







==============================================
저장한 시간 :2025-03-11 오후 3:05:49 화요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 11일 목요일      (1주 2일차 강의) 
//-------------------------------------------------------------------------------------------
//   많은 수의 자료를 처리하기
//
//-------------------------------------------------------------------------------------------
#include<iostream>
#include <random>
#include"save.h"

using namespace std;

default_random_engine dre; //엔전에서 막 임의의 bit를 가공한다
uniform_int_distribution uid{ 1,9999 };
//[문제] 랜덤 int 1000개를 생성하여 화면에 출력하라

//----------
int main()
//----------
{
	int p[1000];
	for (int i = 0; i < 1000; ++i)
		cout << uid(dre) << " ";

	save("메인.cpp");	
}







==============================================
저장한 시간 :2025-03-11 오후 3:06:00 화요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 11일 목요일      (1주 2일차 강의) 
//-------------------------------------------------------------------------------------------
//   많은 수의 자료를 처리하기
//
//-------------------------------------------------------------------------------------------
#include<iostream>
#include <random>
#include"save.h"

using namespace std;

default_random_engine dre; //엔전에서 막 임의의 bit를 가공한다
uniform_int_distribution uid{ 1,9999 };
//[문제] 랜덤 int 1000개를 생성하여 화면에 출력하라

//----------
int main()
//----------
{
	int p[1000];
	for (int i = 0; i < 1000; ++i)
		cout << uid(dre) << " ";
	cout << endl;

	save("메인.cpp");	
}







==============================================
저장한 시간 :2025-03-11 오후 3:07:15 화요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 11일 목요일      (1주 2일차 강의) 
//-------------------------------------------------------------------------------------------
//   많은 수의 자료를 처리하기
//
//-------------------------------------------------------------------------------------------
#include<iostream>
#include <random>
#include<print>
#include"save.h"

using namespace std;

default_random_engine dre; //엔전에서 막 임의의 bit를 가공한다
uniform_int_distribution uid{ 1,9999 };
//[문제] 랜덤 int 1000개를 생성하여 화면에 출력하라

//----------
int main()
//----------
{
	int p[1000];
	for (int i = 0; i < 1000; ++i)
		print("", uid(dre));
	cout << endl;

	save("메인.cpp");	
}







==============================================
저장한 시간 :2025-03-11 오후 3:07:35 화요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 11일 목요일      (1주 2일차 강의) 
//-------------------------------------------------------------------------------------------
//   많은 수의 자료를 처리하기
//
//-------------------------------------------------------------------------------------------
#include<iostream>
#include <random>
#include<print>
#include"save.h"

using namespace std;

default_random_engine dre; //엔전에서 막 임의의 bit를 가공한다
uniform_int_distribution uid{ 1,9999 };
//[문제] 랜덤 int 1000개를 생성하여 화면에 출력하라

//----------
int main()
//----------
{
	int p[1000];
	for (int i = 0; i < 1000; ++i)
		print("{}", uid(dre));
	cout << endl;

	save("메인.cpp");	
}







==============================================
저장한 시간 :2025-03-11 오후 3:08:01 화요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 11일 목요일      (1주 2일차 강의) 
//-------------------------------------------------------------------------------------------
//   많은 수의 자료를 처리하기
//
//-------------------------------------------------------------------------------------------
#include<iostream>
#include <random>
#include<print>
#include"save.h"

using namespace std;

default_random_engine dre; //엔전에서 막 임의의 bit를 가공한다
uniform_int_distribution uid{ 1,9999 };
//[문제] 랜덤 int 1000개를 생성하여 화면에 출력하라

//----------
int main()
//----------
{
	int p[1000];
	for (int i = 0; i < 1000; ++i)
		print("{:8}", uid(dre));  //나는 8 글자에 맞추어 볼래
	cout << endl;

	save("메인.cpp");	
}







==============================================
저장한 시간 :2025-03-11 오후 3:08:20 화요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 11일 목요일      (1주 2일차 강의) 
//-------------------------------------------------------------------------------------------
//   많은 수의 자료를 처리하기
//
//-------------------------------------------------------------------------------------------
#include<iostream>
#include <random>
#include<print>
#include"save.h"

using namespace std;

default_random_engine dre; //엔전에서 막 임의의 bit를 가공한다
uniform_int_distribution uid{ 1,999'9999 };
//[문제] 랜덤 int 1000개를 생성하여 화면에 출력하라

//----------
int main()
//----------
{
	int p[1000];
	for (int i = 0; i < 1000; ++i)
		print("{:8}", uid(dre));  //나는 8 글자에 맞추어 볼래
	cout << endl;

	save("메인.cpp");	
}







==============================================
저장한 시간 :2025-03-13 오후 3:29:57 목요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 11일 목요일      (1주 2일차 강의) 
//-------------------------------------------------------------------------------------------
//   많은 수의 자료를 처리하기
//
//-------------------------------------------------------------------------------------------
#include<iostream>
#include <random>
#include<print>
#include"save.h"

using namespace std;

default_random_engine dre; //엔전에서 막 임의의 bit를 가공한다
uniform_int_distribution uid{ 1,999'9999 };
//[문제] 랜덤 int 1000개를 메모리에 저장하라
// 가장 큰 값을 찾아 화면에 출력하라
void find_max_num(int num[]);

//----------
int main()
//----------
{
	int p[1000];
	for (int i = 0; i < 1000; ++i) {
		p[i] = uid(dre);
		print("{:8}", p[i]);  //나는 8 글자에 맞추어 볼래
	}
	cout << endl;
	find_max_num(p);

	save("메인.cpp");	
}
void find_max_num(int num[]) {
	int maxNum = 0;
	for (int i = 0; i < 1000; ++i) {
		maxNum = max(maxNum, num[i]);
	}
	cout << " 가장 큰 수는 :" << maxNum;
}







==============================================
저장한 시간 :2025-03-13 오후 3:30:25 목요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 13일 목요일      (2주 2일차 강의) 
//-------------------------------------------------------------------------------------------
//   많은 수의 자료를 처리하기
//
//-------------------------------------------------------------------------------------------
#include<iostream>
#include <random>
#include<print>
#include"save.h"

using namespace std;

default_random_engine dre; //엔전에서 막 임의의 bit를 가공한다
uniform_int_distribution uid{ 1,999'9999 };
//[문제] 랜덤 int 1000개를 메모리에 저장하라
// 가장 큰 값을 찾아 화면에 출력하라
void find_max_num(int num[]);

//----------
int main()
//----------
{
	int p[1000];
	for (int i = 0; i < 1000; ++i) {
		p[i] = uid(dre);
		print("{:8}", p[i]);  //나는 8 글자에 맞추어 볼래
	}
	cout << endl;
	find_max_num(p);

	save("메인.cpp");	
}
void find_max_num(int num[]) {
	int maxNum = 0;
	for (int i = 0; i < 1000; ++i) {
		maxNum = max(maxNum, num[i]);
	}
	cout << " 가장 큰 수는 :" << maxNum << endl;
}







==============================================
저장한 시간 :2025-03-13 오후 3:35:41 목요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 13일 목요일      (2주 2일차 강의) 
//-------------------------------------------------------------------------------------------
//   많은 수의 자료를 처리하기
//
//-------------------------------------------------------------------------------------------
#include<iostream>
#include <random>
#include<print>
#include"save.h"

using namespace std;

default_random_engine dre; //엔전에서 막 임의의 bit를 가공한다
uniform_int_distribution uid{ 1,999'9999 };
//[문제] 랜덤 int 1000개를 메모리에 저장하라
// 가장 큰 값을 찾아 화면에 출력하라
void find_max_num(int num[]);

//----------
int main()
//----------
{
	int p[1000];
	for (int i = 0; i < 1000; ++i) {
		p[i] = uid(dre);
		print("{:8}", p[i]);  //나는 8 글자에 맞추어 볼래
	}
	cout << endl;
	find_max_num(p);

	save("메인.cpp");	
}
void find_max_num(int num[]) {
	int maxNum = 0;
	for (int i = 0; i < 1000; ++i) {
		maxNum = max(maxNum, num[i]);
	}
	cout << " 가장 큰 수는 :" << maxNum << endl;
}







==============================================
저장한 시간 :2025-03-13 오후 3:36:39 목요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 13일 목요일      (2주 2일차 강의) 
//-------------------------------------------------------------------------------------------
//   많은 수의 자료를 처리하기
//
//-------------------------------------------------------------------------------------------
#include<iostream>
#include <random>
#include<print>
#include"save.h"

using namespace std;

default_random_engine dre{ }; //엔진의 시드를 설정할 수 있다. 
uniform_int_distribution uid{ 0,999'9999 };
//[문제] 랜덤 int 1000개를 메모리에 저장하라
// 가장 큰 값을 찾아 화면에 출력하라
void find_max_num(int num[]);

//----------
int main()
//----------
{
	int p[1000];
	for (int i = 0; i < 1000; ++i) {
		p[i] = uid(dre);
		print("{:8}", p[i]);  //나는 8 글자에 맞추어 볼래
	}
	cout << endl;
	find_max_num(p);

	save("메인.cpp");	
}
void find_max_num(int num[]) {
	int maxNum = 0;
	for (int i = 0; i < 1000; ++i) {
		maxNum = max(maxNum, num[i]);
	}
	cout << " 가장 큰 수는 :" << maxNum << endl;
}







==============================================
저장한 시간 :2025-03-13 오후 3:37:13 목요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 13일 목요일      (2주 2일차 강의) 
//-------------------------------------------------------------------------------------------
//   많은 수의 자료를 처리하기
//
//-------------------------------------------------------------------------------------------
#include<iostream>
#include <random>
#include<print>
#include"save.h"

using namespace std;

default_random_engine dre{ random_device{}() }; //엔진의 시드를 설정할 수 있다. 
uniform_int_distribution uid{ 0,999'9999 };
//[문제] 랜덤 int 1000개를 메모리에 저장하라
// 가장 큰 값을 찾아 화면에 출력하라
void find_max_num(int num[]);

//----------
int main()
//----------
{
	int p[1000];
	for (int i = 0; i < 1000; ++i) {
		p[i] = uid(dre);
		print("{:8}", p[i]);  //나는 8 글자에 맞추어 볼래
	}
	cout << endl;
	find_max_num(p);

	save("메인.cpp");	
}
void find_max_num(int num[]) {
	int maxNum = 0;
	for (int i = 0; i < 1000; ++i) {
		maxNum = max(maxNum, num[i]);
	}
	cout << " 가장 큰 수는 :" << maxNum << endl;
}







==============================================
저장한 시간 :2025-03-13 오후 3:39:42 목요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 13일 목요일      (2주 2일차 강의) 
//-------------------------------------------------------------------------------------------
//   많은 수의 자료를 처리하기
//
//-------------------------------------------------------------------------------------------
#include<iostream>
#include <random>
#include<print>
#include"save.h"

using namespace std;

default_random_engine dre{ random_device{}() }; //엔진의 시드를 설정할 수 있다. 
uniform_int_distribution uid{ 0,999'9999 };
//[문제] 랜덤 int 1000개를 메모리에 저장하라
// 가장 큰 값을 찾아 화면에 출력하라
void find_max_num(int num[]);

//----------
int main()
//----------
{
	int p[1000];
	for (int i = 0; i < 1000; ++i) {
		p[i] = uid(dre);
		print("{:8}", p[i]);  //나는 8 글자에 맞추어 볼래
	}
	cout << endl;
	find_max_num(p);

	save("메인.cpp");	
}
void find_max_num(int num[]) {
	int maxNum = 0;
	for (int i = 0; i < 1000; ++i) {
		maxNum = max(maxNum, num[i]);
	}
	cout << " 가장 큰 수는 :" << maxNum << endl;
}







==============================================
저장한 시간 :2025-03-13 오후 3:46:50 목요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 13일 목요일      (2주 2일차 강의) 
//-------------------------------------------------------------------------------------------
//   많은 수의 자료를 처리하기
//
//-------------------------------------------------------------------------------------------
#include<iostream>
#include <random>
#include<print>
#include<vector>
#include"save.h"

using namespace std;

default_random_engine dre{ random_device{}() }; //엔진의 시드를 설정할 수 있다. 
uniform_int_distribution uid{ 0,999'9999 };
//[문제] 랜덤 int 1000개를 메모리에 저장하라
// 저장된 값 중에서 가장 큰 값을 찾아 화면에 출력하라 

void find_max_num(int num[]);

//----------
int main()
//----------
{
	int p[1000];
	vector<int> vi;
	vi.resize(1000);
	for (int i = 0; i < 1000; ++i) {
		vi[i] = uid(dre);
		print("{:8}", p[i]);  //나는 8 글자에 맞추어 볼래
	}
	cout << endl;
	auto mNum= *max_element(vi.begin(), vi.end());
	cout << " 가장 큰 수는 :" << mNum << endl;
	

	save("메인.cpp");	
}
void find_max_num(int num[]) {
	int maxNum = 0;
	for (int i = 0; i < 1000; ++i) {
		maxNum = max(maxNum, num[i]);
	}
	cout << " 가장 큰 수는 :" << maxNum << endl;
}







==============================================
저장한 시간 :2025-03-13 오후 3:47:05 목요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 13일 목요일      (2주 2일차 강의) 
//-------------------------------------------------------------------------------------------
//   많은 수의 자료를 처리하기
//
//-------------------------------------------------------------------------------------------
#include<iostream>
#include <random>
#include<print>
#include<vector>
#include"save.h"

using namespace std;

default_random_engine dre{ random_device{}() }; //엔진의 시드를 설정할 수 있다. 
uniform_int_distribution uid{ 0,999'9999 };
//[문제] 랜덤 int 1000개를 메모리에 저장하라
// 저장된 값 중에서 가장 큰 값을 찾아 화면에 출력하라 

void find_max_num(int num[]);

//----------
int main()
//----------
{
	int p[1000];
	vector<int> vi;
	vi.resize(1000);
	for (int i = 0; i < 1000; ++i) {
		vi[i] = uid(dre);
		print("{:8}", vi[i]);  //나는 8 글자에 맞추어 볼래
	}
	cout << endl;
	auto mNum= *max_element(vi.begin(), vi.end());
	cout << " 가장 큰 수는 :" << mNum << endl;
	

	save("메인.cpp");	
}
void find_max_num(int num[]) {
	int maxNum = 0;
	for (int i = 0; i < 1000; ++i) {
		maxNum = max(maxNum, num[i]);
	}
	cout << " 가장 큰 수는 :" << maxNum << endl;
}







==============================================
저장한 시간 :2025-03-13 오후 3:48:27 목요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 13일 목요일      (2주 2일차 강의) 
//-------------------------------------------------------------------------------------------
//   많은 수의 자료를 처리하기
//
//-------------------------------------------------------------------------------------------
#include<iostream>
#include <random>
#include<print>
#include<vector>
#include"save.h"

using namespace std;

default_random_engine dre{  }; //엔진의 시드를 설정할 수 있다. 
uniform_int_distribution uid{ 0,999'9999 };
//[문제] 랜덤 int 1000개를 메모리에 저장하라
// 저장된 값 중에서 가장 큰 값을 찾아 화면에 출력하라 

void find_max_num(int num[]);

//----------
int main()
//----------
{
	int p[1000];
	vector<int> vi;
	vi.resize(1000);
	for (int i = 0; i < 1000; ++i) {
		vi[i] = uid(dre);
		print("{:8}", vi[i]);  //나는 8 글자에 맞추어 볼래
	}
	cout << endl;
	auto mNum= *max_element(vi.begin(), vi.end());
	cout << " 가장 큰 수는 :" << mNum << endl;
	

	save("메인.cpp");	
}
void find_max_num(int num[]) {
	int maxNum = 0;
	for (int i = 0; i < 1000; ++i) {
		maxNum = max(maxNum, num[i]);
	}
	cout << " 가장 큰 수는 :" << maxNum << endl;
}







==============================================
저장한 시간 :2025-03-13 오후 3:51:32 목요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 13일 목요일      (2주 2일차 강의) 
//-------------------------------------------------------------------------------------------
//   많은 수의 자료를 처리하기
//
//-------------------------------------------------------------------------------------------
#include<iostream>
#include <random>
#include<print>
#include<vector>
#include"save.h"

using namespace std;

default_random_engine dre{  }; //엔진의 시드를 설정할 수 있다. 
uniform_int_distribution uid{ 0,999'9999 }; 
//[문제] 랜덤 int 1000개를 메모리에 저장하라
// 저장된 값 중에서 가장 큰 값을 찾아 화면에 출력하라 

void find_max_num(int num[]);

//----------
int main()
//----------
{
	int p[1000];
	vector<int> vi;
	vi.resize(1000);
	for (int i = 0; i < 1000; ++i) {
		vi[i] = uid(dre);
		print("{:8}", vi[i]);  //나는 8 글자에 맞추어 볼래
	}
	cout << endl;
	auto mNum= *max_element(vi.begin(), vi.end());
	cout << " 가장 큰 수는 :" << mNum << endl;
	

	save("메인.cpp");	
}
void find_max_num(int num[]) {
	int maxNum{ numeric_limits<int>::min() }; //공부 좀 한 학생은 이렇게 쓴다.

	for (int i = 0; i < 1000; ++i) {
		maxNum = max(maxNum, num[i]);
	}
	cout << " 가장 큰 수는 :" << maxNum << endl;
}







==============================================
저장한 시간 :2025-03-13 오후 3:51:40 목요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 13일 목요일      (2주 2일차 강의) 
//-------------------------------------------------------------------------------------------
//   많은 수의 자료를 처리하기
//
//-------------------------------------------------------------------------------------------
#include<iostream>
#include <random>
#include<print>
#include<vector>
#include"save.h"

using namespace std;

default_random_engine dre{  }; //엔진의 시드를 설정할 수 있다. 
uniform_int_distribution uid{ 0,999'9999 }; 
//[문제] 랜덤 int 1000개를 메모리에 저장하라
// 저장된 값 중에서 가장 큰 값을 찾아 화면에 출력하라 

void find_max_num(int num[]);

//----------
int main()
//----------
{
	int p[1000];
	vector<int> vi;
	vi.resize(1000);
	for (int i = 0; i < 1000; ++i) {
		vi[i] = uid(dre);
		print("{:8}", vi[i]);  //나는 8 글자에 맞추어 볼래
	}
	cout << endl;
	auto mNum= *max_element(vi.begin(), vi.end());
	cout << " 가장 큰 수는 :" << mNum << endl;
	

	save("메인.cpp");	
}
void find_max_num(int num[]) {
	int maxNum{ numeric_limits<int>::min() }; //공부 좀 한 학생은 이렇게 쓴다.

	for (int i = 0; i < 1000; ++i) {
		maxNum = max(maxNum, num[i]);
	}
	cout << " 가장 큰 수는 :" << maxNum << endl;
}







==============================================
저장한 시간 :2025-03-13 오후 3:57:49 목요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 13일 목요일      (2주 2일차 강의) 
//-------------------------------------------------------------------------------------------
//   많은 수의 자료를 처리하기
//
//-------------------------------------------------------------------------------------------
#include<iostream>
#include <random>
#include<print>
#include<vector>
#include<array>
#include"save.h"

using namespace std;

default_random_engine dre{  }; //엔진의 시드를 설정할 수 있다. 
uniform_int_distribution uid{ 0,999'9999 }; 


//[문제] 랜덤 int 1000개를 메모리에 저장하라
// 저장된 값 중에서 가장 큰 값을 찾아 화면에 출력하라 

void find_max_num(int num[]);

//----------
int main()
//----------
{
	array<int, 1000> arr; //일관된 표현식으로 바뀐다.

	for (int i = 0; i < 1000; ++i) { // 1000은 magic number라 부름 무의미하다.  1000박아놓는거는 hard-wired 라고 한다 가능하면 피해야 한다.
		arr[i] = uid(dre);
	}
	int maxNum{ numeric_limits<int>::min() }; //공부 좀 한 학생은 이렇게 쓴다.

	for (int i = 0; i < 1000; ++i) {
		maxNum = max(maxNum, arr[i]);
	}
	cout << endl;
	cout << " 가장 큰 수는 :" << maxNum << endl;
	

	save("메인.cpp");	
}
void find_max_num(int num[]) {
	int maxNum{ numeric_limits<int>::min() }; //공부 좀 한 학생은 이렇게 쓴다.

	for (int i = 0; i < 1000; ++i) {
		maxNum = max(maxNum, num[i]);
	}
	cout << " 가장 큰 수는 :" << maxNum << endl;
}







==============================================
저장한 시간 :2025-03-13 오후 3:58:08 목요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 13일 목요일      (2주 2일차 강의) 
//-------------------------------------------------------------------------------------------
//   많은 수의 자료를 처리하기
//
//-------------------------------------------------------------------------------------------
#include<iostream>
#include <random>
#include<print>
#include<vector>
#include<array>
#include"save.h"

using namespace std;

default_random_engine dre{  }; //엔진의 시드를 설정할 수 있다. 
uniform_int_distribution uid{ 0,999'9999 }; 


//[문제] 랜덤 int 1000개를 메모리에 저장하라
// 저장된 값 중에서 가장 큰 값을 찾아 화면에 출력하라 

void find_max_num(int num[]);

//----------
int main()
//----------
{
	array<int, 1000> arr; //일관된 표현식으로 바뀐다.

	for (int i = 0; i < arr.size(); ++i) { // 1000은 magic number라 부름 무의미하다.  1000박아놓는거는 hard-wired 라고 한다 가능하면 피해야 한다.
		arr[i] = uid(dre);
	}
	int maxNum{ numeric_limits<int>::min() }; //공부 좀 한 학생은 이렇게 쓴다.

	for (int i = 0; i < 1000; ++i) {
		maxNum = max(maxNum, arr[i]);
	}
	cout << " 가장 큰 수는 :" << maxNum << endl;
	

	save("메인.cpp");	
}
void find_max_num(int num[]) {
	int maxNum{ numeric_limits<int>::min() }; //공부 좀 한 학생은 이렇게 쓴다.

	for (int i = 0; i < 1000; ++i) {
		maxNum = max(maxNum, num[i]);
	}
	cout << " 가장 큰 수는 :" << maxNum << endl;
}







==============================================
저장한 시간 :2025-03-13 오후 3:59:43 목요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 13일 목요일      (2주 2일차 강의) 
//-------------------------------------------------------------------------------------------
//   많은 수의 자료를 처리하기
//
//-------------------------------------------------------------------------------------------
#include<iostream>
#include <random>
#include<print>
#include<vector>
#include<array>
#include"save.h"

using namespace std;

default_random_engine dre{  }; //엔진의 시드를 설정할 수 있다. 
uniform_int_distribution uid{ 0,999'9999 }; 


//[문제] 랜덤 int 1000개를 메모리에 저장하라
// 저장된 값 중에서 가장 큰 값을 찾아 화면에 출력하라 

void find_max_num(int num[]);

//----------
int main()
//----------
{
	array<int, 1000> arr; //일관된 표현식으로 바뀐다.

	for (int& num : arr) { //지역에서 지역밖에 있는거 못함 
		num = uid(dre);
	}
	int maxNum{ numeric_limits<int>::min() }; //공부 좀 한 학생은 이렇게 쓴다.

	for (int i = 0; i < 1000; ++i) {
		maxNum = max(maxNum, arr[i]);
	}
	cout << " 가장 큰 수는 :" << maxNum << endl;
	

	save("메인.cpp");	
}
void find_max_num(int num[]) {
	int maxNum{ numeric_limits<int>::min() }; //공부 좀 한 학생은 이렇게 쓴다.

	for (int i = 0; i < 1000; ++i) {
		maxNum = max(maxNum, num[i]);
	}
	cout << " 가장 큰 수는 :" << maxNum << endl;
}







==============================================
저장한 시간 :2025-03-13 오후 4:01:02 목요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 13일 목요일      (2주 2일차 강의) 
//-------------------------------------------------------------------------------------------
//   많은 수의 자료를 처리하기
//
//-------------------------------------------------------------------------------------------
#include<iostream>
#include <random>
#include<print>
#include<vector>
#include<array>
#include"save.h"

using namespace std;

default_random_engine dre{  }; //엔진의 시드를 설정할 수 있다. 
uniform_int_distribution uid{ 0,999'9999 }; 


//[문제] 랜덤 int 1000개를 메모리에 저장하라
// 저장된 값 중에서 가장 큰 값을 찾아 화면에 출력하라 

void find_max_num(int num[]);

//----------
int main()
//----------
{
	array<int, 1000> arr; //일관된 표현식으로 바뀐다.

	for (int& num : arr) { //지역에서 지역밖에 있는거 못함 
		num = uid(dre);
	}

	int maxNum{ numeric_limits<int>::min() }; //공부 좀 한 학생은 이렇게 쓴다.

	for (const int& num : arr) {
		maxNum = max(maxNum, num);
	}
	cout << " 가장 큰 수는 :" << maxNum << endl;
	

	save("메인.cpp");	
}
void find_max_num(int num[]) {
	int maxNum{ numeric_limits<int>::min() }; //공부 좀 한 학생은 이렇게 쓴다.

	for (int i = 0; i < 1000; ++i) {
		maxNum = max(maxNum, num[i]);
	}
	cout << " 가장 큰 수는 :" << maxNum << endl;
}







==============================================
저장한 시간 :2025-03-13 오후 4:09:06 목요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 13일 목요일      (2주 2일차 강의) 
//-------------------------------------------------------------------------------------------
//   많은 수의 자료를 처리하기
//
//-------------------------------------------------------------------------------------------
#include<iostream>
#include <random>
#include<print>
#include<vector>
#include<array>
#include<algorithm>
#include"save.h"

using namespace std;

default_random_engine dre{  }; //엔진의 시드를 설정할 수 있다. 
uniform_int_distribution uid{ 0,999'9999 }; 


//[문제] 랜덤 int 1000개를 메모리에 저장하라
// 저장된 값 중에서 가장 큰 값을 찾아 화면에 출력하라 

void find_max_num(int num[]);

//----------
int main()
//----------
{
	array<int, 1000> arr; //일관된 표현식으로 바뀐다.

	for (int& num : arr) { //지역에서 지역밖에 있는거 못함 
		num = uid(dre);
	}

	auto maxIt = max_element(arr.begin(), arr.end());  //end는 iterator 가 마지막 원소 뒤에 값을 가리킨다.

	cout << " 가장 큰 수는 :" << *maxIt << endl;
	

	save("메인.cpp");	
}
void find_max_num(int num[]) {
	int maxNum{ numeric_limits<int>::min() }; //공부 좀 한 학생은 이렇게 쓴다.

	for (int i = 0; i < 1000; ++i) {
		maxNum = max(maxNum, num[i]);
	}
	cout << " 가장 큰 수는 :" << maxNum << endl;
}







==============================================
저장한 시간 :2025-03-13 오후 4:10:32 목요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 13일 목요일      (2주 2일차 강의) 
//-------------------------------------------------------------------------------------------
//   많은 수의 자료를 처리하기
//
//-------------------------------------------------------------------------------------------
#include<iostream>
#include <random>
#include<print>
#include<vector>
#include<array>
#include<algorithm>
#include"save.h"

using namespace std;

default_random_engine dre{  }; //엔진의 시드를 설정할 수 있다. 
uniform_int_distribution uid{ 0,999'9999 }; 


//[문제] 랜덤 int 1000개를 메모리에 저장하라
// 저장된 값 중에서 가장 큰 값을 찾아 화면에 출력하라 

void find_max_num(int num[]);

//----------
int main()
//----------
{
	array<int, 1000> arr; //일관된 표현식으로 바뀐다.

	for (int& num : arr) { //지역에서 지역밖에 있는거 못함 
		num = uid(dre);
	}

	//end는 iterator 가 마지막 원소 뒤에 값을 가리킨다.

	cout << " 가장 큰 수는 :" << *max_element(arr.begin(), arr.end()) << endl;
	

	save("메인.cpp");	
}
void find_max_num(int num[]) {
	int maxNum{ numeric_limits<int>::min() }; //공부 좀 한 학생은 이렇게 쓴다.

	for (int i = 0; i < 1000; ++i) {
		maxNum = max(maxNum, num[i]);
	}
	cout << " 가장 큰 수는 :" << maxNum << endl;
}







==============================================
저장한 시간 :2025-03-13 오후 4:19:41 목요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 13일 목요일      (2주 2일차 강의) 
//-------------------------------------------------------------------------------------------
//   많은 수의 자료를 처리하기
//
//-------------------------------------------------------------------------------------------
#include<iostream>
#include <random>
#include<print>
#include<vector>
#include<array>
#include<algorithm>
#include<fstream>
#include"save.h"

using namespace std;

default_random_engine dre{  }; //엔진의 시드를 설정할 수 있다. 
uniform_int_distribution uid{ 0,999'9999 }; 


//[문제] 랜덤 int 값 1000개를 파일"int 1000개.txt" 에 텍스트 모드로 저장하라
// 파일을 열었을 때 사람이 읽을 수 있어야 한다.
// 파일을 읽어서 원래 int값을 가져올 수 있어야 한다.

void save_to_file(const array<int, 1000>& arr, const string& filename);
void load_from_file(array<int, 1000>& arr, const string& filename);
//----------
int main()
//----------
{
	array<int, 1000> arr; //일관된 표현식으로 바뀐다.

	for (int& num : arr) { //지역에서 지역밖에 있는거 못함 
		num = uid(dre);
	}
    ofstream ofs("int 1000개.txt");
    for (auto& num : arr) {
        ofs << num << " ";
    }


	

	save("메인.cpp");	

}

void save_to_file(const array<int, 1000>& arr, const string& filename) {
    ofstream ofs(filename);
    if (!ofs) {
        cerr << "파일을 열 수 없습니다: " << filename << endl;
        return;
    }
    for (const int& num : arr) {
        ofs << num << '\n';
    }
}

void load_from_file(array<int, 1000>& arr, const string& filename) {
    ifstream ifs(filename);
    if (!ifs) {
        cerr << "파일을 열 수 없습니다: " << filename << endl;
        return;
    }
    for (int& num : arr) {
        ifs >> num;
    }
}





==============================================
저장한 시간 :2025-03-13 오후 4:20:14 목요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 13일 목요일      (2주 2일차 강의) 
//-------------------------------------------------------------------------------------------
//   많은 수의 자료를 처리하기
//
//-------------------------------------------------------------------------------------------
#include<iostream>
#include <random>
#include<print>
#include<vector>
#include<array>
#include<algorithm>
#include<fstream>
#include"save.h"

using namespace std;

default_random_engine dre{  }; //엔진의 시드를 설정할 수 있다. 
uniform_int_distribution uid{ 0,999'9999 }; 


//[문제] 랜덤 int 값 1000개를 파일"int 1000개.txt" 에 텍스트 모드로 저장하라
// 파일을 열었을 때 사람이 읽을 수 있어야 한다.
// 파일을 읽어서 원래 int값을 가져올 수 있어야 한다.

void save_to_file(const array<int, 1000>& arr, const string& filename);
void load_from_file(array<int, 1000>& arr, const string& filename);
//----------
int main()
//----------
{
	array<int, 1000> arr; //일관된 표현식으로 바뀐다.

	for (int& num : arr) { //지역에서 지역밖에 있는거 못함 
		num = uid(dre);
	}
    ofstream ofs("int 1000개.txt", std::ios::app);
    for (auto& num : arr) {
        ofs << num << " ";
    }


	

	save("메인.cpp");	

}

void save_to_file(const array<int, 1000>& arr, const string& filename) {
    ofstream ofs(filename);
    if (!ofs) {
        cerr << "파일을 열 수 없습니다: " << filename << endl;
        return;
    }
    for (const int& num : arr) {
        ofs << num << '\n';
    }
}

void load_from_file(array<int, 1000>& arr, const string& filename) {
    ifstream ifs(filename);
    if (!ifs) {
        cerr << "파일을 열 수 없습니다: " << filename << endl;
        return;
    }
    for (int& num : arr) {
        ifs >> num;
    }
}





==============================================
저장한 시간 :2025-03-13 오후 4:25:59 목요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 13일 목요일      (2주 2일차 강의) 
//-------------------------------------------------------------------------------------------
//   많은 수의 자료를 처리하기
//
//-------------------------------------------------------------------------------------------
#include<iostream>
#include <random>
#include<print>
#include<vector>
#include<array>
#include<algorithm>
#include<fstream>
#include"save.h"

using namespace std;

default_random_engine dre{  }; //엔진의 시드를 설정할 수 있다. 
uniform_int_distribution uid{ 0,999'9999 }; 


//[문제] 랜덤 int 값 1000개를 파일"int 1000개.txt" 에 텍스트 모드로 저장하라
// 파일을 열었을 때 사람이 읽을 수 있어야 한다.
// 파일을 읽어서 원래 int값을 가져올 수 있어야 한다.


//----------
int main()
//----------
{
    print("{:^80}", 20250311);
    for (int i = 0; i < 1000; ++i)
        print("{:8}", uid(dre));



	save("메인.cpp");	

}





==============================================
저장한 시간 :2025-03-13 오후 4:31:17 목요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 13일 목요일      (2주 2일차 강의) 
//-------------------------------------------------------------------------------------------
//   많은 수의 자료를 처리하기
//
//-------------------------------------------------------------------------------------------
#include<iostream>
#include <random>
#include<print>
#include<fstream>
#include"save.h"

using namespace std;

default_random_engine dre{  }; //엔진의 시드를 설정할 수 있다. 
uniform_int_distribution uid{ 0,999'9999 }; 


//[문제] 랜덤 int 값 1000개를 파일"int 1000개.txt" 에 텍스트 모드로 저장하라
// 파일을 열었을 때 사람이 읽을 수 있어야 한다.
// 파일을 읽어서 원래 int값을 가져올 수 있어야 한다.


//----------
int main()
//----------
{
    ofstream out{ "int 1000개.txt"}; //RAII 하면 굳이 out.close()를 해줄 필요가 없다

    for (int i = 0; i < 1000; ++i)
        print( out,"{:8}", uid(dre));



	save("메인.cpp");	

}





==============================================
저장한 시간 :2025-03-13 오후 4:37:21 목요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 13일 목요일      (2주 2일차 강의) 
//-------------------------------------------------------------------------------------------
//   많은 수의 자료를 처리하기
//
//-------------------------------------------------------------------------------------------
#include<iostream>
#include <random>
#include<print>
#include<fstream>
#include"save.h"

using namespace std;

default_random_engine dre{  }; //엔진의 시드를 설정할 수 있다. 
uniform_int_distribution uid{ 0,999'9999 }; 


//[문제] 랜덤 int 값 1000개를 파일"int 1000개.txt" 에 텍스트 모드로 저장하라
// 파일을 열었을 때 사람이 읽을 수 있어야 한다.
// 파일을 읽어서 원래 int값을 가져올 수 있어야 한다.


//----------
int main()
//----------
{
    ofstream out{ "int 1000개.txt"}; //RAII 하면 굳이 out.close()를 해줄 필요가 없다

    for (int i = 0; i < 1000; ++i)
        print( out,"{:8} *** ", uid(dre));

    ifstream in;

	save("메인.cpp");	

}

==============================================
저장한 시간 :2025-03-13 오후 4:38:10 목요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 13일 목요일      (2주 2일차 강의) 
//-------------------------------------------------------------------------------------------
//   많은 수의 자료를 처리하기
//
//-------------------------------------------------------------------------------------------
#include<iostream>
#include <random>
#include<print>
#include<fstream>
#include"save.h"

using namespace std;

default_random_engine dre{  }; //엔진의 시드를 설정할 수 있다. 
uniform_int_distribution uid{ 0,999'9999 }; 


//[문제] 랜덤 int 값 1000개를 파일"int 1000개.txt" 에 텍스트 모드로 저장하라
// 파일을 열었을 때 사람이 읽을 수 있어야 한다.
// 파일을 읽어서 원래 int값을 가져올 수 있어야 한다.


//----------
int main()
//----------
{
    ofstream out{ "int 1000개.txt"}; //RAII 하면 굳이 out.close()를 해줄 필요가 없다

    for (int i = 0; i < 1000; ++i)
        print( out,"{:8} , ", uid(dre)); //구분자 ,delimeter

    ifstream in;

	save("메인.cpp");	

}

==============================================
저장한 시간 :2025-03-13 오후 4:39:18 목요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 13일 목요일      (2주 2일차 강의) 
//-------------------------------------------------------------------------------------------
//   많은 수의 자료를 처리하기
//
//-------------------------------------------------------------------------------------------
#include<iostream>
#include <random>
#include<print>
#include<fstream>
#include"save.h"

using namespace std;

default_random_engine dre{  }; //엔진의 시드를 설정할 수 있다. 
uniform_int_distribution uid{ 0,999'9999 }; 


//[문제] 랜덤 int 값 1000개를 파일"int 1000개.txt" 에 텍스트 모드로 저장하라
// 파일을 열었을 때 사람이 읽을 수 있어야 한다.
// 파일을 읽어서 원래 int값을 가져올 수 있어야 한다.


//----------
int main()
//----------
{
    ofstream out{ "int 1000개.txt"}; //RAII 하면 굳이 out.close()를 해줄 필요가 없다
    int cnt{};
    for (int i = 0; i < 1000; ++i) {
        print(out, "{:8} , ", uid(dre)); //구분자 ,delimeter
        if (not(++cnt % 10))
            cout << endl;
    }

    ifstream in;

	save("메인.cpp");	

}

==============================================
저장한 시간 :2025-03-13 오후 4:39:32 목요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 13일 목요일      (2주 2일차 강의) 
//-------------------------------------------------------------------------------------------
//   많은 수의 자료를 처리하기
//
//-------------------------------------------------------------------------------------------
#include<iostream>
#include <random>
#include<print>
#include<fstream>
#include"save.h"

using namespace std;

default_random_engine dre{  }; //엔진의 시드를 설정할 수 있다. 
uniform_int_distribution uid{ 0,999'9999 }; 


//[문제] 랜덤 int 값 1000개를 파일"int 1000개.txt" 에 텍스트 모드로 저장하라
// 파일을 열었을 때 사람이 읽을 수 있어야 한다.
// 파일을 읽어서 원래 int값을 가져올 수 있어야 한다.


//----------
int main()
//----------
{
    ofstream out{ "int 1000개.txt"}; //RAII 하면 굳이 out.close()를 해줄 필요가 없다
    int cnt{};
    for (int i = 0; i < 1000; ++i) {
        print(out, "{:8} , ", uid(dre)); //구분자 ,delimeter
        if (not(++cnt % 10))
            out << endl;
    }

    ifstream in;

	save("메인.cpp");	

}

==============================================
저장한 시간 :2025-03-13 오후 4:40:05 목요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 13일 목요일      (2주 2일차 강의) 
//-------------------------------------------------------------------------------------------
//   많은 수의 자료를 처리하기
//
//-------------------------------------------------------------------------------------------
#include<iostream>
#include <random>
#include<print>
#include<fstream>
#include"save.h"

using namespace std;

default_random_engine dre{  }; //엔진의 시드를 설정할 수 있다. 
uniform_int_distribution uid{ 0,999'9999 }; 


//[문제] 랜덤 int 값 1000개를 파일"int 1000개.txt" 에 텍스트 모드로 저장하라
// 파일을 열었을 때 사람이 읽을 수 있어야 한다.
// 파일을 읽어서 원래 int값을 가져올 수 있어야 한다.


//----------
int main()
//----------
{
    ofstream out{ "int 1000개.txt"}; //RAII 하면 굳이 out.close()를 해줄 필요가 없다
    int cnt{};
    for (int i = 0; i < 1000; ++i) {
        print(out, "{:8} , ", uid(dre)); //구분자 ,delimeter
        if (not( ++cnt % 10))
            out << endl;
    }

    ifstream in;

	save("메인.cpp");	

}

==============================================
저장한 시간 :2025-03-13 오후 4:40:57 목요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 13일 목요일      (2주 2일차 강의) 
//-------------------------------------------------------------------------------------------
//   많은 수의 자료를 처리하기
//
//-------------------------------------------------------------------------------------------
#include<iostream>
#include <random>
#include<print>
#include<fstream>
#include"save.h"

using namespace std;

default_random_engine dre{  }; //엔진의 시드를 설정할 수 있다. 
uniform_int_distribution uid{ 0,999'9999 }; 


//[문제] 



//----------
int main()
//----------
{
    ofstream out{ "int 1000개.txt"}; //RAII 하면 굳이 out.close()를 해줄 필요가 없다
    int cnt{};
    for (int i = 0; i < 1000; ++i) {
        print(out, "{:8}", uid(dre)); //구분자 ,delimeter
        if (not( ++cnt % 10))
            out << endl;
    }

    ifstream in;

	save("메인.cpp");	

}

==============================================
저장한 시간 :2025-03-13 오후 4:43:33 목요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 13일 목요일      (2주 2일차 강의) 
//-------------------------------------------------------------------------------------------
//   많은 수의 자료를 처리하기
//
//-------------------------------------------------------------------------------------------
#include<iostream>
#include <random>
#include<print>
#include<fstream>
#include<array>
#include<algorithm>
#include"save.h"

using namespace std;

default_random_engine dre{  }; //엔진의 시드를 설정할 수 있다. 
uniform_int_distribution uid{ 0,999'9999 }; 


//[문제] 파일 "int 100개.txt"에는 intㄱ밧 100개가 text로 기록되어 있다.
// 가장 큰 값을 찾아 화면에 출력하라. 출력된 값이 무엇인지 적어라



//----------
int main()
//----------
{
   
    ifstream in{ "int 1000개.txt" };
    array<int, 1000> arr;
    for (int i = 0; i < 1000; ++i) {
        in >> arr[i];
    }
    cout << *max_element(arr.begin(), arr.end());

	save("메인.cpp");	

}

==============================================
저장한 시간 :2025-03-13 오후 4:43:51 목요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 13일 목요일      (2주 2일차 강의) 
//-------------------------------------------------------------------------------------------
//   많은 수의 자료를 처리하기
//
//-------------------------------------------------------------------------------------------
#include<iostream>
#include <random>
#include<print>
#include<fstream>
#include<array>
#include<algorithm>
#include"save.h"

using namespace std;

default_random_engine dre{  }; //엔진의 시드를 설정할 수 있다. 
uniform_int_distribution uid{ 0,999'9999 }; 


//[문제] 파일 "int 100개.txt"에는 intㄱ밧 100개가 text로 기록되어 있다.
// 가장 큰 값을 찾아 화면에 출력하라. 출력된 값이 무엇인지 적어라



//----------
int main()
//----------
{
   
    ifstream in{ "int 1000개.txt" };
    array<int, 1000> arr;
    for (int i = 0; i < 1000; ++i) {
        in >> arr[i];
    }
    cout << "가장 큰 값은 :" << *max_element(arr.begin(), arr.end()) << endl;

	save("메인.cpp");	

}

==============================================
저장한 시간 :2025-03-13 오후 4:44:51 목요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 13일 목요일      (2주 2일차 강의) 
//-------------------------------------------------------------------------------------------
//   많은 수의 자료를 처리하기
//
//-------------------------------------------------------------------------------------------
#include<iostream>
#include <random>
#include<print>
#include<fstream>
#include<array>
#include<algorithm>
#include"save.h"

using namespace std;

default_random_engine dre{  }; //엔진의 시드를 설정할 수 있다. 
uniform_int_distribution uid{ 0,999'9999 }; 


//[문제] 파일 "int 100개.txt"에는 intㄱ밧 100개가 text로 기록되어 있다.
// 가장 큰 값을 찾아 화면에 출력하라. 출력된 값이 무엇인지 적어라



//----------
int main()
//----------
{
   
    ifstream in{ "int 1000개.txt" };
    array<int, 1000> arr;
    for (int i = 0; i < 1000; ++i) {
        in >> arr[i];
    }
    cout << "가장 큰 값은 :" << *max_element(arr.begin(), arr.end()) << endl;
    for (auto num : arr) {
        print("{:8}", num);
    }

	save("메인.cpp");	

}

==============================================
저장한 시간 :2025-03-13 오후 4:50:49 목요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 13일 목요일      (2주 2일차 강의) 
//-------------------------------------------------------------------------------------------
//   많은 수의 자료를 처리하기
//
//-------------------------------------------------------------------------------------------
#include<iostream>
#include<random>
#include<print>
#include<fstream>
#include<array>
#include<algorithm>
#include"save.h"

using namespace std;

default_random_engine dre{  }; //엔진의 시드를 설정할 수 있다. 
uniform_int_distribution uid{ 0,999'9999 }; 


//[문제] 파일 "int 100개.txt"에는 int 1000개가 text로 기록되어 있다.
// 가장 큰 값을 찾아 화면에 출력하라. 출력된 값이 무엇인지 적어라



//----------
int main()
//----------
{
   
    ifstream in{ "int 1000개.txt" };
    if (not in)
        return 20250313;

    int num;
    int maxValue{ numeric_limits<int> ::min() };
    while (in >> num) {
        if (maxValue > num)
            maxValue = num;
    }
    cout << "최댓값은 :" << maxValue;
	save("메인.cpp");	

}

==============================================
저장한 시간 :2025-03-13 오후 4:51:49 목요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 13일 목요일      (2주 2일차 강의) 
//-------------------------------------------------------------------------------------------
//   많은 수의 자료를 처리하기
//
//-------------------------------------------------------------------------------------------
#include<iostream>
#include<random>
#include<print>
#include<fstream>
#include<array>
#include<algorithm>
#include"save.h"

using namespace std;

default_random_engine dre{  }; //엔진의 시드를 설정할 수 있다. 
uniform_int_distribution uid{ 0,999'9999 }; 


//[문제] 파일 "int 100개.txt"에는 int 1000개가 text로 기록되어 있다.
// 가장 큰 값을 찾아 화면에 출력하라. 출력된 값이 무엇인지 적어라



//----------
int main()
//----------
{
   
    ifstream in{ "int 1000개.txt" };
    if (not in)
        return 20250313;

    int num;
    int maxValue{ numeric_limits<int> ::min() };
    size_t cnt{ };

    while (in >> num) {
        ++cnt;
        if (maxValue > num)
            maxValue = num;
    }
    cout << "개수 :" << cnt << endl;
    cout << "최댓값은 :" << maxValue << endl;
	save("메인.cpp");	

}

==============================================
저장한 시간 :2025-03-13 오후 4:52:06 목요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 13일 목요일      (2주 2일차 강의) 
//-------------------------------------------------------------------------------------------
//   많은 수의 자료를 처리하기
//
//-------------------------------------------------------------------------------------------
#include<iostream>
#include<random>
#include<print>
#include<fstream>
#include<array>
#include<algorithm>
#include"save.h"

using namespace std;

default_random_engine dre{  }; //엔진의 시드를 설정할 수 있다. 
uniform_int_distribution uid{ 0,999'9999 }; 


//[문제] 파일 "int 100개.txt"에는 int 1000개가 text로 기록되어 있다.
// 가장 큰 값을 찾아 화면에 출력하라. 출력된 값이 무엇인지 적어라



//----------
int main()
//----------
{
   
    ifstream in{ "int 1000개.txt" };
    if (not in)
        return 20250313;

    int num;
    int maxValue{ numeric_limits<int> ::min() };
    size_t cnt{ };

    while (in >> num) {
        ++cnt;
        if (maxValue < num)
            maxValue = num;
    }
    cout << "개수 :" << cnt << endl;
    cout << "최댓값은 :" << maxValue << endl;
	save("메인.cpp");	

}

==============================================
저장한 시간 :2025-03-13 오후 4:57:37 목요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 13일 목요일      (2주 2일차 강의) 
//-------------------------------------------------------------------------------------------
//   많은 수의 자료를 처리하기
//
//-------------------------------------------------------------------------------------------
#include<iostream>
#include<random>
#include<print>
#include<fstream>
#include<array>
#include<algorithm>
#include"save.h"

using namespace std;

default_random_engine dre{  }; //엔진의 시드를 설정할 수 있다. 
uniform_int_distribution uid{ 0,999'9999 }; 


//[문제] 파일 "int 100개.txt"에는 int 1000개가 text로 기록되어 있다.
// 가장 큰 값을 찾아 화면에 출력하라. 출력된 값이 무엇인지 적어라



//----------
int main()
//----------
{
   
    ifstream in{ "int 1000개.txt" };
    if (not in)
        return 20250313;
    cout<<"최댓값은:"<<*max_element(istream_iterator<int>{in}, {}); //별 3개를 건너뛰고 이런코딩도 가능하다

	save("메인.cpp");	

}

==============================================
저장한 시간 :2025-03-13 오후 4:58:39 목요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 13일 목요일      (2주 2일차 강의) 
//-------------------------------------------------------------------------------------------
//   많은 수의 자료를 처리하기
//
//-------------------------------------------------------------------------------------------
#include<iostream>
#include<random>
#include<print>
#include<fstream>
#include<array>
#include<algorithm>
#include"save.h"

using namespace std;

default_random_engine dre{  }; //엔진의 시드를 설정할 수 있다. 
uniform_int_distribution uid{ 0,999'9999 }; 


//[문제] 파일 "int 100개.txt"에는 int 1000개가 text로 기록되어 있다.
// 가장 큰 값을 찾아 화면에 출력하라. 출력된 값이 무엇인지 적어라



//----------
int main()
//----------
{
   
    ifstream in{ "int 1000개.txt" };
    if (not in)
        return 20250313;
    cout<<"최댓값은:"<<*max_element(istream_iterator<int>{in}, {})<<endl; //별 3개를 건너뛰고 이런코딩도 가능하다

	save("메인.cpp");	

}

==============================================
저장한 시간 :2025-03-13 오후 5:03:27 목요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 13일 목요일      (2주 2일차 강의) 
//-------------------------------------------------------------------------------------------
//   많은 수의 자료를 처리하기
//
//-------------------------------------------------------------------------------------------
#include<iostream>
#include<random>
#include<print>
#include<fstream>
#include<array>
#include<algorithm>
#include"save.h"

using namespace std;

default_random_engine dre{  }; //엔진의 시드를 설정할 수 있다. 
uniform_int_distribution uid{ 0,999'9999 }; 


//[문제] 파일 "int 100개.txt"에는 int 1000개가 text로 기록되어 있다.
// 이 데이터를 메모리에 저장하라.
// 메모리에 있는 데이터를 화면에 출력하시오.



//----------
int main()
//----------
{
   
    ifstream in{ "int 1000개.txt" };
    if (not in)
        return 20250313;
    
    array<int, 1000> arr;
    for (int i = 0; i < 1000; ++i) {
        in >> arr[i];
    }
    for (auto num : arr) {
        print("{:8}", num);
    }
	save("메인.cpp");	

}

==============================================
저장한 시간 :2025-03-18 오후 1:45:21 화요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 13일 목요일      (2주 2일차 강의) 
//-------------------------------------------------------------------------------------------
//   많은 수의 자료를 처리하기
//
//-------------------------------------------------------------------------------------------
#include<iostream>
#include<bitset>
#include<algorithm>
#include"save.h"

using namespace std;


//[문제] 파일 "int 100개.txt"에는 int 1000개가 text로 기록되어 있다.
//  int 1000개를 저장하기 위해 몇 바이트를 사용했는가?? 8200




//----------
int main()
//----------
{
	int num{ 0x01'02'03'04 };
	cout << "16진수 -" << hex << num << endl;
	cout << "10진수 -" << num << endl;
	bitset<32>binary =  num ;
	cout << "2진수 -" << binary << endl;
	save("메인.cpp");	
}

==============================================
저장한 시간 :2025-03-18 오후 1:45:38 화요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 13일 목요일      (2주 2일차 강의) 
//-------------------------------------------------------------------------------------------
//   많은 수의 자료를 처리하기
//
//-------------------------------------------------------------------------------------------
#include<iostream>
#include<bitset>
#include<algorithm>
#include"save.h"

using namespace std;


//[문제] 파일 "int 100개.txt"에는 int 1000개가 text로 기록되어 있다.
//  int 1000개를 저장하기 위해 몇 바이트를 사용했는가?? 8200




//----------
int main()
//----------
{
	int num{ 0x01'02'03'04 };
	cout << "16진수 -" << hex << num << endl;
	cout << "10진수 -" << num << endl;
	bitset<32>binary =  num ;
	cout << " 2진수  -" << binary << endl;
	save("메인.cpp");	
}

==============================================
저장한 시간 :2025-03-18 오후 1:45:48 화요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 13일 목요일      (2주 2일차 강의) 
//-------------------------------------------------------------------------------------------
//   많은 수의 자료를 처리하기
//
//-------------------------------------------------------------------------------------------
#include<iostream>
#include<bitset>
#include<algorithm>
#include"save.h"

using namespace std;


//[문제] 파일 "int 100개.txt"에는 int 1000개가 text로 기록되어 있다.
//  int 1000개를 저장하기 위해 몇 바이트를 사용했는가?? 8200




//----------
int main()
//----------
{
	int num{ 0x01'02'03'04 };
	cout << "16진수 -" << hex << num << endl;
	cout << "10진수 -" << num << endl;
	bitset<32>binary =  num ;
	cout << " 2진수 -" << binary << endl;
	save("메인.cpp");	
}

==============================================
저장한 시간 :2025-03-18 오후 1:47:05 화요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 13일 목요일      (2주 2일차 강의) 
//-------------------------------------------------------------------------------------------
//   많은 수의 자료를 처리하기
//
//-------------------------------------------------------------------------------------------
#include<iostream>
#include<bitset>
#include<algorithm>
#include"save.h"

using namespace std;


//[문제] 파일 "int 100개.txt"에는 int 1000개가 text로 기록되어 있다.
//  int 1000개를 저장하기 위해 몇 바이트를 사용했는가?? 8200




//----------
int main()
//----------
{
	int num{ 0x01'02'03'04 };
	bitset<32>binary = num;
	cout << " 2진수 -" << binary << endl;
	cout << "10진수 -" << num << endl;
	cout << "16진수 -" << hex << num << endl;
	
	
	save("메인.cpp");	
}

==============================================
저장한 시간 :2025-03-18 오후 1:55:47 화요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 13일 목요일      (2주 2일차 강의) 
//-------------------------------------------------------------------------------------------
//   많은 수의 자료를 처리하기
//
//-------------------------------------------------------------------------------------------
// 
//-------------------------------------------------------------------------------------------
#include<iostream>
#include<array>
#include"save.h"

using namespace std;


//[문제] 메모리에 저장된 bit를 그대로 파일에 저장할 수 잇다.
// -> 저수준 입출력 함수를 사용한다.




//----------
int main()
//----------
{
	array<int, 1000> a;
	for (int num : a) {
		cout << num << " ";
	}
	cout << endl;
	
	save("메인.cpp");	
}

==============================================
저장한 시간 :2025-03-18 오후 1:56:21 화요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 13일 목요일      (2주 2일차 강의) 
//-------------------------------------------------------------------------------------------
//   많은 수의 자료를 처리하기
//
//-------------------------------------------------------------------------------------------
// 
//-------------------------------------------------------------------------------------------
#include<iostream>
#include<array>
#include"save.h"

using namespace std;


//[문제] 메모리에 저장된 bit를 그대로 파일에 저장할 수 잇다.
// -> 저수준 입출력 함수를 사용한다.




//----------
int main()
//----------
{
	array<int, 1000> a; //초기화가 되는지 확인해보자.
	for (int num : a) {
		cout << num << " ";
	}
	//초기화 되어있지 않다는것을 확인
	cout << endl;
	
	save("메인.cpp");	
}

==============================================
저장한 시간 :2025-03-18 오후 1:56:42 화요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 13일 목요일      (2주 2일차 강의) 
//-------------------------------------------------------------------------------------------
//   많은 수의 자료를 처리하기
//
//-------------------------------------------------------------------------------------------
// 
//-------------------------------------------------------------------------------------------
#include<iostream>
#include<array>
#include"save.h"

using namespace std;


//[문제] 메모리에 저장된 bit를 그대로 파일에 저장할 수 잇다.
// -> 저수준 입출력 함수를 사용한다.




//----------
int main()
//----------
{
	array<int, 1000> a{ }; //초기화가 되는지 확인해보자.
	for (int num : a) {
		cout << num << " ";
	}
	//초기화 되어있지 않다는것을 확인
	cout << endl;
	
	save("메인.cpp");	
}

==============================================
저장한 시간 :2025-03-18 오후 1:56:51 화요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 13일 목요일      (2주 2일차 강의) 
//-------------------------------------------------------------------------------------------
//   많은 수의 자료를 처리하기
//
//-------------------------------------------------------------------------------------------
// 
//-------------------------------------------------------------------------------------------
#include<iostream>
#include<array>
#include"save.h"

using namespace std;


//[문제] 메모리에 저장된 bit를 그대로 파일에 저장할 수 잇다.
// -> 저수준 입출력 함수를 사용한다.




//----------
int main()
//----------
{
	array<int, 1000> a{ }; //초기화가 되는지 확인해보자.
	for (int num : a) {
		cout << num << " ";
	}
	//초기화 된다
	cout << endl;
	
	save("메인.cpp");	
}

==============================================
저장한 시간 :2025-03-18 오후 1:57:22 화요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 13일 목요일      (2주 2일차 강의) 
//-------------------------------------------------------------------------------------------
//   많은 수의 자료를 처리하기
//
//-------------------------------------------------------------------------------------------
// 
//-------------------------------------------------------------------------------------------
#include<iostream>
#include<array>
#include"save.h"

using namespace std;


//[문제] 메모리에 저장된 bit를 그대로 파일에 저장할 수 잇다.
// -> 저수준 입출력 함수를 사용한다.




//----------
int main()
//----------
{
	array<int, 1000> a; //초기화가 되는지 확인해보자.
	a.fill(333);
	for (int num : a) {
		cout << num << " ";
	}
	//초기화 된다
	cout << endl;
	
	save("메인.cpp");	
}

==============================================
저장한 시간 :2025-03-18 오후 1:58:36 화요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 13일 목요일      (2주 2일차 강의) 
//-------------------------------------------------------------------------------------------
//   많은 수의 자료를 처리하기
//
//-------------------------------------------------------------------------------------------
// 
//-------------------------------------------------------------------------------------------
#include<iostream>
#include<array>
#include"save.h"

using namespace std;


//[문제] 메모리에 저장된 bit를 그대로 파일에 저장할 수 잇다.
// -> 저수준 입출력 함수를 사용한다.




//----------
int main()
//----------
{
	array<int, 1000> a; //초기화가 되는지 확인해보자.
	int i{ };
	for (int num : a)
		num = ++i;
	for (int num : a) {
		cout << num << " ";
	}
	//초기화 된다
	cout << endl;
	
	save("메인.cpp");	
}

==============================================
저장한 시간 :2025-03-18 오후 1:59:11 화요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 13일 목요일      (2주 2일차 강의) 
//-------------------------------------------------------------------------------------------
//   많은 수의 자료를 처리하기
//
//-------------------------------------------------------------------------------------------
// 
//-------------------------------------------------------------------------------------------
#include<iostream>
#include<array>
#include"save.h"

using namespace std;


//[문제] 메모리에 저장된 bit를 그대로 파일에 저장할 수 잇다.
// -> 저수준 입출력 함수를 사용한다.




//----------
int main()
//----------
{
	array<int, 1000> a; //초기화가 되는지 확인해보자.


	int i{ };
	for (int& num : a)
		num = ++i;  //노는 지역이 달라서 안된다
	for (int num : a) {
		cout << num << " ";
	}
	//초기화 된다
	cout << endl;
	
	save("메인.cpp");	
}

==============================================
저장한 시간 :2025-03-18 오후 2:00:35 화요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 13일 목요일      (2주 2일차 강의) 
//-------------------------------------------------------------------------------------------
//   많은 수의 자료를 처리하기
//
//-------------------------------------------------------------------------------------------
// 
//-------------------------------------------------------------------------------------------
#include<iostream>
#include<array>
#include<numeric>
#include"save.h"

using namespace std;


//[문제] 메모리에 저장된 bit를 그대로 파일에 저장할 수 잇다.
// -> 저수준 입출력 함수를 사용한다.




//----------
int main()
//----------
{
	array<int, 1000> a; //초기화가 되는지 확인해보자.

	iota(a.begin(), a.end(), 1); //a의 시작부터 b의 끝까지 1씩 증가시켜서 넣어줘
	
	for (int num : a) {
		cout << num << " ";
	}
	//초기화 된다
	cout << endl;
	
	save("메인.cpp");	
}

==============================================
저장한 시간 :2025-03-18 오후 2:12:43 화요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 13일 목요일      (2주 2일차 강의) 
//-------------------------------------------------------------------------------------------
//   많은 수의 자료를 처리하기
//
//-------------------------------------------------------------------------------------------
// 
//-------------------------------------------------------------------------------------------
#include<iostream>
#include<array>
#include<numeric>
#include<fstream>
#include"save.h"

using namespace std;







//----------
int main()
//----------
{
	array<int, 1000> a;
	iota(a.begin(), a.end(), 1); //a의 시작부터 b의 끝까지 1부터 1씩 증가시켜서 넣어줘

	//[문제] a의 data를 파일 "int 1000개 메모리 그대로" 에 기록하자
	
	ofstream out{ "int 1000개 메모리 그대로" };
	out.write((char*)a.data(), sizeof(int) * a.size()); //이파일에 메모리 그대로 입력하겠어 a.data() 어디다 저장했는지 알려준다. int가 들어있는 곳을 알려줌
	
	save("메인.cpp");	
}

==============================================
저장한 시간 :2025-03-18 오후 2:14:10 화요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 13일 목요일      (2주 2일차 강의) 
//-------------------------------------------------------------------------------------------
//   많은 수의 자료를 처리하기
//
//-------------------------------------------------------------------------------------------
// 
//-------------------------------------------------------------------------------------------
#include<iostream>
#include<array>
#include<numeric>
#include<fstream>
#include"save.h"

using namespace std;







//----------
int main()
//----------
{
	array<int, 1000> a;
	iota(a.begin(), a.end(), 1); //a의 시작부터 b의 끝까지 1부터 1씩 증가시켜서 넣어줘

	cout << "a에 들어있는 int 개수 -" << a.size() << endl;
	//[문제] a의 data를 파일 "int 1000개 메모리 그대로" 에 기록하자
	
	ofstream out{ "int 1000개 메모리 그대로" };
	out.write((char*)a.data(), sizeof(int) * a.size()); //이파일에 메모리 그대로 입력하겠어 a.data() 어디다 저장했는지 알려준다. int가 들어있는 곳을 알려줌
	
	save("메인.cpp");	
}

==============================================
저장한 시간 :2025-03-18 오후 2:17:22 화요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 13일 목요일      (2주 2일차 강의) 
//-------------------------------------------------------------------------------------------
//   많은 수의 자료를 처리하기
//
//-------------------------------------------------------------------------------------------
// 
//-------------------------------------------------------------------------------------------
#include<iostream>
#include<array>
#include<numeric>
#include<fstream>
#include"save.h"

using namespace std;







//----------
int main()
//----------
{
	array<int, 1000> a;
	iota(a.begin(), a.end(), 1); //a의 시작부터 b의 끝까지 1부터 1씩 증가시켜서 넣어줘

	cout << "a에 들어있는 int 개수 -" << a.size() << endl;
	//[문제] a의 data를 파일 "int 1000개 메모리 그대로" 에 기록하자
	
	ofstream out{ "int 1000개 메모리 그대로" ,ios::binary };  //파일을 텍스트 모드로 열었다
	out.write((char*)a.data(), sizeof(int) * a.size()); //이파일에 메모리 그대로 입력하겠어 a.data() 어디다 저장했는지 알려준다. int가 들어있는 곳을 알려줌
	
	save("메인.cpp");	
}

==============================================
저장한 시간 :2025-03-18 오후 2:20:34 화요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 13일 목요일      (2주 2일차 강의) 
//-------------------------------------------------------------------------------------------
//   많은 수의 자료를 처리하기
//
//-------------------------------------------------------------------------------------------
// 
//-------------------------------------------------------------------------------------------
#include<iostream>
#include<array>
#include<numeric>
#include<fstream>
#include"save.h"

using namespace std;







//----------
int main()
//----------
{
	array<int, 1000> a;
	a.fill(0x0a0a0a);
	
	ofstream out{ "int 1000개 메모리 그대로"};
	out.write((char*)a.data(), sizeof(int) * a.size()); //이파일에 메모리 그대로 입력하겠어 a.data() 어디다 저장했는지 알려준다. int가 들어있는 곳을 알려줌
	
	save("메인.cpp");	
}

==============================================
저장한 시간 :2025-03-18 오후 2:35:57 화요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 13일 목요일      (2주 2일차 강의) 
//-------------------------------------------------------------------------------------------
//   많은 수의 자료를 처리하기 -binary I/O
//          ->파일을 binary 모드로 열어야 변환이 일어나지 않는다.
//-------------------------------------------------------------------------------------------
// 
//-------------------------------------------------------------------------------------------
#include<iostream>
#include<fstream>
#include<random>
#include"save.h"

using namespace std;

//파일 "int 10만개에를 바이너리모드 wirte 함수로 기록" 에 10만개의 random int 값을 기록하자.
//이 int값은 메모리 크기 그대로 기록하겠다.
//파일은 binary mode로 열자.


default_random_engine dre;


//----------
int main()
//----------
{
	ofstream out{ "int 10만개에를 바이너리모드 wirte 함수로 기록", ios::binary };

	uniform_int_distribution uid{ numeric_limits<int>::min(),numeric_limits<int>::max() }; //int의 최소부터 최댓값까지

	int num; //이게 훨씬 좋은 방법
	for (int i = 0; i < 10'0000; ++i) {
		num = uid(dre);
		out.write((char *)&num, sizeof(int)); //바이트 단위만 다룸으로 바이트 주소임을 알려줌
	}
	save("메인.cpp");	
}

==============================================
저장한 시간 :2025-03-18 오후 2:47:20 화요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 13일 목요일      (2주 2일차 강의) 
//-------------------------------------------------------------------------------------------
//   많은 수의 자료를 처리하기 -binary I/O
//          ->파일을 binary 모드로 열어야 변환이 일어나지 않는다.
//-------------------------------------------------------------------------------------------
// 
//-------------------------------------------------------------------------------------------
#include<iostream>
#include<fstream>
#include<array>
#include"save.h"

using namespace std;

//binary로 열어 기록한 파일 "int 10만개에를 바이너리모드 wirte 함수로 기록" 에는,
//int값 10만개가 메모리 크기 그대로 기록되어 있다. (ostream의 wirte 함수를 사용)
// int값 10만개를 읽어서 메모리에 저장하시오.
// 가장 작은 값을 찾아 화면에 출력하라.
// 화면에 출력된 값도 답지에 적어라.





//----------
int main()
//----------
{
	array<int, 100000> p;
	ifstream in{ "int 10만개에를 바이너리모드 wirte 함수로 기록",ios::binary };
	in.read((char*)(p.data()),  sizeof(int)*p.size() );
	cout << "가장 작은 수 :" << *min_element(p.begin(), p.end()) << endl;
	save("메인.cpp");	
}

==============================================
저장한 시간 :2025-03-18 오후 2:47:58 화요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 13일 목요일      (2주 2일차 강의) 
//-------------------------------------------------------------------------------------------
//   많은 수의 자료를 처리하기 -binary I/O
//          ->파일을 binary 모드로 열어야 변환이 일어나지 않는다.
//-------------------------------------------------------------------------------------------
// 
//-------------------------------------------------------------------------------------------
#include<iostream>
#include<fstream>
#include<array>
#include"save.h"

using namespace std;

//binary로 열어 기록한 파일 "int 10만개에를 바이너리모드 wirte 함수로 기록" 에는,
//int값 10만개가 메모리 크기 그대로 기록되어 있다. (ostream의 wirte 함수를 사용)
// int값 10만개를 읽어서 메모리에 저장하시오.
// 가장 작은 값을 찾아 화면에 출력하라.
// 화면에 출력된 값도 답지에 적어라.





//----------
int main()
//----------
{
	array<int, 100000> p;
	ifstream in{ "int 10만개에를 바이너리모드 wirte 함수로 기록",ios::binary };
	in.read((char*)(p.data()),  sizeof(int)*p.size() );
	cout << "가장 작은 수 :" << *min_element(p.begin(), p.end()) << endl;
	save("메인.cpp");	
}

==============================================
저장한 시간 :2025-03-18 오후 2:50:15 화요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 13일 목요일      (2주 2일차 강의) 
//-------------------------------------------------------------------------------------------
//   많은 수의 자료를 처리하기 -binary I/O
//          ->파일을 binary 모드로 열어야 변환이 일어나지 않는다.
//-------------------------------------------------------------------------------------------
// 
//-------------------------------------------------------------------------------------------
#include<iostream>
#include<fstream>
#include<array>
#include"save.h"

using namespace std;

//binary로 열어 기록한 파일 "int 10만개에를 바이너리모드 wirte 함수로 기록" 에는,
//int값 10만개가 메모리 크기 그대로 기록되어 있다. (ostream의 wirte 함수를 사용)
// int값 10만개를 읽어서 메모리에 저장하시오.
// 가장 작은 값을 찾아 화면에 출력하라.
// 화면에 출력된 값도 답지에 적어라.





//----------
int main()
//----------
{
	array<int, 100000> p;
	ifstream in{ "int 10만개에를 바이너리모드 wirte 함수로 기록",ios::binary };
	if (!in) {
		cerr << "파일을 열 수 없습니다." << endl;
		return 1;
	}
	in.read((char*)(p.data()),  sizeof(int)*p.size() );
	if (!in) {
		cerr << "파일을 열 수 없습니다." << endl;
		return 1;
	}

	cout << "가장 작은 수 :" << *min_element(p.begin(), p.end()) << endl;
	save("메인.cpp");	
}

==============================================
저장한 시간 :2025-03-18 오후 2:57:50 화요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 13일 목요일      (2주 2일차 강의) 
//-------------------------------------------------------------------------------------------
//   많은 수의 자료를 처리하기 -binary I/O
//          ->파일을 binary 모드로 열어야 변환이 일어나지 않는다.
//-------------------------------------------------------------------------------------------
// 
//-------------------------------------------------------------------------------------------
#include<iostream>
#include<fstream>
#include<array>
#include<algorithm>
#include"save.h"

using namespace std;

//binary로 열어 기록한 파일 "int 10만개에를 바이너리모드 wirte 함수로 기록" 에는,
//int값 10만개가 메모리 크기 그대로 기록되어 있다. (ostream의 wirte 함수를 사용)
// int값 10만개를 읽어서 메모리에 저장하시오.
// 가장 작은 값을 찾아 화면에 출력하라.
// 화면에 출력된 값도 답지에 적어라.





//----------
int main()
//----------
{
	
	ifstream in{ "int 10만개에를 바이너리모드 wirte 함수로 기록",ios::binary }; //읽을때도 바이너리로 열었다 텍스트로 열었어도 큰 지장은 없을 텐데....
	if (not in) {
		return 20250318;
	}
	array<int, 100000> a;
	for (int& num : a)
		in.read((char*)&num, sizeof(int));

	cout << "가장 작은 수 :" << *min_element(a.begin(), a.end()) << endl;
	save("메인.cpp");	
}

==============================================
저장한 시간 :2025-03-18 오후 2:58:39 화요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 13일 목요일      (2주 2일차 강의) 
//-------------------------------------------------------------------------------------------
//   많은 수의 자료를 처리하기 -binary I/O
//          ->파일을 binary 모드로 열어야 변환이 일어나지 않는다.
//-------------------------------------------------------------------------------------------
// 
//-------------------------------------------------------------------------------------------
#include<iostream>
#include<fstream>
#include<array>
#include<algorithm>
#include"save.h"

using namespace std;

//binary로 열어 기록한 파일 "int 10만개에를 바이너리모드 wirte 함수로 기록" 에는,
//int값 10만개가 메모리 크기 그대로 기록되어 있다. (ostream의 wirte 함수를 사용)
// int값 10만개를 읽어서 메모리에 저장하시오.
// 가장 작은 값을 찾아 화면에 출력하라.
// 화면에 출력된 값도 답지에 적어라.





//----------
int main()
//----------
{
	
	ifstream in{ "int 10만개에를 바이너리모드 wirte 함수로 기록",ios::binary }; //읽을때도 바이너리로 열었다 텍스트로 열었어도 큰 지장은 없을 텐데....
	if (not in) {
		return 20250318;
	}
	array<int, 100000> a;
	for (int& num : a)
		in.read((char*)&num, sizeof(int));

	cout << "가장 작은 수 :" << *min_element(a.begin(), a.end()) << endl;
	save("메인.cpp");	
}

==============================================
저장한 시간 :2025-03-18 오후 2:59:33 화요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 13일 목요일      (2주 2일차 강의) 
//-------------------------------------------------------------------------------------------
//   많은 수의 자료를 처리하기 -binary I/O
//          ->파일을 binary 모드로 열어야 변환이 일어나지 않는다.
//-------------------------------------------------------------------------------------------
// 
//-------------------------------------------------------------------------------------------
#include<iostream>
#include<fstream>
#include<array>
#include<algorithm>
#include"save.h"

using namespace std;

//binary로 열어 기록한 파일 "int 10만개에를 바이너리모드 wirte 함수로 기록" 에는,
//int값 10만개가 메모리 크기 그대로 기록되어 있다. (ostream의 wirte 함수를 사용)
// int값 10만개를 읽어서 메모리에 저장하시오.
// 가장 작은 값을 찾아 화면에 출력하라.
// 화면에 출력된 값도 답지에 적어라.





//----------
int main()
//----------
{
	
	ifstream in{ "int 10만개에를 바이너리모드 wirte 함수로 기록" }; //읽을때도 바이너리로 열었다 텍스트로 열었어도 큰 지장은 없을 텐데....
	if (not in) {
		return 20250318;
	}
	array<int, 100000> a;
	for (int& num : a)
		in.read((char*)&num, sizeof(int));

	cout << "가장 작은 수 :" << *min_element(a.begin(), a.end()) << endl;
	//가장 작은 수 :-2147431498
	save("메인.cpp");	
}

==============================================
저장한 시간 :2025-03-18 오후 3:01:46 화요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 13일 목요일      (2주 2일차 강의) 
//-------------------------------------------------------------------------------------------
//   많은 수의 자료를 처리하기 -binary I/O
//          ->파일을 binary 모드로 열어야 변환이 일어나지 않는다.
//-------------------------------------------------------------------------------------------
// 
//-------------------------------------------------------------------------------------------
#include<iostream>
#include<fstream>
#include<array>
#include<algorithm>
#include"save.h"

using namespace std;

//binary로 열어 기록한 파일 "int 10만개에를 바이너리모드 wirte 함수로 기록" 에는,
//int값 10만개가 메모리 크기 그대로 기록되어 있다. (ostream의 wirte 함수를 사용)
// int값 10만개를 읽어서 메모리에 저장하시오.
// 가장 작은 값을 찾아 화면에 출력하라.
// 화면에 출력된 값도 답지에 적어라.





//----------
int main()
//----------
{
	
	ifstream in{ "int 10만개에를 바이너리모드 wirte 함수로 기록" }; //읽을때도 바이너리로 열었다 텍스트로 열었어도 큰 지장은 없을 텐데....
	if (not in) {
		return 20250318;
	}
	array<int, 100000> a; //콘티구어스 한 메모리라 for문 돌리는거는 바보같은 행위
	in.read((char*)a.data(), sizeof(int) * a.size());

	cout << "가장 작은 수 :" << *min_element(a.begin(), a.end()) << endl;
	//가장 작은 수 :-2147431498
	//가장 작은 수 :-1728550813 바이너리 모드로 안열음
	save("메인.cpp");	
}

==============================================
저장한 시간 :2025-03-18 오후 3:02:27 화요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 13일 목요일      (2주 2일차 강의) 
//-------------------------------------------------------------------------------------------
//   많은 수의 자료를 처리하기 -binary I/O
//          ->파일을 binary 모드로 열어야 변환이 일어나지 않는다.
//-------------------------------------------------------------------------------------------
// 
//-------------------------------------------------------------------------------------------
#include<iostream>
#include<fstream>
#include<array>
#include<algorithm>
#include"save.h"

using namespace std;

//binary로 열어 기록한 파일 "int 10만개에를 바이너리모드 wirte 함수로 기록" 에는,
//int값 10만개가 메모리 크기 그대로 기록되어 있다. (ostream의 wirte 함수를 사용)
// int값 10만개를 읽어서 메모리에 저장하시오.
// 가장 작은 값을 찾아 화면에 출력하라.
// 화면에 출력된 값도 답지에 적어라.





//----------
int main()
//----------
{
	
	ifstream in{ "int 10만개에를 바이너리모드 wirte 함수로 기록", ios::binary }; //읽을때도 바이너리로 열었다 텍스트로 열었어도 큰 지장은 없을 텐데....
	if (not in) {
		return 20250318;
	}
	array<int, 100000> a; //콘티구어스 한 메모리라 for문 돌리는거는 바보같은 행위
	in.read((char*)a.data(), sizeof(int) * a.size());

	cout << "가장 작은 수 :" << *min_element(a.begin(), a.end()) << endl;
	//가장 작은 수 :-2147431498
	//가장 작은 수 :-1728550813 바이너리 모드로 안열음
	save("메인.cpp");	
}

==============================================
저장한 시간 :2025-03-20 오후 3:37:18 목요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 20일 목요일      (3주 2일차 강의) 
//-------------------------------------------------------------------------------------------
//   많은 수의 자료를 처리하기 - Dog를 읽고 쓴다 , read/wirte
// 
//-------------------------------------------------------------------------------------------
// 
//-------------------------------------------------------------------------------------------
#include<iostream>
#include<fstream>
#include<array>
#include"save.h"

using namespace std;

//[문제] binary mode 로 열어 wirte 함수로 int 10만개를 기록한
//파일 "int 10만개에를 바이너리모드 wirte 함수로 기록"이 있다.
//읽어서 메모리에 모두 저장하라
//메모리에 있는 값 중에서 가장 작은 것과 가장 큰 것을 찾아 화면에 출력하라.
//출력된 값을 답지에도 적어라



//----------
int main()
//----------
{
	ifstream in{ "int 10만개에를 바이너리모드 wirte 함수로 기록" , ios::binary };
	array<int, 10'0000> a;
	in.read( (char*)a.data(), a.size() * sizeof(int) );
	cout << "가장 작은 값 :" << *min_element(a.cbegin(), a.cend()) << endl;
	cout << "가장 큰 값 :" << *max_element(a.cbegin(), a.cend()) << endl;
	save("메인.cpp");	
}

==============================================
저장한 시간 :2025-03-20 오후 3:48:38 목요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 20일 목요일      (3주 2일차 강의) 
//-------------------------------------------------------------------------------------------
//   많은 수의 자료를 처리하기 - Dog를 읽고 쓴다 , read/wirte
// 
//-------------------------------------------------------------------------------------------
// constexpr 가 뭘까??? 알아보자
//-------------------------------------------------------------------------------------------
#include<iostream>
#include<fstream>
#include<array>
#include<algorithm>
#include"save.h"

using namespace std;

//[문제] binary mode 로 열어 wirte 함수로 int 10만개를 기록한
//파일 "int 10만개에를 바이너리모드 wirte 함수로 기록"이 있다.
//읽어서 메모리에 모두 저장하라
//메모리에 있는 값 중에서 가장 작은 것과 가장 큰 것을 찾아 화면에 출력하라.
//출력된 값을 답지에도 적어라



//----------
int main()
//----------
{
	ifstream in{ "int 10만개에를 바이너리모드 wirte 함수로 기록" , ios::binary };
	array<int, 10'0000> a;
	in.read( (char*)a.data(), a.size() * sizeof(int) );
	auto p = minmax_element(a.begin(), a.end());
	cout << "최솟값 -" << *p.first << endl;
	cout << "최댓값 -" << *p.second << endl;
	save("메인.cpp");	
}

==============================================
저장한 시간 :2025-03-20 오후 3:49:28 목요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 20일 목요일      (3주 2일차 강의) 
//-------------------------------------------------------------------------------------------
//   많은 수의 자료를 처리하기 - Dog를 읽고 쓴다 , read/wirte
// 
//-------------------------------------------------------------------------------------------
// constexpr 가 뭘까??? 알아보자
//-------------------------------------------------------------------------------------------
#include<iostream>
#include<fstream>
#include<array>
#include<algorithm>
#include"save.h"

using namespace std;

//[문제] binary mode 로 열어 wirte 함수로 int 10만개를 기록한
//파일 "int 10만개에를 바이너리모드 wirte 함수로 기록"이 있다.
//읽어서 메모리에 모두 저장하라
//메모리에 있는 값 중에서 가장 작은 것과 가장 큰 것을 찾아 화면에 출력하라.
//출력된 값을 답지에도 적어라



//----------
int main()
//----------
{
	ifstream in{ "int 10만개에를 바이너리모드 wirte 함수로 기록" , ios::binary };
	array<int, 10'0000> a;
	in.read( (char*)a.data(), a.size() * sizeof(int) );
	auto p = minmax_element(a.begin(), a.end());
	cout << "최솟값 : " << *p.first << endl;
	cout << "최댓값 : " << *p.second << endl;
	save("메인.cpp");	
}

==============================================
저장한 시간 :2025-03-20 오후 3:51:28 목요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 20일 목요일      (3주 2일차 강의) 
//-------------------------------------------------------------------------------------------
//   많은 수의 자료를 처리하기 - Dog를 읽고 쓴다 , read/wirte
// 
//-------------------------------------------------------------------------------------------
// constexpr 가 뭘까??? 알아보자
//-------------------------------------------------------------------------------------------
#include<iostream>
#include<fstream>
#include<array>
#include<algorithm>
#include"save.h"

using namespace std;

//[문제] binary mode 로 열어 wirte 함수로 int 10만개를 기록한
//파일 "int 10만개에를 바이너리모드 wirte 함수로 기록"이 있다.
//읽어서 메모리에 모두 저장하라
//메모리에 있는 값 중에서 가장 작은 것과 가장 큰 것을 찾아 화면에 출력하라.
//출력된 값을 답지에도 적어라



//----------
int main()
//----------
{
	ifstream in{ "int 10만개에를 바이너리모드 wirte 함수로 기록" , ios::binary };
	array<int, 10'0000> a;
	in.read( (char*)a.data(), a.size() * sizeof(int) );

	auto [최솟값의위치, 최대값의위치] = minmax_element(a.begin(), a.end());  //앵글 브레킷
	cout << "최솟값 : " << *최솟값의위치 << endl;
	cout << "최댓값 : " << *최솟값의위치 << endl;
	save("메인.cpp");	
}

==============================================
저장한 시간 :2025-03-20 오후 3:51:45 목요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 20일 목요일      (3주 2일차 강의) 
//-------------------------------------------------------------------------------------------
//   많은 수의 자료를 처리하기 - Dog를 읽고 쓴다 , read/wirte
// 
//-------------------------------------------------------------------------------------------
// constexpr 가 뭘까??? 알아보자
//-------------------------------------------------------------------------------------------
#include<iostream>
#include<fstream>
#include<array>
#include<algorithm>
#include"save.h"

using namespace std;

//[문제] binary mode 로 열어 wirte 함수로 int 10만개를 기록한
//파일 "int 10만개에를 바이너리모드 wirte 함수로 기록"이 있다.
//읽어서 메모리에 모두 저장하라
//메모리에 있는 값 중에서 가장 작은 것과 가장 큰 것을 찾아 화면에 출력하라.
//출력된 값을 답지에도 적어라



//----------
int main()
//----------
{
	ifstream in{ "int 10만개에를 바이너리모드 wirte 함수로 기록" , ios::binary };
	array<int, 10'0000> a;
	in.read( (char*)a.data(), a.size() * sizeof(int) );

	auto [최솟값의위치, 최대값의위치] = minmax_element(a.begin(), a.end());  //앵글 브레킷
	cout << "최솟값 : " << *최솟값의위치 << endl;
	cout << "최댓값 : " << *최대값의위치 << endl;
	save("메인.cpp");	
}

==============================================
저장한 시간 :2025-03-20 오후 4:13:55 목요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 20일 목요일      (3주 2일차 강의) 
//-------------------------------------------------------------------------------------------
//   많은 수의 자료를 처리하기 - Dog를 읽고 쓴다 , read/wirte
// 
//-------------------------------------------------------------------------------------------
// constexpr 가 뭘까??? 알아보자
// structured-binding
//-------------------------------------------------------------------------------------------
#include<iostream>
#include<string>
#include<random>
#include<print>
#include"save.h"


using namespace std;


// [문제] class Dog 객체 10만개를 binary mode 로 연 파일 "Dog 10만마리" 에 저장하였다.
//객체 크기 그대로 write 함수를 사용하여 저장하였다.
default_random_engine dre;
uniform_int_distribution<int> uid{ 'a','z' }; //a부터 z를 int 로 해석해서 찍어줘

class Dog {
public:
	Dog() { // name(15글자 고정 , 임의의 소문자 )과  id를 초기화
		id = ++sid;

		for (int i = 0; i < 15; ++i) {
			name += uid(dre);
		}
	}
	void show() const {
		println("[{:7}] -{ }", id, name);
	}

private:
	string name;
	int id{};

	static int sid; // scope - local , life time - global
};

int Dog::sid{ };

//----------
int main()
//----------
{
	Dog dog;
	
	save("메인.cpp");	
}

==============================================
저장한 시간 :2025-03-20 오후 4:14:43 목요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 20일 목요일      (3주 2일차 강의) 
//-------------------------------------------------------------------------------------------
//   많은 수의 자료를 처리하기 - Dog를 읽고 쓴다 , read/wirte
// 
//-------------------------------------------------------------------------------------------
// constexpr 가 뭘까??? 알아보자
// structured-binding
//-------------------------------------------------------------------------------------------
#include<iostream>
#include<string>
#include<random>
#include<print>
#include"save.h"


using namespace std;


// [문제] class Dog 객체 10만개를 binary mode 로 연 파일 "Dog 10만마리" 에 저장하였다.
//객체 크기 그대로 write 함수를 사용하여 저장하였다.
default_random_engine dre;
uniform_int_distribution<int> uid{ 'a','z' }; //a부터 z를 int 로 해석해서 찍어줘

class Dog {
public:
	Dog() { // name(15글자 고정 , 임의의 소문자 )과  id를 초기화
		id = ++sid;

		for (int i = 0; i < 15; ++i) {
			name += uid(dre);
		}
	}
	void show() const {
		/*println("[{:7}] -{ }", id, name);*/
		

	}

private:
	string name;
	int id{};

	static int sid; // scope - local , life time - global
};

int Dog::sid{ };

//----------
int main()
//----------
{
	Dog dog;
	dog.show();
	save("메인.cpp");	
}

==============================================
저장한 시간 :2025-03-20 오후 4:15:20 목요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 20일 목요일      (3주 2일차 강의) 
//-------------------------------------------------------------------------------------------
//   많은 수의 자료를 처리하기 - Dog를 읽고 쓴다 , read/wirte
// 
//-------------------------------------------------------------------------------------------
// constexpr 가 뭘까??? 알아보자
// structured-binding
//-------------------------------------------------------------------------------------------
#include<iostream>
#include<string>
#include<random>
#include<print>
#include"save.h"


using namespace std;


// [문제] class Dog 객체 10만개를 binary mode 로 연 파일 "Dog 10만마리" 에 저장하였다.
//객체 크기 그대로 write 함수를 사용하여 저장하였다.
default_random_engine dre;
uniform_int_distribution<int> uid{ 'a','z' }; //a부터 z를 int 로 해석해서 찍어줘

class Dog {
public:
	Dog() { // name(15글자 고정 , 임의의 소문자 )과  id를 초기화
		id = ++sid;

		for (int i = 0; i < 15; ++i) {
			name += uid(dre);
		}
	}
	void show() const {
		println("[{:7}]", id);
		

	}

private:
	string name;
	int id{};

	static int sid; // scope - local , life time - global
};

int Dog::sid{ };

//----------
int main()
//----------
{
	Dog dog;
	dog.show();
	save("메인.cpp");	
}

==============================================
저장한 시간 :2025-03-20 오후 4:15:41 목요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 20일 목요일      (3주 2일차 강의) 
//-------------------------------------------------------------------------------------------
//   많은 수의 자료를 처리하기 - Dog를 읽고 쓴다 , read/wirte
// 
//-------------------------------------------------------------------------------------------
// constexpr 가 뭘까??? 알아보자
// structured-binding
//-------------------------------------------------------------------------------------------
#include<iostream>
#include<string>
#include<random>
#include<print>
#include"save.h"


using namespace std;


// [문제] class Dog 객체 10만개를 binary mode 로 연 파일 "Dog 10만마리" 에 저장하였다.
//객체 크기 그대로 write 함수를 사용하여 저장하였다.
default_random_engine dre;
uniform_int_distribution<int> uid{ 'a','z' }; //a부터 z를 int 로 해석해서 찍어줘

class Dog {
public:
	Dog() { // name(15글자 고정 , 임의의 소문자 )과  id를 초기화
		id = ++sid;

		for (int i = 0; i < 15; ++i) {
			name += uid(dre);
		}
	}
	void show() const {
		println("[{:7}] -", id, name);
		

	}

private:
	string name;
	int id{};

	static int sid; // scope - local , life time - global
};

int Dog::sid{ };

//----------
int main()
//----------
{
	Dog dog;
	dog.show();
	save("메인.cpp");	
}

==============================================
저장한 시간 :2025-03-20 오후 4:16:03 목요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 20일 목요일      (3주 2일차 강의) 
//-------------------------------------------------------------------------------------------
//   많은 수의 자료를 처리하기 - Dog를 읽고 쓴다 , read/wirte
// 
//-------------------------------------------------------------------------------------------
// constexpr 가 뭘까??? 알아보자
// structured-binding
//-------------------------------------------------------------------------------------------
#include<iostream>
#include<string>
#include<random>
#include<print>
#include"save.h"


using namespace std;


// [문제] class Dog 객체 10만개를 binary mode 로 연 파일 "Dog 10만마리" 에 저장하였다.
//객체 크기 그대로 write 함수를 사용하여 저장하였다.
default_random_engine dre;
uniform_int_distribution<int> uid{ 'a','z' }; //a부터 z를 int 로 해석해서 찍어줘

class Dog {
public:
	Dog() { // name(15글자 고정 , 임의의 소문자 )과  id를 초기화
		id = ++sid;

		for (int i = 0; i < 15; ++i) {
			name += uid(dre);
		}
	}
	void show() const {
		println("[{:7}] -{}", id, name);
		

	}

private:
	string name;
	int id{};

	static int sid; // scope - local , life time - global
};

int Dog::sid{ };

//----------
int main()
//----------
{
	Dog dog;
	dog.show();
	save("메인.cpp");	
}

==============================================
저장한 시간 :2025-03-20 오후 4:18:21 목요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 20일 목요일      (3주 2일차 강의) 
//-------------------------------------------------------------------------------------------
//   많은 수의 자료를 처리하기 - Dog를 읽고 쓴다 , read/wirte
// 
//-------------------------------------------------------------------------------------------
// constexpr 가 뭘까??? 알아보자
// structured-binding
//-------------------------------------------------------------------------------------------
#include<iostream>
#include<string>
#include<random>
#include<print>
#include"save.h"


using namespace std;


// [문제] class Dog 객체 10만개를 binary mode 로 연 파일 "Dog 10만마리" 에 저장하였다.
//객체 크기 그대로 write 함수를 사용하여 저장하였다.
default_random_engine dre;
uniform_int_distribution<int> uid{ 'a','z' }; //a부터 z를 int 로 해석해서 찍어줘

class Dog {
public:
	Dog() { // name(15글자 고정 , 임의의 소문자 )과  id를 초기화
		id = ++sid;

		for (int i = 0; i < 15; ++i) {
			name += uid(dre);
		}
	}
	void show() const {
		println("[{:7}] -{}", id, name); //빈칸을 두면 안돌아갔다.
	}

private:
	string name;
	int id{};

	static int sid; // scope - local , life time - global
};

int Dog::sid{ };

//----------
int main()
//----------
{
	for (int i = 0; i < 10'0000; ++i) {
		Dog dog;
		dog.show();
	}
	save("메인.cpp");	
}

==============================================
저장한 시간 :2025-03-20 오후 4:21:34 목요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 20일 목요일      (3주 2일차 강의) 
//-------------------------------------------------------------------------------------------
//   많은 수의 자료를 처리하기 - Dog를 읽고 쓴다 , read/wirte
// 
//-------------------------------------------------------------------------------------------
// constexpr 가 뭘까??? 알아보자
// structured-binding
//-------------------------------------------------------------------------------------------
#include<iostream>
#include<string>
#include<random>
#include<print>
#include<fstream>
#include"save.h"


using namespace std;


// [문제] class Dog 객체 10만개를 binary mode 로 연 파일 "Dog 10만마리" 에 저장하였다.
//객체 크기 그대로 write 함수를 사용하여 저장하였다.
default_random_engine dre;
uniform_int_distribution<int> uid{ 'a','z' }; //a부터 z를 int 로 해석해서 찍어줘

class Dog {
public:
	Dog() { // name(15글자 고정 , 임의의 소문자 )과  id를 초기화
		id = ++sid;

		for (int i = 0; i < 15; ++i) {
			name += uid(dre);
		}
	}
	void show() const {
		println("[{:7}] -{}", id, name); //빈칸을 두면 안돌아갔다.
	}

private:
	string name;
	int id{};

	static int sid; // scope - local , life time - global
};

int Dog::sid{ };

//----------
int main()
//----------
{
	ofstream out { "Dog 10만마리" , ios::binary };
	for (int i = 0; i < 10'0000; ++i) {
		Dog dog;
		out.write( (char*)&dog, sizeof(Dog));
	}
	save("메인.cpp");	
}

==============================================
저장한 시간 :2025-03-20 오후 4:31:24 목요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 20일 목요일      (3주 2일차 강의) 
//-------------------------------------------------------------------------------------------
//   많은 수의 자료를 처리하기 - Dog를 읽고 쓴다 , read/wirte
// 
//-------------------------------------------------------------------------------------------
// constexpr 가 뭘까??? 알아보자
// structured-binding
//-------------------------------------------------------------------------------------------
#include<iostream>
#include<fstream>
#include<array>
#include"save.h"


using namespace std;

// [문제] eclass에서 다운 받은 파일 "Dog 10만마리" 는 binary mode로 열었고,
// 위에 적은 class Dog를 스트림의 write 함수를 사용하여 메모리 그대로 저장하였다.
// Dog 객체 10만개를 메모리에 저장하라.
// 가장 마지막 객체의 정보를 cout을 사용하여 화면에 출력하라. 


class Dog {
private:
	string name;
	int id{};

	static int sid; // scope - local , life time - global
	friend ostream& operator<<(ostream& os, const Dog& dog) {
		os << "개 이름: " << dog.name << ",개 ID: " << dog.id;
		return os;
	}
};

int Dog::sid{ };
array<Dog, 10'0000> Da;
//----------
int main()
//----------
{
	ifstream in{ "Dog 10만마리", ios::binary };
	
	in.read((char*)&Da, sizeof(Dog) * Da.size());

	cout << Da.back() << endl;
	save("메인.cpp");	
}

==============================================
저장한 시간 :2025-03-20 오후 4:40:18 목요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 20일 목요일      (3주 2일차 강의) 
//-------------------------------------------------------------------------------------------
//   많은 수의 자료를 처리하기 - Dog를 읽고 쓴다 , read/wirte
// 
//-------------------------------------------------------------------------------------------
// constexpr 가 뭘까??? 알아보자
// structured-binding
//-------------------------------------------------------------------------------------------
#include<iostream>
#include<fstream>
#include<array>
#include"save.h"


using namespace std;

// [문제] eclass에서 다운 받은 파일 "Dog 10만마리" 는 binary mode로 열었고,
// 위에 적은 class Dog를 스트림의 write 함수를 사용하여 메모리 그대로 저장하였다.
// Dog 객체 10만개를 메모리에 저장하라.
// 가장 마지막 객체의 정보를 cout을 사용하여 화면에 출력하라. 


class Dog {
private:
	string name;
	int id{};

	static int sid; // scope - local , life time - global
	friend ostream& operator<<(ostream& os, const Dog& dog) {
		os << "개 이름: " << dog.name << ",개 ID: " << dog.id;
		return os;
	}
};

int Dog::sid{ };
array<Dog, 10'0000> Da;
//----------
int main()
//----------
{
	ifstream in{ "Dog 10만마리", ios::binary };
	if (not in)
		return 1231412;
	int cnt{};
	while (in.read((char*)&Da, sizeof(Dog) * Da.size())) {
		++cnt;
	}
	cout << "읽은 객체 수 -" << cnt << endl;
	cout << Da.back() << endl;
	save("메인.cpp");	
}

==============================================
저장한 시간 :2025-03-20 오후 4:47:26 목요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 20일 목요일      (3주 2일차 강의) 
//-------------------------------------------------------------------------------------------
//   많은 수의 자료를 처리하기 - Dog를 읽고 쓴다 , read/wirte
// 
//-------------------------------------------------------------------------------------------
// constexpr 가 뭘까??? 알아보자
// structured-binding
//-------------------------------------------------------------------------------------------
#include<iostream>
#include<fstream>
#include<array>
#include"save.h"


using namespace std;

// [문제] eclass에서 다운 받은 파일 "Dog 10만마리" 는 binary mode로 열었고,
// 위에 적은 class Dog를 스트림의 write 함수를 사용하여 메모리 그대로 저장하였다.
// Dog 객체 10만개를 메모리에 저장하라.
// 가장 마지막 객체의 정보를 cout을 사용하여 화면에 출력하라. 


class Dog {
private:
	string name;
	int id{};

	static int sid; // scope - local , life time - global

	friend ostream& operator<<(ostream& os, const Dog& dog) { //friend는 클래스에서 제일 밑바닥에 있어야 한다.
		return os << "개 이름: " << dog.name << ",개 ID: " << dog.id;
	}
};

int Dog::sid{ };
array<Dog, 10'0000> dogs;
//----------
int main()
//----------
{
	ifstream in{ "Dog 10만마리", ios::binary };
	if (not in)
		return 1231412;
	int cnt{};
	in.read((char*)dogs.data(), sizeof(Dog) * dogs.size());

	cout << "읽은 객체 수 -" << cnt << endl;
	cout << dogs.back() << endl;
	save("메인.cpp");	
}

==============================================
저장한 시간 :2025-03-20 오후 4:47:50 목요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 20일 목요일      (3주 2일차 강의) 
//-------------------------------------------------------------------------------------------
//   많은 수의 자료를 처리하기 - Dog를 읽고 쓴다 , read/wirte
// 
//-------------------------------------------------------------------------------------------
// constexpr 가 뭘까??? 알아보자
// structured-binding
//-------------------------------------------------------------------------------------------
#include<iostream>
#include<fstream>
#include<array>
#include"save.h"


using namespace std;

// [문제] eclass에서 다운 받은 파일 "Dog 10만마리" 는 binary mode로 열었고,
// 위에 적은 class Dog를 스트림의 write 함수를 사용하여 메모리 그대로 저장하였다.
// Dog 객체 10만개를 메모리에 저장하라.
// 가장 마지막 객체의 정보를 cout을 사용하여 화면에 출력하라. 


class Dog {
private:
	string name;
	int id{};

	static int sid; // scope - local , life time - global

	friend ostream& operator<<(ostream& os, const Dog& dog) { //friend는 클래스에서 제일 밑바닥에 있어야 한다.
		return os << "개 이름: " << dog.name << ",개 ID: " << dog.id;
	}
};

int Dog::sid{ };
array<Dog, 10'0000> dogs;
//----------
int main()
//----------
{
	ifstream in{ "Dog 10만마리", ios::binary };
	if (not in)
		return 1231412;
	int cnt{};
	in.read((char*)dogs.data(), sizeof(Dog) * dogs.size());

	cout << "읽은 객체 수 -" << cnt << endl;
	cout << dogs.back() << endl;
	save("메인.cpp");	
}

==============================================
저장한 시간 :2025-03-20 오후 4:48:11 목요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 20일 목요일      (3주 2일차 강의) 
//-------------------------------------------------------------------------------------------
//   많은 수의 자료를 처리하기 - Dog를 읽고 쓴다 , read/wirte
// 
//-------------------------------------------------------------------------------------------
// constexpr 가 뭘까??? 알아보자
// structured-binding
//-------------------------------------------------------------------------------------------
#include<iostream>
#include<fstream>
#include<array>
#include"save.h"


using namespace std;

// [문제] eclass에서 다운 받은 파일 "Dog 10만마리" 는 binary mode로 열었고,
// 위에 적은 class Dog를 스트림의 write 함수를 사용하여 메모리 그대로 저장하였다.
// Dog 객체 10만개를 메모리에 저장하라.
// 가장 마지막 객체의 정보를 cout을 사용하여 화면에 출력하라. 


class Dog {
private:
	string name;
	int id{};

	static int sid; // scope - local , life time - global

	friend ostream& operator<<(ostream& os, const Dog& dog) { //friend는 클래스에서 제일 밑바닥에 있어야 한다.
		return os << "개 이름: " << dog.name << ",개 ID: " << dog.id;
	}
};

int Dog::sid{ };
array<Dog, 10'0000> dogs;
//----------
int main()
//----------
{
	ifstream in{ "Dog 10만마리", ios::binary };
	if (not in)
		return 1231412;

	in.read((char*)dogs.data(), sizeof(Dog) * dogs.size());


	cout << dogs.back() << endl;
	save("메인.cpp");	
}

==============================================
저장한 시간 :2025-03-20 오후 4:48:41 목요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 20일 목요일      (3주 2일차 강의) 
//-------------------------------------------------------------------------------------------
//   많은 수의 자료를 처리하기 - Dog를 읽고 쓴다 , read/wirte
// 
//-------------------------------------------------------------------------------------------
// constexpr 가 뭘까??? 알아보자
// structured-binding
//-------------------------------------------------------------------------------------------
#include<iostream>
#include<fstream>
#include<array>
#include"save.h"


using namespace std;

// [문제] eclass에서 다운 받은 파일 "Dog 10만마리" 는 binary mode로 열었고,
// 위에 적은 class Dog를 스트림의 write 함수를 사용하여 메모리 그대로 저장하였다.
// Dog 객체 10만개를 메모리에 저장하라.
// 가장 마지막 객체의 정보를 cout을 사용하여 화면에 출력하라. 


class Dog {
private:
	string name;
	int id{};

	static int sid; // scope - local , life time - global

	friend ostream& operator<<(ostream& os, const Dog& dog) { //friend는 클래스에서 제일 밑바닥에 있어야 한다.
		return os << "개 이름: " << dog.name << ",개 ID: " << dog.id;
	}
};

int Dog::sid{ };
array<Dog, 10'0000> dogs;
//----------
int main()
//----------
{
	ifstream in{ "Dog 10만마리", ios::binary };
	if (not in)
		return 1231412;

	in.read((char*)dogs.data(), sizeof(Dog) * dogs.size());


	cout << dogs.back() << endl;
	save("메인.cpp");	
}

==============================================
저장한 시간 :2025-03-20 오후 4:56:15 목요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 20일 목요일      (3주 2일차 강의) 
//-------------------------------------------------------------------------------------------
//   많은 수의 자료를 처리하기 - Dog를 읽고 쓴다 , read/wirte
// 
//-------------------------------------------------------------------------------------------
// constexpr 가 뭘까??? 알아보자
// structured-binding
//-------------------------------------------------------------------------------------------
#include<iostream>
#include<fstream>
#include<array>
#include"save.h"


using namespace std;

// [문제] eclass에서 다운 받은 파일 "Dog 10만마리" 는 binary mode로 열었고,
// 위에 적은 class Dog를 스트림의 write 함수를 사용하여 메모리 그대로 저장하였다.



class Dog {
private:
	string name;
	int id{};


	friend ostream& operator<<(ostream& os, const Dog& dog) { //friend는 클래스에서 제일 밑바닥에 있어야 한다.
		return os << "개 이름: " << dog.name << ",개 ID: " << dog.id;
	}

	friend ifstream& operator>>(ifstream& in,  Dog& dog) {
		in.read((char*)&dog, sizeof(Dog));
		return in;
	}
};

array<Dog, 10'0000> dogs;
//----------
int main()
//----------
{
	ifstream in{ "Dog 10만마리", ios::binary };
	if (not in)
		return 1231412;
	// [문제] 다음 코드가 수정없이 실행되도록 필요한 코드를 class Dog에 추가하라.
	for (Dog& dog : dogs) {
		in >> dog;
		cout << dog << endl;
	}

	save("메인.cpp");	
}

==============================================
저장한 시간 :2025-03-25 오후 2:17:29 화요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 20일 목요일      (3주 2일차 강의) 
//-------------------------------------------------------------------------------------------
// 동적할당과 smart pointer
//-------------------------------------------------------------------------------------------
// constexpr 가 뭘까??? 알아보자
// structured-binding
//-------------------------------------------------------------------------------------------
#include<iostream>
#include<numeric>
#include"save.h"
using namespace std;
void f()
{
	int* p = new int[ 10 ];
	cout << "합계  :" << accumulate(p, p + 10, 0) << endl;
	
	delete[] p;
}

//----------
int main()
//----------
{
	for(int i =0 ; i<10; ++i)
	f();
	save("메인.cpp");	
}

==============================================
저장한 시간 :2025-03-25 오후 2:17:46 화요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 20일 목요일      (3주 2일차 강의) 
//-------------------------------------------------------------------------------------------
// 동적할당과 smart pointer
//-------------------------------------------------------------------------------------------
// constexpr 가 뭘까??? 알아보자
// structured-binding
//-------------------------------------------------------------------------------------------
#include<iostream>
#include<numeric>
#include"save.h"
using namespace std;
void f()
{
	int* p = new int[ 10 ];
	cout << "합계  :" << accumulate(p, p + 10, 0) << endl;
	
	delete[] p;
}

//----------
int main()
//----------
{
	for(int i =0 ; i<10; ++i)
		f();
		
	save("메인.cpp");	
}

==============================================
저장한 시간 :2025-03-25 오후 2:18:21 화요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 20일 목요일      (3주 2일차 강의) 
//-------------------------------------------------------------------------------------------
// 동적할당과 smart pointer
//-------------------------------------------------------------------------------------------
// constexpr 가 뭘까??? 알아보자
// structured-binding
//-------------------------------------------------------------------------------------------
#include<iostream>
#include<numeric>
#include"save.h"
using namespace std;
void f()
{
	int* p = new int[ 10 ];
	cout << "free store의 메모리 -" << p << endl;
	cout << "합계  :" << accumulate(p, p + 10, 0) << endl;
	
	delete[] p;
}

//----------
int main()
//----------
{
	for(int i =0 ; i<10; ++i)
		f();
		
	save("메인.cpp");	
}

==============================================
저장한 시간 :2025-03-25 오후 2:19:07 화요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 20일 목요일      (3주 2일차 강의) 
//-------------------------------------------------------------------------------------------
// 동적할당과 smart pointer
//-------------------------------------------------------------------------------------------
// constexpr 가 뭘까??? 알아보자
// structured-binding
//-------------------------------------------------------------------------------------------
#include<iostream>
#include<numeric>
#include"save.h"
using namespace std;
void f()
{
	int* p = new int[10] {};
	cout << "free store의 메모리 -" << p << endl;
	cout << "합계  :" << accumulate(p, p + 10, 0) << endl;
	
	delete[] p;
}

//----------
int main()
//----------
{
	for(int i =0 ; i<10; ++i)
		f();
		
	save("메인.cpp");	
}

==============================================
저장한 시간 :2025-03-25 오후 2:24:32 화요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 20일 목요일      (3주 2일차 강의) 
//-------------------------------------------------------------------------------------------
// 동적할당과 smart pointer
//-------------------------------------------------------------------------------------------
// constexpr 가 뭘까??? 알아보자
// structured-binding
//-------------------------------------------------------------------------------------------
#include<iostream>
#include<numeric>
#include"save.h"
using namespace std;
void f()
{
	int* p = new int[10] {};

	cout << "합계  :" << accumulate(p, p + 10, 0) << endl;

	throw 20250325; //예외를 집어던짐 누가 잘못됐다는 거 안들어주면 시스템이 죽어버림
	
	cout << "이줄이 출력되겠니?" << endl;
	delete[] p;
}

//----------
int main()
//----------
{
	try {
		f(); //내가 만들지 않은 함수일 가능성이 큼
	}
	catch (...) {

	}
	save("메인.cpp");	
}

==============================================
저장한 시간 :2025-03-25 오후 2:28:28 화요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 20일 목요일      (3주 2일차 강의) 
//-------------------------------------------------------------------------------------------
// 동적할당과 smart pointer
//-------------------------------------------------------------------------------------------
// constexpr 가 뭘까??? 알아보자
// structured-binding
//-------------------------------------------------------------------------------------------
#include<iostream>
#include<numeric>
#include"save.h"
using namespace std;

class Dog {
public:
	Dog( ) { cout << "생성" << endl; }
	~Dog() { cout << "소멸" << endl; }
};

void f()
{
	Dog* p =new Dog;

	delete p;
	
}

//----------
int main()
//----------
{
	
	f(); 
	
	save("메인.cpp");	
}

==============================================
저장한 시간 :2025-03-25 오후 2:29:30 화요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 20일 목요일      (3주 2일차 강의) 
//-------------------------------------------------------------------------------------------
// 동적할당과 smart pointer
//-------------------------------------------------------------------------------------------
// constexpr 가 뭘까??? 알아보자
// structured-binding
//-------------------------------------------------------------------------------------------
#include<iostream>
#include<numeric>
#include"save.h"
using namespace std;

class Dog {
public:
	Dog( ) { cout << "생성" << endl; }
	~Dog() { cout << "소멸" << endl; }
};

void f()
{
	Dog* p =new Dog;

	throw 1;

	delete p;
	
}

//----------
int main()
//----------
{
	try {
		f();
	}
	catch (...) {

	}
	
	save("메인.cpp");	
}

==============================================
저장한 시간 :2025-03-25 오후 2:38:20 화요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 20일 목요일      (3주 2일차 강의) 
//-------------------------------------------------------------------------------------------
// 동적할당과 smart pointer - RAII
//-------------------------------------------------------------------------------------------
// constexpr 가 뭘까??? 알아보자
// structured-binding
//-------------------------------------------------------------------------------------------
#include<iostream>
#include<numeric>
#include"save.h"
using namespace std;

class Dog {
public:
	Dog( ) { cout << "생성" << endl; }
	~Dog() { cout << "소멸" << endl; }
};

class 스마트 {
	Dog* p;
public:
	스마트(Dog* p) : p{ p } {
	}
	~스마트() {
		delete p;
	}
};

void f()
{
	

	스마트 p{ new Dog }; //이게 RAII

	//지역에 만들어진 객체를 파괴하는 것을 보장한다. 
	throw 1;

	
}

//----------
int main()
//----------
{
	try {
		f();
	}
	catch (...) {

	}
	
	save("메인.cpp");	
}

==============================================
저장한 시간 :2025-03-25 오후 2:41:12 화요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 20일 목요일      (3주 2일차 강의) 
//-------------------------------------------------------------------------------------------
// 동적할당과 smart pointer - RAII
//  - C++ stack-unwinding을 보장한다
//-------------------------------------------------------------------------------------------
// constexpr 가 뭘까??? 알아보자
// structured-binding
//-------------------------------------------------------------------------------------------
#include<iostream>
#include<memory>
#include"save.h"
using namespace std;

class Dog {
public:
	Dog( ) { cout << "생성" << endl; }
	~Dog() { cout << "소멸" << endl; }
};


void f()
{
	

	unique_ptr<Dog> p{ new Dog }; //

	//지역에 만들어진 객체를 파괴하는 것을 보장한다. 
	throw 1;

	
}

//----------
int main()
//----------
{
	try {
		f();
	}
	catch (...) {

	}
	
	save("메인.cpp");	
}

==============================================
저장한 시간 :2025-03-25 오후 2:41:35 화요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 20일 목요일      (3주 2일차 강의) 
//-------------------------------------------------------------------------------------------
// 동적할당과 smart pointer - RAII
//  - C++ stack-unwinding을 보장한다
//-------------------------------------------------------------------------------------------
// constexpr 가 뭘까??? 알아보자
// structured-binding
//-------------------------------------------------------------------------------------------
#include<iostream>
#include<memory>
#include"save.h"
using namespace std;

class Dog {
public:
	Dog( ) { cout << "생성" << endl; }
	~Dog() { cout << "소멸" << endl; }
};


void f()
{
	

	unique_ptr<Dog> p{ new Dog }; //

	//지역에 만들어진 객체를 파괴하는 것을 보장한다. 
	throw 1;

	
}

//----------
int main()
//----------
{
	try {
		f();
	}
	catch (...) {
		cout << "예외를 잡아서 처리하였다" << endl;
	}
	
	save("메인.cpp");	
}

==============================================
저장한 시간 :2025-03-25 오후 2:42:53 화요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 20일 목요일      (3주 2일차 강의) 
//-------------------------------------------------------------------------------------------
// 동적할당과 smart pointer - RAII
//  - C++ stack-unwinding을 보장한다
//-------------------------------------------------------------------------------------------
// constexpr 가 뭘까??? 알아보자
// structured-binding
//-------------------------------------------------------------------------------------------
#include<iostream>
#include<memory>
#include"save.h"
using namespace std;

class Dog {
public:
	Dog( ) { cout << "생성" << endl; }
	~Dog() { cout << "소멸" << endl; }
};


void f()
{
	

	unique_ptr<Dog> p{ new Dog }; //

	//지역에 만들어진 객체를 파괴하는 것을 보장한다. 
	cout << "이줄이 출력될 수 없다" << endl;

	
}

//----------
int main()
//----------
{
	try {
		f();
	}
	catch (...) {
		cout << "예외를 잡아서 처리하였다" << endl;
	}
	
	save("메인.cpp");	
}

==============================================
저장한 시간 :2025-03-25 오후 2:44:00 화요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 20일 목요일      (3주 2일차 강의) 
//-------------------------------------------------------------------------------------------
// 동적할당과 smart pointer - RAII
//  - C++ stack-unwinding을 보장한다
//-------------------------------------------------------------------------------------------
// constexpr 가 뭘까??? 알아보자
// structured-binding
//-------------------------------------------------------------------------------------------
#include<iostream>
#include<memory>
#include"save.h"
using namespace std;

class Dog {
public:
	Dog( ) { cout << "생성" << endl; }
	~Dog() { cout << "소멸" << endl; }
};


void f()
{
	

	unique_ptr<Dog> p= make_unique<Dog>( ); //

	//지역에 만들어진 객체를 파괴하는 것을 보장한다. 
	cout << "이줄이 출력될 수 없다" << endl;

	
}

//----------
int main()
//----------
{
	try {
		f();
	}
	catch (...) {
		cout << "예외를 잡아서 처리하였다" << endl;
	}
	
	save("메인.cpp");	
}

==============================================
저장한 시간 :2025-03-25 오후 2:45:41 화요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 20일 목요일      (3주 2일차 강의) 
//-------------------------------------------------------------------------------------------
// 동적할당과 smart pointer - RAII
//  - C++ stack-unwinding을 보장한다
//-------------------------------------------------------------------------------------------
// constexpr 가 뭘까??? 알아보자
// structured-binding
//-------------------------------------------------------------------------------------------
#include<iostream>
#include<memory>
#include"save.h"
using namespace std;

class Dog {
public:
	Dog( ) { cout << "생성" << endl; }
	~Dog() { cout << "소멸" << endl; }
};


void f()
{
	

	unique_ptr<Dog[]> p = make_unique<Dog[]>(10); //dog 10마리

	//지역에 만들어진 객체를 파괴하는 것을 보장한다. 
	throw 123;
	cout << "이줄이 출력될 수 없다" << endl;

	
}

//----------
int main()
//----------
{
	try {
		f();
	}
	catch (...) {
		cout << "예외를 잡아서 처리하였다" << endl;
	}
	
	save("메인.cpp");	
}

==============================================
저장한 시간 :2025-03-26 오후 8:15:49 수요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 20일 목요일      (3주 2일차 강의) 
//-------------------------------------------------------------------------------------------
// 동적할당과 smart pointer - RAII 클래스로 자원을 관리하는 것
//  - C++ stack-unwinding을 보장한다
//-------------------------------------------------------------------------------------------
// 많은 수의 자료 - FILE
//-------------------------------------------------------------------------------------------
#include<iostream>
#include<memory>
#include"save.h"
using namespace std;

class Dog {
public:
	Dog() { cout << "생성" << endl; }
	~Dog() { cout << "소멸" << endl; }
};


void f()
{


	unique_ptr<Dog[]> p = make_unique<Dog[]>(10); //dog 10마리

	//지역에 만들어진 객체를 파괴하는 것을 보장한다. 
	throw 123;
	cout << "이줄이 출력될 수 없다" << endl;


}

//----------
int main()
//----------
{
	try {
		f();
	}
	catch (...) {
		cout << "예외를 잡아서 처리하였다" << endl;
	}

	save("메인.cpp");
}

==============================================
저장한 시간 :2025-03-26 오후 8:21:26 수요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 20일 목요일      (3주 2일차 강의) 
//-------------------------------------------------------------------------------------------
// 동적할당과 smart pointer - RAII 클래스로 자원을 관리하는 것
//  - C++ stack-unwinding을 보장한다
//-------------------------------------------------------------------------------------------
// 많은 수의 자료 - FILE
//-------------------------------------------------------------------------------------------
#include<iostream>
#include<memory>
#include<string>
#include"save.h"
using namespace std;

class Dog {
public:
	Dog() { cout << "생성" << endl; }
	Dog(string n) {
		cout << "내 이름은 :" << n << endl;
		name = n;
	}
	~Dog() { cout << "소멸" << endl; }
private:
	string name;
};


void f()
{


	unique_ptr<Dog[]> p = make_unique<Dog[]>(10); //dog 10마리
	unique_ptr<Dog[]> p2 = make_unique<Dog[]>(10); //dog 10마리

	//지역에 만들어진 객체를 파괴하는 것을 보장한다. 
	throw 123;
	cout << "이줄이 출력될 수 없다" << endl;


}

//----------
int main()
//----------
{
	try {
		f();
	}
	catch (...) {
		cout << "예외를 잡아서 처리하였다" << endl;
	}
	Dog dog{ "poppy" };
	save("메인.cpp");
}

==============================================
저장한 시간 :2025-03-26 오후 8:23:30 수요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 20일 목요일      (3주 2일차 강의) 
//-------------------------------------------------------------------------------------------
// 동적할당과 smart pointer - RAII 클래스로 자원을 관리하는 것
//  - C++ stack-unwinding을 보장한다
//-------------------------------------------------------------------------------------------
// 많은 수의 자료 - FILE
//-------------------------------------------------------------------------------------------
#include<iostream>
#include<memory>
#include<string>
#include"save.h"
using namespace std;

class Dog {
public:
	Dog() {
		cout << "생성" << endl;
		name = " ";
	}
	Dog(string n) {
		name = n;
		cout << "내 이름은 :" << name << endl;
		
	}
	~Dog() { cout << "소멸" << endl; }
private:
	string name;
};


void f()
{


	unique_ptr<Dog[]> p = make_unique<Dog[]>(10); //dog 10마리
	unique_ptr<Dog[]> p2 = make_unique<Dog[]>(10); //dog 10마리

	//지역에 만들어진 객체를 파괴하는 것을 보장한다. 
	throw 123;
	cout << "이줄이 출력될 수 없다" << endl;


}

//----------
int main()
//----------
{
	try {
		f();
	}
	catch (...) {
		cout << "예외를 잡아서 처리하였다" << endl;
	}
	Dog dog{ "poppy" };
	save("메인.cpp");
}

==============================================
저장한 시간 :2025-03-26 오후 8:23:46 수요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 20일 목요일      (3주 2일차 강의) 
//-------------------------------------------------------------------------------------------
// 동적할당과 smart pointer - RAII 클래스로 자원을 관리하는 것
//  - C++ stack-unwinding을 보장한다
//-------------------------------------------------------------------------------------------
// 많은 수의 자료 - FILE
//-------------------------------------------------------------------------------------------
#include<iostream>
#include<memory>
#include<string>
#include"save.h"
using namespace std;

class Dog {
public:
	Dog() {
		cout << "생성" << endl;
		name = " ";
	}
	Dog(string n) {
		name = n;
		cout << "내 이름은 :" << name << endl;
		
	}
	~Dog() { cout<<name << " 소멸" << endl; }
private:
	string name;
};


void f()
{


	unique_ptr<Dog[]> p = make_unique<Dog[]>(10); //dog 10마리
	unique_ptr<Dog[]> p2 = make_unique<Dog[]>(10); //dog 10마리

	//지역에 만들어진 객체를 파괴하는 것을 보장한다. 
	throw 123;
	cout << "이줄이 출력될 수 없다" << endl;


}

//----------
int main()
//----------
{
	try {
		f();
	}
	catch (...) {
		cout << "예외를 잡아서 처리하였다" << endl;
	}
	Dog dog{ "poppy" };
	save("메인.cpp");
}

==============================================
저장한 시간 :2025-03-26 오후 8:23:58 수요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 20일 목요일      (3주 2일차 강의) 
//-------------------------------------------------------------------------------------------
// 동적할당과 smart pointer - RAII 클래스로 자원을 관리하는 것
//  - C++ stack-unwinding을 보장한다
//-------------------------------------------------------------------------------------------
// 많은 수의 자료 - FILE
//-------------------------------------------------------------------------------------------
#include<iostream>
#include<memory>
#include<string>
#include"save.h"
using namespace std;

class Dog {
public:
	Dog() {
		cout << "생성" << endl;
	}
	Dog(string n) {
		name = n;
		cout << "내 이름은 :" << name << endl;
		
	}
	~Dog() { cout<<name << " 소멸" << endl; }
private:
	string name;
};


void f()
{


	unique_ptr<Dog[]> p = make_unique<Dog[]>(10); //dog 10마리
	unique_ptr<Dog[]> p2 = make_unique<Dog[]>(10); //dog 10마리

	//지역에 만들어진 객체를 파괴하는 것을 보장한다. 
	throw 123;
	cout << "이줄이 출력될 수 없다" << endl;


}

//----------
int main()
//----------
{
	try {
		f();
	}
	catch (...) {
		cout << "예외를 잡아서 처리하였다" << endl;
	}
	Dog dog{ "poppy" };
	save("메인.cpp");
}

==============================================
저장한 시간 :2025-03-27 오후 3:27:03 목요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 20일 목요일      (3주 2일차 강의) 
//-------------------------------------------------------------------------------------------
// 동적할당과 smart pointer - RAII 클래스로 자원을 관리하는 것
//  - C++ stack-unwinding을 보장한다
//-------------------------------------------------------------------------------------------
// 많은 수의 자료 - FILE
//-------------------------------------------------------------------------------------------
#include<iostream>
#include<memory>
#include<string>
#include<fstream>
#include<algorithm>
#include"save.h"
using namespace std;


//----------
int main()
//----------
{
	ifstream in{ "메인.cpp" };
	if (not in) {
		cout << "파일을 열 수 없어요" << endl;
		return 123123;
	}
	ofstream out{ "메인 대문자.cpp" };
	transform(istreambuf_iterator<char>{in}, {},
		ostreambuf_iterator<char>{out}, [](char c) {return toupper(c); });
	save("메인.cpp");
}

==============================================
저장한 시간 :2025-03-27 오후 3:41:24 목요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 20일 목요일      (3주 2일차 강의) 
//-------------------------------------------------------------------------------------------
// 동적할당과 smart pointer - RAII 클래스로 자원을 관리하는 것
//  - C++ stack-unwinding을 보장한다
//-------------------------------------------------------------------------------------------
// Callable
//-------------------------------------------------------------------------------------------
#include<iostream>
#include<random>
#include<array>
#include"save.h"
using namespace std;

uniform_int_distribution uid{ 0, 999'9999 };
default_random_engine dre;

//[문제] 랜덤 int 1000만개를 메모리에 저장하자.
// 랜덤 int 값은 [0, 1'000'0000 ) == 0부터 999'9999 까지 값을 갖도록 
// qsort를 사용해서 오름차순으로 정렬하라
//정렬한 결과를 앞에서부터 1000개만 화면에 출력하라

array<int, 1'000'0000> arr;

int cmp(const void* a, const void* b) {
	if (*(int*)a > *(int*)b) {
		return 1;
	}
	else if (*(int*)a < *(int*)b) {
		return -1;
	}
	else {
		return 0;
	}
}
//----------
int main()
//----------
{
	for (int& num : arr)
		num = uid(dre);
	qsort(arr.data(), arr.size(), sizeof(int), cmp);

	for (int i = 0; i < 1000; ++i) {
		cout << arr[i] << " ";
	}
	
	save("메인.cpp");
}

==============================================
저장한 시간 :2025-03-27 오후 3:42:50 목요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 20일 목요일      (3주 2일차 강의) 
//-------------------------------------------------------------------------------------------
// 동적할당과 smart pointer - RAII 클래스로 자원을 관리하는 것
//  - C++ stack-unwinding을 보장한다
//-------------------------------------------------------------------------------------------
// Callable
//-------------------------------------------------------------------------------------------
#include<iostream>
#include<random>
#include<array>
#include<print>
#include"save.h"
using namespace std;

uniform_int_distribution uid{ 0, 999'9999 };
default_random_engine dre;

//[문제] 랜덤 int 1000만개를 메모리에 저장하자.
// 랜덤 int 값은 [0, 1'000'0000 ) == 0부터 999'9999 까지 값을 갖도록 
// qsort를 사용해서 오름차순으로 정렬하라
//정렬한 결과를 앞에서부터 1000개만 화면에 출력하라

array<int, 1'000'0000> arr;

int cmp(const void* a, const void* b) {
	if (*(int*)a > *(int*)b) {
		return 1;
	}
	else if (*(int*)a < *(int*)b) {
		return -1;
	}
	else {
		return 0;
	}
}
//----------
int main()
//----------
{
	for (int& num : arr)
		num = uid(dre);
	qsort(arr.data(), arr.size(), sizeof(int), cmp);

	for (int i = 0; i < 1000; ++i) {
		print("{:4}", arr[i]);
	}
	
	save("메인.cpp");
}

==============================================
저장한 시간 :2025-03-27 오후 3:43:26 목요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 20일 목요일      (3주 2일차 강의) 
//-------------------------------------------------------------------------------------------
// 동적할당과 smart pointer - RAII 클래스로 자원을 관리하는 것
//  - C++ stack-unwinding을 보장한다
//-------------------------------------------------------------------------------------------
// Callable
//-------------------------------------------------------------------------------------------
#include<iostream>
#include<random>
#include<array>
#include<print>
#include"save.h"
using namespace std;

uniform_int_distribution uid{ 0, 999'9999 };
default_random_engine dre;

//[문제] 랜덤 int 1000만개를 메모리에 저장하자.
// 랜덤 int 값은 [0, 1'000'0000 ) == 0부터 999'9999 까지 값을 갖도록 
// qsort를 사용해서 오름차순으로 정렬하라
//정렬한 결과를 앞에서부터 1000개만 화면에 출력하라

array<int, 1'000'0000> arr;

int cmp(const void* a, const void* b) {
	if (*(int*)a > *(int*)b) {
		return 1;
	}
	else if (*(int*)a < *(int*)b) {
		return -1;
	}
	else {
		return 0;
	}
}
//----------
int main()
//----------
{
	for (int& num : arr)
		num = uid(dre);
	qsort(arr.data(), arr.size(), sizeof(int), cmp);

	for (int i = 0; i < 1000; ++i) {
		print("{:4}", arr[i]);
	}
	cout << endl;
	
	save("메인.cpp");
}

==============================================
저장한 시간 :2025-03-27 오후 3:43:44 목요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 20일 목요일      (3주 2일차 강의) 
//-------------------------------------------------------------------------------------------
// 동적할당과 smart pointer - RAII 클래스로 자원을 관리하는 것
//  - C++ stack-unwinding을 보장한다
//-------------------------------------------------------------------------------------------
// Callable
//-------------------------------------------------------------------------------------------
#include<iostream>
#include<random>
#include<array>
#include<print>
#include"save.h"
using namespace std;

uniform_int_distribution uid{ 0, 999'9999 };
default_random_engine dre;

//[문제] 랜덤 int 1000만개를 메모리에 저장하자.
// 랜덤 int 값은 [0, 1'000'0000 ) == 0부터 999'9999 까지 값을 갖도록 
// qsort를 사용해서 오름차순으로 정렬하라
//정렬한 결과를 앞에서부터 1000개만 화면에 출력하라

array<int, 1'000'0000> arr;

int cmp(const void* a, const void* b) {
	if (*(int*)a > *(int*)b) {
		return 1;
	}
	else if (*(int*)a < *(int*)b) {
		return -1;
	}
	else {
		return 0;
	}
}
//----------
int main()
//----------
{
	for (int& num : arr)
		num = uid(dre);
	qsort(arr.data(), arr.size(), sizeof(int), cmp);

	for (int i = 0; i < 1000; ++i) {
		print("{:5}", arr[i]);
	}
	cout << endl;
	
	save("메인.cpp");
}

==============================================
저장한 시간 :2025-03-27 오후 3:47:49 목요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 20일 목요일      (3주 2일차 강의) 
//-------------------------------------------------------------------------------------------
// 동적할당과 smart pointer - RAII 클래스로 자원을 관리하는 것
//  - C++ stack-unwinding을 보장한다
//-------------------------------------------------------------------------------------------
// Callable
//-------------------------------------------------------------------------------------------
#include<iostream>
#include<random>
#include<array>
#include<print>
#include"save.h"
using namespace std;


//[문제] 랜덤 int 1000만개를 메모리에 저장하자.
// 랜덤 int 값은 [0, 1'000'0000 ) == 0부터 999'9999 까지 값을 갖도록 
// qsort를 사용해서 오름차순으로 정렬하라
//정렬한 결과를 앞에서부터 1000개만 화면에 출력하라

array<int, 1'000'0000> a;

uniform_int_distribution uid{ 0, 999'9999 };
default_random_engine dre;

int cmp(const void* a, const void* b) {
	if (*(int*)a > *(int*)b) {
		return 1;
	}
	else if (*(int*)a < *(int*)b) {
		return -1;
	}
	else {
		return 0;
	}
}
//----------
int main()
//----------
{
	for (int& num : a) //자료구조 a속에 int 형식의 데이터 num가 들어있는거다.  &을 붙여줘야 값이 들어간다
		num = uid(dre);

	//qsort로 오름차순 정렬


	//앞에서 부터 1000개 화면 출력
	for (int i = 0; i < 1000; ++i)
		print("{:8}", a[i]);
	cout << endl;
	
	save("메인.cpp");
}

==============================================
저장한 시간 :2025-03-27 오후 3:53:08 목요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 20일 목요일      (3주 2일차 강의) 
//-------------------------------------------------------------------------------------------
// 동적할당과 smart pointer - RAII 클래스로 자원을 관리하는 것
//  - C++ stack-unwinding을 보장한다
//-------------------------------------------------------------------------------------------
// Callable
//-------------------------------------------------------------------------------------------
#include<iostream>
#include<random>
#include<ranges>
#include<array>
#include<print>
#include"save.h"
using namespace std;


//[문제] 랜덤 int 1000만개를 메모리에 저장하자.
// 랜덤 int 값은 [0, 1'000'0000 ) == 0부터 999'9999 까지 값을 갖도록 
// qsort를 사용해서 오름차순으로 정렬하라
//정렬한 결과를 앞에서부터 1000개만 화면에 출력하라

array<int, 1'000'0000> a;

uniform_int_distribution uid{ 0, 999'9999 };
default_random_engine dre;

int cmp(const void* a, const void* b) {
	if (*(int*)a > *(int*)b) {
		return 1;
	}
	else if (*(int*)a < *(int*)b) {
		return -1;
	}
	else {
		return 0;
	}
}
//----------
int main()
//----------
{
	for (int& num : a) //자료구조 a속에 int 형식의 데이터 num가 들어있는거다.  &을 붙여줘야 값이 들어간다
		num = uid(dre);

	//qsort로 오름차순 정렬


	//앞에서 부터 1000개 화면 출력 여기서 개선책이 없을까???
	for (int num:a | views::take(1000))
		print("{:8}", num);
	cout << endl;
	
	save("메인.cpp");
}

==============================================
저장한 시간 :2025-03-27 오후 3:54:59 목요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 20일 목요일      (3주 2일차 강의) 
//-------------------------------------------------------------------------------------------
// 동적할당과 smart pointer - RAII 클래스로 자원을 관리하는 것
//  - C++ stack-unwinding을 보장한다
//-------------------------------------------------------------------------------------------
// Callable
//-------------------------------------------------------------------------------------------
#include<iostream>
#include<random>
#include<ranges>
#include<array>
#include<print>
#include"save.h"
using namespace std;


//[문제] 랜덤 int 1000만개를 메모리에 저장하자.
// 랜덤 int 값은 [0, 1'000'0000 ) == 0부터 999'9999 까지 값을 갖도록 
// qsort를 사용해서 오름차순으로 정렬하라
//정렬한 결과를 앞에서부터 1000개만 화면에 출력하라

array<int, 1'000'0000> a;

uniform_int_distribution uid{ 0, 999'9999 };
default_random_engine dre;

int cmp(const void* a, const void* b) {
	if (*(int*)a > *(int*)b) {
		return 1;
	}
	else if (*(int*)a < *(int*)b) {
		return -1;
	}
	else {
		return 0;
	}
}
//----------
int main()
//----------
{
	for (int& num : a) //자료구조 a속에 int 형식의 데이터 num가 들어있는거다.  &을 붙여줘야 값이 들어간다
		num = uid(dre);

	//qsort로 오름차순 정렬


	//앞에서 부터 1000개 화면 출력 여기서 개선책이 없을까???
	for (int num:a | views::take(1000)
				   | views::take(1)
		)
		print("{:8}", num);
	cout << endl;
	
	save("메인.cpp");
}

==============================================
저장한 시간 :2025-03-27 오후 3:55:12 목요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 20일 목요일      (3주 2일차 강의) 
//-------------------------------------------------------------------------------------------
// 동적할당과 smart pointer - RAII 클래스로 자원을 관리하는 것
//  - C++ stack-unwinding을 보장한다
//-------------------------------------------------------------------------------------------
// Callable
//-------------------------------------------------------------------------------------------
#include<iostream>
#include<random>
#include<ranges>
#include<array>
#include<print>
#include"save.h"
using namespace std;


//[문제] 랜덤 int 1000만개를 메모리에 저장하자.
// 랜덤 int 값은 [0, 1'000'0000 ) == 0부터 999'9999 까지 값을 갖도록 
// qsort를 사용해서 오름차순으로 정렬하라
//정렬한 결과를 앞에서부터 1000개만 화면에 출력하라

array<int, 1'000'0000> a;

uniform_int_distribution uid{ 0, 999'9999 };
default_random_engine dre;

int cmp(const void* a, const void* b) {
	if (*(int*)a > *(int*)b) {
		return 1;
	}
	else if (*(int*)a < *(int*)b) {
		return -1;
	}
	else {
		return 0;
	}
}
//----------
int main()
//----------
{
	for (int& num : a) //자료구조 a속에 int 형식의 데이터 num가 들어있는거다.  &을 붙여줘야 값이 들어간다
		num = uid(dre);

	//qsort로 오름차순 정렬


	//앞에서 부터 1000개 화면 출력 여기서 개선책이 없을까???
	for (int num:a | views::take(1)
				   | views::take(1)
		)
		print("{:8}", num);
	cout << endl;
	
	save("메인.cpp");
}

==============================================
저장한 시간 :2025-03-27 오후 4:16:52 목요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 20일 목요일      (3주 2일차 강의) 
//-------------------------------------------------------------------------------------------
// 동적할당과 smart pointer - RAII 클래스로 자원을 관리하는 것
//  - C++ stack-unwinding을 보장한다
//-------------------------------------------------------------------------------------------
// Callable
//-------------------------------------------------------------------------------------------
#include<iostream>
#include<random>
#include<ranges>
#include<array>
#include<print>
#include"save.h"
using namespace std;


//[문제] 랜덤 int 1000만개를 메모리에 저장하자.
// 랜덤 int 값은 [0, 1'000'0000 ) == 0부터 999'9999 까지 값을 갖도록 
// qsort를 사용해서 오름차순으로 정렬하라
//정렬한 결과를 앞에서부터 1000개만 화면에 출력하라

array<int, 1'000'0000> a;

uniform_int_distribution uid{ 0, 999'9999 };
default_random_engine dre;

//퀵쇼트가 원소를 바꿔야 하면 1을 리턴
//이미 정렬상태이면 -1
//둘이 정렬기준상 돌일한 값이면 0를 리턴
int 오름차순(const void* a, const void* b)
{
	int* p = (int*)a;  //c언어 스타일의 캐스팅
	int* q = (int*)b;

	if (*p < *q)
		return -1;
	else if (*p > *q)
		return 1;
	
	return 0;

	/*const int* p = (const int*)a;
	int* pp = (int*)p;*/
}
//----------
int main()
//----------
{
	for (int& num : a) //자료구조 a속에 int 형식의 데이터 num가 들어있는거다.  &을 붙여줘야 값이 들어간다
		num = uid(dre);

	//qsort로 오름차순 정렬
	qsort(a.data(), a.size(),sizeof(array<int,1'0000000>::value_type), 오름차순);

	//앞에서 부터 1000개 화면 출력 여기서 개선책이 없을까???
	for (int num:a | views::take(1000))
		print("{:8}", num);
	cout << endl;
	
	save("메인.cpp");
}

==============================================
저장한 시간 :2025-03-27 오후 4:19:25 목요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 20일 목요일      (3주 2일차 강의) 
//-------------------------------------------------------------------------------------------
// 동적할당과 smart pointer - RAII 클래스로 자원을 관리하는 것
//  - C++ stack-unwinding을 보장한다
//-------------------------------------------------------------------------------------------
// Callable
//-------------------------------------------------------------------------------------------
#include<iostream>
#include<random>
#include<ranges>
#include<array>
#include<print>
#include"save.h"
using namespace std;


//[문제] 랜덤 int 1000만개를 메모리에 저장하자.
// 랜덤 int 값은 [0, 1'000'0000 ) == 0부터 999'9999 까지 값을 갖도록 
// qsort를 사용해서 오름차순으로 정렬하라
//정렬한 결과를 앞에서부터 1000개만 화면에 출력하라

array<int, 1'000'0000> a;

uniform_int_distribution uid{ 0, 999'9999 };
default_random_engine dre;

//퀵쇼트가 원소를 바꿔야 하면 1을 리턴
//이미 정렬상태이면 -1
//둘이 정렬기준상 돌일한 값이면 0를 리턴
int 오름차순(const void* a, const void* b)
{
	int* p = (int*)a;  //c언어 스타일의 캐스팅
	int* q = (int*)b;

	if (*p < *q)
		return -1;
	else if (*p > *q)
		return 1;
	
	return 0;

	/*const int* p = (const int*)a;
	int* pp = (int*)p;*/
}
int 내림차순(const void* a, const void* b)
{
	int* p = (int*)a;  //c언어 스타일의 캐스팅
	int* q = (int*)b;

	if (*p < *q)
		return 1;
	else if (*p > *q)
		return -1;

	return 0;

	/*const int* p = (const int*)a;
	int* pp = (int*)p;*/
}
//----------
int main()
//----------
{
	for (int& num : a) //자료구조 a속에 int 형식의 데이터 num가 들어있는거다.  &을 붙여줘야 값이 들어간다
		num = uid(dre);

	//qsort로 내림차순(descending order) 정렬
	qsort(a.data(), a.size(),sizeof(array<int,1'0000000>::value_type), 내림차순);

	//앞에서 부터 1000개 화면 출력 여기서 개선책이 없을까???
	for (int num:a | views::take(1000))
		print("{:8}", num);
	cout << endl;
	
	save("메인.cpp");
}

==============================================
저장한 시간 :2025-03-27 오후 4:20:57 목요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 20일 목요일      (3주 2일차 강의) 
//-------------------------------------------------------------------------------------------
// 동적할당과 smart pointer - RAII 클래스로 자원을 관리하는 것
//  - C++ stack-unwinding을 보장한다
//-------------------------------------------------------------------------------------------
// Callable
//-------------------------------------------------------------------------------------------
#include<iostream>
#include<random>
#include<ranges>
#include<array>
#include<print>
#include"save.h"
using namespace std;


//[문제] 랜덤 int 1000만개를 메모리에 저장하자.
// 랜덤 int 값은 [0, 1'000'0000 ) == 0부터 999'9999 까지 값을 갖도록 
// qsort를 사용해서 오름차순으로 정렬하라
//정렬한 결과를 앞에서부터 1000개만 화면에 출력하라

array<int, 1'000'0000> a;

uniform_int_distribution uid{ 0, 999'9999 };
default_random_engine dre;

//퀵쇼트가 원소를 바꿔야 하면 1을 리턴
//이미 정렬상태이면 -1
//둘이 정렬기준상 돌일한 값이면 0를 리턴
int 오름차순(const void* a, const void* b)
{
	int* p = (int*)a;  //c언어 스타일의 캐스팅
	int* q = (int*)b;

	if (*p < *q)
		return -1;
	else if (*p > *q)
		return 1;
	
	return 0;

	/*const int* p = (const int*)a;
	int* pp = (int*)p;*/
}
int 내림차순(const void* a, const void* b)
{
	return *(int*)b - *(int*)a;
}
//----------
int main()
//----------
{
	for (int& num : a) //자료구조 a속에 int 형식의 데이터 num가 들어있는거다.  &을 붙여줘야 값이 들어간다
		num = uid(dre);

	//qsort로 내림차순(descending order) 정렬
	qsort(a.data(), a.size(),sizeof(array<int,1'0000000>::value_type), 내림차순);

	//앞에서 부터 1000개 화면 출력 여기서 개선책이 없을까???
	for (int num:a | views::take(1000))
		print("{:8}", num);
	cout << endl;
	
	save("메인.cpp");
}

==============================================
저장한 시간 :2025-03-27 오후 4:27:12 목요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 20일 목요일      (3주 2일차 강의) 
//-------------------------------------------------------------------------------------------
// 동적할당과 smart pointer - RAII 클래스로 자원을 관리하는 것
//  - C++ stack-unwinding을 보장한다
//-------------------------------------------------------------------------------------------
// Callable
//-------------------------------------------------------------------------------------------
#include<iostream>
#include<random>
#include<ranges>
#include<array>
#include<print>
#include"save.h"
using namespace std;


//[문제] 랜덤 int 1000만개를 메모리에 저장하자.
// 랜덤 int 값은 [0, 1'000'0000 ) == 0부터 999'9999 까지 값을 갖도록 
// qsort를 사용해서 오름차순으로 정렬하라
//정렬한 결과를 앞에서부터 1000개만 화면에 출력하라

array<int, 1'000'0000> a;

uniform_int_distribution uid{ 0, 999'9999 };
default_random_engine dre;

//퀵쇼트가 원소를 바꿔야 하면 1을 리턴
//이미 정렬상태이면 -1
//둘이 정렬기준상 돌일한 값이면 0를 리턴
int 오름차순(const void* a, const void* b)
{
	int* p = (int*)a;  //c언어 스타일의 캐스팅
	int* q = (int*)b;

	if (*p < *q)
		return -1;
	else if (*p > *q)
		return 1;
	
	return 0;

	/*const int* p = (const int*)a;
	int* pp = (int*)p;*/
}
int 내림차순(const void* a, const void* b)
{
	return *(int*)b - *(int*)a;
}
//----------
int main()
//----------
{
	for (int& num : a) //자료구조 a속에 int 형식의 데이터 num가 들어있는거다.  &을 붙여줘야 값이 들어간다
		num = uid(dre);

	//qsort로 내림차순(descending order) 정렬
	
	int (*정렬기준)(const void*, const void*) = 오름차순;
	qsort(a.data(), a.size(),sizeof(int), 정렬기준);

	//앞에서 부터 1000개 화면 출력 여기서 개선책이 없을까???
	for (int num:a | views::take(1000))
		print("{:8}", num);
	cout << endl;
	
	save("메인.cpp");
}

==============================================
저장한 시간 :2025-03-27 오후 4:46:36 목요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 20일 목요일      (3주 2일차 강의) 
//-------------------------------------------------------------------------------------------
// 동적할당과 smart pointer - RAII 클래스로 자원을 관리하는 것
//  - C++ stack-unwinding을 보장한다
//-------------------------------------------------------------------------------------------
// Callable
//-------------------------------------------------------------------------------------------
#include<iostream>
#include<random>
#include<array>
#include<print>
#include<ranges>
#include<algorithm>
#include"save.h"
using namespace std;


//[문제] 랜덤 int 1000만개를 메모리에 저장하자.
// 랜덤 int 값은 [0, 1'000'0000 ) == 0부터 999'9999 까지 값을 갖도록 
// c++언어의 sort를 사용해서 오름차순으로 정렬하라
//정렬한 결과를 앞에서부터 1000개만 화면에 출력하라

array<int, 1'000'0000> a;

uniform_int_distribution uid{ 0, 999'9999 };
default_random_engine dre;


//----------
int main()
//----------
{
	for (int& num : a) //자료구조 a속에 int 형식의 데이터 num가 들어있는거다.  &을 붙여줘야 값이 들어간다
		num = uid(dre);

	//정렬
	sort(a.begin(), a.end());
	
	for (int num:a | views::take(1000))
		print("{:8}", num);
	cout << endl;
	
	save("메인.cpp");
}

==============================================
저장한 시간 :2025-03-27 오후 4:54:54 목요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 20일 목요일      (3주 2일차 강의) 
//-------------------------------------------------------------------------------------------
// 동적할당과 smart pointer - RAII 클래스로 자원을 관리하는 것
//  - C++ stack-unwinding을 보장한다
//-------------------------------------------------------------------------------------------
// Callable
//-------------------------------------------------------------------------------------------
#include<iostream>
#include<random>
#include<array>
#include<print>
#include<ranges>
#include<algorithm>
#include"save.h"
using namespace std;


//[문제] 랜덤 int 1000만개를 메모리에 저장하자.
// 랜덤 int 값은 [0, 1'000'0000 ) == 0부터 999'9999 까지 값을 갖도록 
// c++언어의 sort를 사용해서 오름차순으로 정렬하라
//정렬한 결과를 앞에서부터 1000개만 화면에 출력하라

array<int, 1'000'0000> a;

uniform_int_distribution uid{ 0, 999'9999 };
default_random_engine dre;

bool 오름차순(const int a, const int b)
{
	return a < b;
}

//----------
int main()
//----------
{
	for (int& num : a)
		num = uid(dre);

	//정렬
	sort(a.begin(), a.end(),오름차순);  // 디폴트 정렬 operator <
	
	for (int num:a | views::take(1000))
		print("{:8}", num);
	cout << endl;
	
	save("메인.cpp");
}

==============================================
저장한 시간 :2025-03-27 오후 4:58:00 목요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 20일 목요일      (3주 2일차 강의) 
//-------------------------------------------------------------------------------------------
// 동적할당과 smart pointer - RAII 클래스로 자원을 관리하는 것
//  - C++ stack-unwinding을 보장한다
//-------------------------------------------------------------------------------------------
// Callable
//-------------------------------------------------------------------------------------------
#include<iostream>
#include<random>
#include<array>
#include<print>
#include<ranges>
#include<algorithm>
#include<chrono>
#include"save.h"
using namespace std;


//[문제] 랜덤 int 1000만개를 메모리에 저장하자.
// 랜덤 int 값은 [0, 1'000'0000 ) == 0부터 999'9999 까지 값을 갖도록 
// c++언어의 sort를 사용해서 오름차순으로 정렬하라
//정렬한 결과를 앞에서부터 1000개만 화면에 출력하라

array<int, 1'000'0000> a;

uniform_int_distribution uid{ 0, 999'9999 };
default_random_engine dre;

bool 오름차순(const int a, const int b)
{
	return a < b;
}

//----------
int main()
//----------
{
	for (int& num : a)
		num = uid(dre);

	//정렬에 걸리는 시간 측정
	auto 시작 =chrono::high_resolution_clock::now( );//스톱워치 시작
	sort(a.begin(), a.end(),오름차순);  // 디폴트 정렬 operator <
	auto 끝 = chrono::high_resolution_clock::now();//스톱워치 시작

	cout << "경과 시간(duration)  : " << 끝 - 시작 << endl;
	//스톱워치 끝
	for (int num:a | views::take(1000))
		print("{:8}", num);
	cout << endl;
	
	
	save("메인.cpp");
}

==============================================
저장한 시간 :2025-03-27 오후 4:59:28 목요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 20일 목요일      (3주 2일차 강의) 
//-------------------------------------------------------------------------------------------
// 동적할당과 smart pointer - RAII 클래스로 자원을 관리하는 것
//  - C++ stack-unwinding을 보장한다
//-------------------------------------------------------------------------------------------
// Callable
//-------------------------------------------------------------------------------------------
#include<iostream>
#include<random>
#include<array>
#include<print>
#include<ranges>
#include<algorithm>
#include<chrono>
#include"save.h"
using namespace std;


//[문제] 랜덤 int 1000만개를 메모리에 저장하자.
// 랜덤 int 값은 [0, 1'000'0000 ) == 0부터 999'9999 까지 값을 갖도록 
// c++언어의 sort를 사용해서 오름차순으로 정렬하라
//정렬한 결과를 앞에서부터 1000개만 화면에 출력하라

array<int, 1'000'0000> a;

uniform_int_distribution uid{ 0, 999'9999 };
default_random_engine dre;

bool 오름차순(const int a, const int b)
{
	return a < b;
}

//----------
int main()
//----------
{
	for (int& num : a)
		num = uid(dre);

	//정렬에 걸리는 시간 측정
	auto 시작 =chrono::high_resolution_clock::now( );//스톱워치 시작
	sort(a.begin(), a.end(),오름차순);  // 디폴트 정렬 operator <
	auto 끝 = chrono::high_resolution_clock::now();//스톱워치 시작

	cout << "경과 시간(duration)  : " << 끝 - 시작 << endl;
	//스톱워치 끝
	for (int num:a | views::take(1000))
		print("{:8}", num);
	cout << endl;
	
	
	save("메인.cpp");
}

==============================================
저장한 시간 :2025-03-27 오후 5:00:47 목요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 20일 목요일      (3주 2일차 강의) 
//-------------------------------------------------------------------------------------------
// 동적할당과 smart pointer - RAII 클래스로 자원을 관리하는 것
//  - C++ stack-unwinding을 보장한다
//-------------------------------------------------------------------------------------------
// Callable
//-------------------------------------------------------------------------------------------
#include<iostream>
#include<random>
#include<array>
#include<print>
#include<ranges>
#include<algorithm>
#include<chrono>
#include"save.h"
using namespace std;


//[문제] 랜덤 int 1000만개를 메모리에 저장하자.
// 랜덤 int 값은 [0, 1'000'0000 ) == 0부터 999'9999 까지 값을 갖도록 
// c++언어의 sort를 사용해서 오름차순으로 정렬하라
//정렬한 결과를 앞에서부터 1000개만 화면에 출력하라

array<int, 1'000'0000> a;

uniform_int_distribution uid{ 0, 999'9999 };
default_random_engine dre;

bool 오름차순(const int a, const int b)
{
	return a < b;
}

//----------
int main()
//----------
{
	for (int& num : a)
		num = uid(dre);

	//정렬에 걸리는 시간 측정
	auto 시작 =chrono::high_resolution_clock::now( );//스톱워치 시작
	sort(a.begin(), a.end(),오름차순);  // 디폴트 정렬 operator <
	auto 끝 = chrono::high_resolution_clock::now();//스톱워치 시작

	cout << "경과 시간(duration)  : " << 끝 - 시작 << endl;
	cout << "경과 시간(ms)  : " << chrono::duration_cast<chrono::milliseconds>(끝 - 시작) << endl;
	
	//스톱워치 끝
	for (int num:a | views::take(1000))
		print("{:8}", num);
	cout << endl;
	
	
	save("메인.cpp");
}

==============================================
저장한 시간 :2025-03-27 오후 5:01:06 목요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 20일 목요일      (3주 2일차 강의) 
//-------------------------------------------------------------------------------------------
// 동적할당과 smart pointer - RAII 클래스로 자원을 관리하는 것
//  - C++ stack-unwinding을 보장한다
//-------------------------------------------------------------------------------------------
// Callable
//-------------------------------------------------------------------------------------------
#include<iostream>
#include<random>
#include<array>
#include<print>
#include<ranges>
#include<algorithm>
#include<chrono>
#include"save.h"
using namespace std;


//[문제] 랜덤 int 1000만개를 메모리에 저장하자.
// 랜덤 int 값은 [0, 1'000'0000 ) == 0부터 999'9999 까지 값을 갖도록 
// c++언어의 sort를 사용해서 오름차순으로 정렬하라
//정렬한 결과를 앞에서부터 1000개만 화면에 출력하라

array<int, 1'000'0000> a;

uniform_int_distribution uid{ 0, 999'9999 };
default_random_engine dre;

bool 오름차순(const int a, const int b)
{
	return a < b;
}

//----------
int main()
//----------
{
	for (int& num : a)
		num = uid(dre);

	//정렬에 걸리는 시간 측정
	auto 시작 =chrono::high_resolution_clock::now( );//스톱워치 시작
	sort(a.begin(), a.end(),오름차순);  // 디폴트 정렬 operator <
	auto 끝 = chrono::high_resolution_clock::now();//스톱워치 시작

	cout << "경과 시간(duration)  : " << 끝 - 시작 << endl;
	cout << "경과 시간(ms)  : " << chrono::duration_cast<chrono::milliseconds>(끝 - 시작) << endl;
	
	//스톱워치 끝
	/*for (int num:a | views::take(1000))
		print("{:8}", num);
	cout << endl;*/
	
	
	save("메인.cpp");
}

==============================================
저장한 시간 :2025-03-27 오후 5:04:38 목요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 20일 목요일      (3주 2일차 강의) 
//-------------------------------------------------------------------------------------------
// 동적할당과 smart pointer - RAII 클래스로 자원을 관리하는 것
//  - C++ stack-unwinding을 보장한다
//-------------------------------------------------------------------------------------------
// Callable
//-------------------------------------------------------------------------------------------
#include<iostream>
#include<random>
#include<array>
#include<print>
#include<ranges>
#include<algorithm>
#include<chrono>
#include"save.h"
using namespace std;


//[문제] 랜덤 int 1000만개를 메모리에 저장하자.
// 랜덤 int 값은 [0, 1'000'0000 ) == 0부터 999'9999 까지 값을 갖도록 
// c++언어의 sort를 사용해서 오름차순으로 정렬하라
//정렬한 결과를 앞에서부터 1000개만 화면에 출력하라

array<int, 1'000'0000> a;

uniform_int_distribution uid{ 0, 999'9999 };
default_random_engine dre;

bool 오름차순(const int a, const int b)
{
	return a < b;
}

//----------
int main()
//----------
{
	{ 
		for (int& num : a)
			num = uid(dre);

		//정렬에 걸리는 시간 측정
		auto 시작 = chrono::high_resolution_clock::now();//스톱워치 시작
		sort(a.begin(), a.end(), 오름차순);  // 디폴트 정렬 operator <
		auto 끝 = chrono::high_resolution_clock::now();//스톱워치 시작

		cout << "경과 시간(ms)  : " << chrono::duration_cast<chrono::milliseconds>(끝 - 시작) << endl;

	}

	{ //내림차순
		for (int& num : a)
			num = uid(dre);

		//정렬에 걸리는 시간 측정
		auto 시작 = chrono::high_resolution_clock::now();//스톱워치 시작
		sort(a.begin(), a.end(), [](const int a, const int b) {
			return a > b;
		});
		auto 끝 = chrono::high_resolution_clock::now();//스톱워치 시작

		cout << "경과 시간(ms)  : " << chrono::duration_cast<chrono::milliseconds>(끝 - 시작) << endl;

	}
	//스톱워치 끝
	/*for (int num:a | views::take(1000))
		print("{:8}", num);
	cout << endl;*/
	
	
	save("메인.cpp");
}

==============================================
저장한 시간 :2025-03-27 오후 7:02:54 목요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 20일 목요일      (3주 2일차 강의) 
//-------------------------------------------------------------------------------------------
// 동적할당과 smart pointer - RAII 클래스로 자원을 관리하는 것
//  - C++ stack-unwinding을 보장한다
//-------------------------------------------------------------------------------------------
// Callable
//-------------------------------------------------------------------------------------------
#include<iostream>
#include<random>
#include<array>
#include<print>
#include<ranges>
#include<algorithm>
#include<chrono>
#include"save.h"
using namespace std;


//[문제] 랜덤 int 1000만개를 메모리에 저장하자.
// 랜덤 int 값은 [0, 1'000'0000 ) == 0부터 999'9999 까지 값을 갖도록 
// c++언어의 sort를 사용해서 오름차순으로 정렬하라
//정렬한 결과를 앞에서부터 1000개만 화면에 출력하라

array<int, 1'000'0000> a;

uniform_int_distribution uid{ 0, 999'9999 };
default_random_engine dre;

bool 오름차순(const int a, const int b)
{
	return a < b;
}

//----------
int main()
//----------
{
	{ 
		for (int& num : a)
			num = uid(dre);

		//정렬에 걸리는 시간 측정
		auto 시작 = chrono::high_resolution_clock::now();//스톱워치 시작
		sort(a.begin(), a.end(), 오름차순);  // 디폴트 정렬 operator <
		auto 끝 = chrono::high_resolution_clock::now();//스톱워치 시작

		cout << "경과 시간(ms)  : " << chrono::duration_cast<chrono::milliseconds>(끝 - 시작) << endl;

	}

	{ //내림차순
		for (int& num : a)
			num = uid(dre);

		//정렬에 걸리는 시간 측정
		auto 시작 = chrono::high_resolution_clock::now();//스톱워치 시작
		sort(a.begin(), a.end(), [](const int a, const int b) {
			return a > b;
		});
		auto 끝 = chrono::high_resolution_clock::now();//스톱워치 시작

		cout << "경과 시간(ms)  : " << chrono::duration_cast<chrono::milliseconds>(끝 - 시작) << endl;

	}
	//스톱워치 끝
	/*for (int num:a | views::take(1000))
		print("{:8}", num);
	cout << endl;*/
	
	
	save("메인.cpp");
}

==============================================
저장한 시간 :2025-04-01 오후 1:30:52 화요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 20일 목요일      (3주 2일차 강의) 
//-------------------------------------------------------------------------------------------
// 동적할당과 smart pointer - RAII 클래스로 자원을 관리하는 것
//  - C++ stack-unwinding을 보장한다
//-------------------------------------------------------------------------------------------
// Callable
//-------------------------------------------------------------------------------------------
#include<iostream>
#include<random>
#include<array>
#include<print>
#include<ranges>
#include<algorithm>
#include<chrono>
#include"save.h"
using namespace std;


//[문제] 랜덤 int 1000만개를 메모리에 저장하자.
// 랜덤 int 값은 [0, 1'000'0000 ) == 0부터 999'9999 까지 값을 갖도록 
// c++언어의 sort를 사용해서 오름차순으로 정렬하라
//정렬한 결과를 앞에서부터 1000개만 화면에 출력하라

array<int, 1'000'0000> a;

uniform_int_distribution uid{ 0, 999'9999 };
default_random_engine dre;

bool 오름차순(const int a, const int b)
{
	return a < b;
}

//----------
int main()
//----------
{
	{ 
		for (int& num : a)
			num = uid(dre);

		//정렬에 걸리는 시간 측정
		auto 시작 = chrono::high_resolution_clock::now();//스톱워치 시작
		sort(a.begin(), a.end(), 오름차순);  // 디폴트 정렬 operator <
		auto 끝 = chrono::high_resolution_clock::now();//스톱워치 시작

		cout << "경과 시간(ms)  : " << chrono::duration_cast<chrono::milliseconds>(끝 - 시작) << endl;

	}

	{ //내림차순
		for (int& num : a)
			num = uid(dre);

		//정렬에 걸리는 시간 측정
		auto 시작 = chrono::high_resolution_clock::now();//스톱워치 시작
		sort(a.begin(), a.end(), [](const int a, const int b) {
			return a > b;
		});
		auto 끝 = chrono::high_resolution_clock::now();//스톱워치 시작

		cout << "경과 시간(ms)  : " << chrono::duration_cast<chrono::milliseconds>(끝 - 시작) << endl;

	}
	//스톱워치 끝
	/*for (int num:a | views::take(1000))
		print("{:8}", num);
	cout << endl;*/
	
	
	save("메인.cpp");
}

==============================================
저장한 시간 :2025-04-01 오후 1:37:45 화요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 20일 목요일      (3주 2일차 강의) 
// 4월 24일 중간고사 8주차 2일
//-------------------------------------------------------------------------------------------
// Callable type -호출 가능한 타입
// 1.합수
// 2.합수 포인터
// 3. 람다
//-------------------------------------------------------------------------------------------
// 
//-------------------------------------------------------------------------------------------
#include<iostream>
#include"save.h"
using namespace std;



//----------
int main()
//----------
{
	
	//람다는 도대체 무엇인가?
	//너는 자료형이 뭐니?
	cout<<"람다의 정체 -"<<
	typeid([]() {
		cout << "안녕! 난 이름이 없어" << endl;
		}).name() << endl;; //자료형을 우리가 알아볼 수 있는 글자로 리턴해줘
	save("메인.cpp");
}

==============================================
저장한 시간 :2025-04-01 오후 1:38:40 화요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 20일 목요일      (3주 2일차 강의) 
// 4월 24일 중간고사 8주차 2일
//-------------------------------------------------------------------------------------------
// Callable type -호출 가능한 타입
// 1.합수
// 2.합수 포인터
// 3. 람다
//-------------------------------------------------------------------------------------------
// 
//-------------------------------------------------------------------------------------------
#include<iostream>
#include"save.h"
using namespace std;



//----------
int main()
//----------
{
	
	//람다는 도대체 무엇인가?
	//너는 자료형이 뭐니?
	cout<<"람다의 정체 -"<<
	typeid([]() {
		cout << "안녕! 난 이름이 없어" << endl;
		}).name() << endl;; //자료형을 우리가 알아볼 수 있는 글자로 리턴해줘

	cout << "람다의 정체 -" <<
		typeid([]() {
		cout << "안녕! 난 이름이 없어" << endl;
			}).name() << endl;; //자료형을 우리가 알아볼 수 있는 글자로 리턴해줘
	save("메인.cpp");
}

==============================================
저장한 시간 :2025-04-01 오후 1:38:58 화요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 20일 목요일      (3주 2일차 강의) 
// 4월 24일 중간고사 8주차 2일
//-------------------------------------------------------------------------------------------
// Callable type -호출 가능한 타입
// 1.합수
// 2.합수 포인터
// 3. 람다
//-------------------------------------------------------------------------------------------
// 
//-------------------------------------------------------------------------------------------
#include<iostream>
#include"save.h"
using namespace std;



//----------
int main()
//----------
{
	
	//람다는 도대체 무엇인가?
	//너는 자료형이 뭐니?
	cout<<"람다 1의 정체 -"<<
	typeid([]() {
		cout << "안녕! 난 이름이 없어" << endl;
		}).name() << endl;; //자료형을 우리가 알아볼 수 있는 글자로 리턴해줘

	cout << "람다 2의 정체 -" <<
		typeid([]() {
		cout << "안녕! 난 이름이 없어" << endl;
			}).name() << endl;; //자료형을 우리가 알아볼 수 있는 글자로 리턴해줘
	save("메인.cpp");
}

==============================================
저장한 시간 :2025-04-01 오후 1:43:48 화요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 20일 목요일      (3주 2일차 강의) 
// 4월 24일 중간고사 8주차 2일
//-------------------------------------------------------------------------------------------
// Callable type -호출 가능한 타입
// 1.합수
// 2.합수 포인터
// 3. 람다
//-------------------------------------------------------------------------------------------
// 
//-------------------------------------------------------------------------------------------
#include<iostream>
#include"save.h"
using namespace std;



//----------
int main()
//----------
{
	
	//람다는 도대체 무엇인가?
	//너는 자료형이 뭐니?

		[]() {
		cout << "안녕! 난 이름이 없어" << endl;
		};
		int* 저장 = (int*)save;
		cout << "save의 메모리 번지 -" << 저장 << endl;
	save("메인.cpp");
}

==============================================
저장한 시간 :2025-04-01 오후 1:49:28 화요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 20일 목요일      (3주 2일차 강의) 
// 4월 24일 중간고사 8주차 2일
//-------------------------------------------------------------------------------------------
// Callable type -호출 가능한 타입
// 1.합수
// 2.합수 포인터
// 3. 람다
//-------------------------------------------------------------------------------------------
// 
//-------------------------------------------------------------------------------------------
#include<iostream>
#include"save.h"
using namespace std;

class Dog {
public:
	void operator()() { //연산자를 함수로 만듦
		cout << "나를 왜 불렀죠?" << endl;
	}
};


//----------
int main()
//----------
{

	Dog dog; //자료형을 정의 한 것 이기때문에 이게 가능

	dog( ); //얘가 연산자라는 걸 이해하면 이게 끝난다.

	save("메인.cpp");
}

==============================================
저장한 시간 :2025-04-01 오후 1:50:09 화요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 20일 목요일      (3주 2일차 강의) 
// 4월 24일 중간고사 8주차 2일
//-------------------------------------------------------------------------------------------
// Callable type -호출 가능한 타입
// 1.합수
// 2.합수 포인터
// 3. 람다
//-------------------------------------------------------------------------------------------
// 
//-------------------------------------------------------------------------------------------
#include<iostream>
#include"save.h"
using namespace std;

class Dog {
public:
	void operator()() { //연산자를 함수로 만듦
		cout << "나를 왜 불렀죠?" << endl;
	}
};


//----------
int main()
//----------
{

	Dog dog; //자료형을 정의 한 것 이기때문에 이게 가능

	dog( ); //얘가 연산자라는 걸 이해하면 이게 끝난다.

	save("메인.cpp");
}

==============================================
저장한 시간 :2025-04-01 오후 1:51:25 화요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 20일 목요일      (3주 2일차 강의) 
// 4월 24일 중간고사 8주차 2일
//-------------------------------------------------------------------------------------------
// Callable type -호출 가능한 타입
// 1.합수
// 2.합수 포인터
// 3. 람다
//-------------------------------------------------------------------------------------------
// 
//-------------------------------------------------------------------------------------------
#include<iostream>
#include"save.h"
using namespace std;

class Dog {
public:
	void operator()() { //연산자를 함수로 만듦
		cout << "나를 왜 불렀죠?" << endl;
	}
};


//----------
int main()
//----------
{

	Dog dog; //자료형을 정의 한 것 이기때문에 이게 가능

	cout << typeid(dog).name() << endl;

	dog.operator()( ); //얘가 연산자라는 걸 이해하면 이게 끝난다.

	save("메인.cpp");
}

==============================================
저장한 시간 :2025-04-01 오후 1:51:41 화요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 20일 목요일      (3주 2일차 강의) 
// 4월 24일 중간고사 8주차 2일
//-------------------------------------------------------------------------------------------
// Callable type -호출 가능한 타입
// 1.합수
// 2.합수 포인터
// 3. 람다
//-------------------------------------------------------------------------------------------
// 
//-------------------------------------------------------------------------------------------
#include<iostream>
#include"save.h"
using namespace std;




//----------
int main()
//----------
{
	class Dog {
	public:
		void operator()() { //연산자를 함수로 만듦
			cout << "나를 왜 불렀죠?" << endl;
		}
	};
	Dog dog; //자료형을 정의 한 것 이기때문에 이게 가능

	cout << typeid(dog).name() << endl;

	dog.operator()( ); //얘가 연산자라는 걸 이해하면 이게 끝난다.

	save("메인.cpp");
}

==============================================
저장한 시간 :2025-04-01 오후 1:52:44 화요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 20일 목요일      (3주 2일차 강의) 
// 4월 24일 중간고사 8주차 2일
//-------------------------------------------------------------------------------------------
// Callable type -호출 가능한 타입
// 1.합수
// 2.합수 포인터
// 3. 람다
//-------------------------------------------------------------------------------------------
// 
//-------------------------------------------------------------------------------------------
#include<iostream>
#include"save.h"
using namespace std;

void dogFun() {
	//지역 클래스로 바꿔버리면 람다처럼 된다.
	class Dog {
	public:
		void operator()() { //연산자를 함수로 만듦
			cout << "나를 왜 불렀죠?" << endl;
		}
	};
	Dog dog; //자료형을 정의 한 것 이기때문에 이게 가능

	cout << typeid(dog).name() << endl;
}


//----------
int main()
//----------
{
	

	dogFun();

	save("메인.cpp");
}

==============================================
저장한 시간 :2025-04-01 오후 1:57:59 화요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 20일 목요일      (3주 2일차 강의) 
// 4월 24일 중간고사 8주차 2일
//-------------------------------------------------------------------------------------------
// Callable type -호출 가능한 타입
// 1.합수
// 2.합수 포인터
// 3. 람다 - 이름 없는함수 - 실체가 있어야 한다. (VS 에서는 class로 코딩해준다)
// 4. 함수 객체(function object) - 함수호출연산자를 오버로딩 한 클래스 객체
//-------------------------------------------------------------------------------------------
// 
//-------------------------------------------------------------------------------------------
#include<iostream>
#include<array>
#include"save.h"
using namespace std;

#include<iostream>
#include<array>
#include<algorithm>
#include"save.h"
using namespace std;

class Dog {
public:
    bool operator()(const int a,const int b) {
        return a > b;
    }
};

//----------
int main()
//----------
{
    array<int, 10> a{ 1,3,5,7,9,2,4,6,9,10 };

    //[문제] 다음 코드가 의도대로 실행될 수 있게 필요한 코딩을 추가하라

    sort(a.begin(), a.end(), Dog{});
    for (int num : a)
        cout << num;
    cout << endl; //10,9,8,7,6,5,4,3,2,1
    save("메인.cpp");
}

==============================================
저장한 시간 :2025-04-01 오후 1:58:13 화요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 20일 목요일      (3주 2일차 강의) 
// 4월 24일 중간고사 8주차 2일
//-------------------------------------------------------------------------------------------
// Callable type -호출 가능한 타입
// 1.합수
// 2.합수 포인터
// 3. 람다 - 이름 없는함수 - 실체가 있어야 한다. (VS 에서는 class로 코딩해준다)
// 4. 함수 객체(function object) - 함수호출연산자를 오버로딩 한 클래스 객체
//-------------------------------------------------------------------------------------------
// 
//-------------------------------------------------------------------------------------------
#include<iostream>
#include<array>
#include"save.h"
using namespace std;

#include<iostream>
#include<array>
#include<algorithm>
#include"save.h"
using namespace std;

class Dog {
public:
    bool operator()(const int a,const int b) {
        return a > b;
    }
};

//----------
int main()
//----------
{
    array<int, 10> a{ 1,3,5,7,9,2,4,6,9,10 };

    //[문제] 다음 코드가 의도대로 실행될 수 있게 필요한 코딩을 추가하라

    sort(a.begin(), a.end(), Dog{});
    for (int num : a)
        cout << num<< " ,";
    cout << endl; //10,9,8,7,6,5,4,3,2,1
    save("메인.cpp");
}

==============================================
저장한 시간 :2025-04-01 오후 1:58:22 화요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 20일 목요일      (3주 2일차 강의) 
// 4월 24일 중간고사 8주차 2일
//-------------------------------------------------------------------------------------------
// Callable type -호출 가능한 타입
// 1.합수
// 2.합수 포인터
// 3. 람다 - 이름 없는함수 - 실체가 있어야 한다. (VS 에서는 class로 코딩해준다)
// 4. 함수 객체(function object) - 함수호출연산자를 오버로딩 한 클래스 객체
//-------------------------------------------------------------------------------------------
// 
//-------------------------------------------------------------------------------------------
#include<iostream>
#include<array>
#include"save.h"
using namespace std;

#include<iostream>
#include<array>
#include<algorithm>
#include"save.h"
using namespace std;

class Dog {
public:
    bool operator()(const int a,const int b) {
        return a > b;
    }
};

//----------
int main()
//----------
{
    array<int, 10> a{ 1,3,5,7,9,2,4,6,9,10 };

    //[문제] 다음 코드가 의도대로 실행될 수 있게 필요한 코딩을 추가하라

    sort(a.begin(), a.end(), Dog{});
    for (int num : a)
        cout << num<< ",";
    cout << endl; //10,9,8,7,6,5,4,3,2,1
    save("메인.cpp");
}

==============================================
저장한 시간 :2025-04-01 오후 1:59:38 화요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 20일 목요일      (3주 2일차 강의) 
// 4월 24일 중간고사 8주차 2일
//-------------------------------------------------------------------------------------------
// Callable type -호출 가능한 타입
// 1.합수
// 2.합수 포인터
// 3. 람다 - 이름 없는함수 - 실체가 있어야 한다. (VS 에서는 class로 코딩해준다)
// 4. 함수 객체(function object) - 함수호출연산자를 오버로딩 한 클래스 객체
//-------------------------------------------------------------------------------------------
// 
//-------------------------------------------------------------------------------------------
#include<iostream>
#include<array>
#include"save.h"
using namespace std;

#include<iostream>
#include<array>
#include<algorithm>
#include"save.h"
using namespace std;

class Dog {
public:
    int operator()(const int a,const int b) {
        return a - b;
    }
};

//----------
int main()
//----------
{
    array<int, 10> a{ 1,3,5,7,9,2,4,6,9,10 };

    //[문제] 다음 코드가 의도대로 실행될 수 있게 필요한 코딩을 추가하라

    sort(a.begin(), a.end(), Dog{});
    for (int num : a)
        cout << num<< ",";
    cout << endl; //10,9,8,7,6,5,4,3,2,1
    save("메인.cpp");
}

==============================================
저장한 시간 :2025-04-01 오후 1:59:47 화요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 20일 목요일      (3주 2일차 강의) 
// 4월 24일 중간고사 8주차 2일
//-------------------------------------------------------------------------------------------
// Callable type -호출 가능한 타입
// 1.합수
// 2.합수 포인터
// 3. 람다 - 이름 없는함수 - 실체가 있어야 한다. (VS 에서는 class로 코딩해준다)
// 4. 함수 객체(function object) - 함수호출연산자를 오버로딩 한 클래스 객체
//-------------------------------------------------------------------------------------------
// 
//-------------------------------------------------------------------------------------------
#include<iostream>
#include<array>
#include"save.h"
using namespace std;

#include<iostream>
#include<array>
#include<algorithm>
#include"save.h"
using namespace std;

class Dog {
public:
    int operator()(const int a,const int b) {
        return b-a;
    }
};

//----------
int main()
//----------
{
    array<int, 10> a{ 1,3,5,7,9,2,4,6,9,10 };

    //[문제] 다음 코드가 의도대로 실행될 수 있게 필요한 코딩을 추가하라

    sort(a.begin(), a.end(), Dog{});
    for (int num : a)
        cout << num<< ",";
    cout << endl; //10,9,8,7,6,5,4,3,2,1
    save("메인.cpp");
}

==============================================
저장한 시간 :2025-04-01 오후 2:00:35 화요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 20일 목요일      (3주 2일차 강의) 
// 4월 24일 중간고사 8주차 2일
//-------------------------------------------------------------------------------------------
// Callable type -호출 가능한 타입
// 1.합수
// 2.합수 포인터
// 3. 람다 - 이름 없는함수 - 실체가 있어야 한다. (VS 에서는 class로 코딩해준다)
// 4. 함수 객체(function object) - 함수호출연산자를 오버로딩 한 클래스 객체
//-------------------------------------------------------------------------------------------
// 
//-------------------------------------------------------------------------------------------
#include<iostream>
#include<array>
#include"save.h"
using namespace std;

#include<iostream>
#include<array>
#include<algorithm>
#include"save.h"
using namespace std;

class Dog {
public:
    int operator()(const int a,const int b) {
        return a-b;
    }
};

//----------
int main()
//----------
{
    array<int, 10> a{ 1,3,5,7,9,2,4,6,9,10 };

    //[문제] 다음 코드가 의도대로 실행될 수 있게 필요한 코딩을 추가하라

    sort(a.begin(), a.end(), Dog{});
    for (int num : a)
        cout << num<< ",";
    cout << endl; //10,9,8,7,6,5,4,3,2,1
    save("메인.cpp");
}

==============================================
저장한 시간 :2025-04-01 오후 2:01:54 화요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 20일 목요일      (3주 2일차 강의) 
// 4월 24일 중간고사 8주차 2일
//-------------------------------------------------------------------------------------------
// Callable type -호출 가능한 타입
// 1.합수
// 2.합수 포인터
// 3. 람다 - 이름 없는함수 - 실체가 있어야 한다. (VS 에서는 class로 코딩해준다)
// 4. 함수 객체(function object) - 함수호출연산자를 오버로딩 한 클래스 객체
//-------------------------------------------------------------------------------------------
// 
//-------------------------------------------------------------------------------------------
#include<iostream>
#include<array>
#include"save.h"
using namespace std;

#include<iostream>
#include<array>
#include<algorithm>
#include"save.h"
using namespace std;

class Dog {
public:
    int operator()(const int a,const int b) {
        return b-a;
    }
};

//----------
int main()
//----------
{
    array<int, 10> a{ 1,3,5,7,9,2,4,6,9,10 };

    //[문제] 다음 코드가 의도대로 실행될 수 있게 필요한 코딩을 추가하라

    sort(a.begin(), a.end(), Dog{});
    for (int num : a)
        cout << num<< ",";
    cout << endl; //10,9,8,7,6,5,4,3,2,1
    save("메인.cpp");
}

==============================================
저장한 시간 :2025-04-01 오후 2:02:10 화요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 20일 목요일      (3주 2일차 강의) 
// 4월 24일 중간고사 8주차 2일
//-------------------------------------------------------------------------------------------
// Callable type -호출 가능한 타입
// 1.합수
// 2.합수 포인터
// 3. 람다 - 이름 없는함수 - 실체가 있어야 한다. (VS 에서는 class로 코딩해준다)
// 4. 함수 객체(function object) - 함수호출연산자를 오버로딩 한 클래스 객체
//-------------------------------------------------------------------------------------------
// 
//-------------------------------------------------------------------------------------------
#include<iostream>
#include<array>
#include"save.h"
using namespace std;

#include<iostream>
#include<array>
#include<algorithm>
#include"save.h"
using namespace std;

class Dog {
public:
    int operator()(const int a,const int b) {
        return b-a;
    }
};

//----------
int main()
//----------
{
    array<int, 10> a{ 1,3,5,7,9,2,4,6,9,10 };

    //[문제] 다음 코드가 의도대로 실행될 수 있게 필요한 코딩을 추가하라

    sort(a.begin(), a.end(), Dog{});
    for (int num : a)
        cout << num<< ",";
    cout << endl; //10,9,8,7,6,5,4,3,2,1
    save("메인.cpp");
}

==============================================
저장한 시간 :2025-04-01 오후 2:02:17 화요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 20일 목요일      (3주 2일차 강의) 
// 4월 24일 중간고사 8주차 2일
//-------------------------------------------------------------------------------------------
// Callable type -호출 가능한 타입
// 1.합수
// 2.합수 포인터
// 3. 람다 - 이름 없는함수 - 실체가 있어야 한다. (VS 에서는 class로 코딩해준다)
// 4. 함수 객체(function object) - 함수호출연산자를 오버로딩 한 클래스 객체
//-------------------------------------------------------------------------------------------
// 
//-------------------------------------------------------------------------------------------
#include<iostream>
#include<array>
#include"save.h"
using namespace std;

#include<iostream>
#include<array>
#include<algorithm>
#include"save.h"
using namespace std;

class Dog {
public:
    int operator()(const int a,const int b) {
        return b-a;
    }
};

//----------
int main()
//----------
{
    array<int, 10> a{ 1,3,5,7,9,2,4,6,9,10 };

    //[문제] 다음 코드가 의도대로 실행될 수 있게 필요한 코딩을 추가하라

    sort(a.begin(), a.end(), Dog{});
    for (int num : a)
        cout << num<< ",";
    cout << endl; //10,9,8,7,6,5,4,3,2,1
    save("메인.cpp");
}

==============================================
저장한 시간 :2025-04-01 오후 2:02:28 화요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 20일 목요일      (3주 2일차 강의) 
// 4월 24일 중간고사 8주차 2일
//-------------------------------------------------------------------------------------------
// Callable type -호출 가능한 타입
// 1.합수
// 2.합수 포인터
// 3. 람다 - 이름 없는함수 - 실체가 있어야 한다. (VS 에서는 class로 코딩해준다)
// 4. 함수 객체(function object) - 함수호출연산자를 오버로딩 한 클래스 객체
//-------------------------------------------------------------------------------------------
// 
//-------------------------------------------------------------------------------------------
#include<iostream>
#include<array>
#include"save.h"
using namespace std;

#include<iostream>
#include<array>
#include<algorithm>
#include"save.h"
using namespace std;

class Dog {
public:
    int operator()(const int a,const int b) {
        return b-a;
    }
};

//----------
int main()
//----------
{
    array<int, 10> a{ 1,3,5,7,9,2,4,6,9,10 };

    //[문제] 다음 코드가 의도대로 실행될 수 있게 필요한 코딩을 추가하라

    sort(a.begin(), a.end(), Dog{});
    for (int num : a)
        cout << num<< ",";
    cout << endl; //10,9,8,7,6,5,4,3,2,1
    save("메인.cpp");
}

==============================================
저장한 시간 :2025-04-01 오후 2:02:53 화요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 20일 목요일      (3주 2일차 강의) 
// 4월 24일 중간고사 8주차 2일
//-------------------------------------------------------------------------------------------
// Callable type -호출 가능한 타입
// 1.합수
// 2.합수 포인터
// 3. 람다 - 이름 없는함수 - 실체가 있어야 한다. (VS 에서는 class로 코딩해준다)
// 4. 함수 객체(function object) - 함수호출연산자를 오버로딩 한 클래스 객체
//-------------------------------------------------------------------------------------------
// 
//-------------------------------------------------------------------------------------------
#include<iostream>
#include<array>
#include"save.h"
using namespace std;

#include<iostream>
#include<array>
#include<algorithm>
#include"save.h"
using namespace std;

class Dog {
public:
    int operator()(const int a,const int b) {
        return b-a;
    }
};

//----------
int main()
//----------
{
    array<int, 10> a{ 1,3,5,7,9,2,4,6,9,10 };

    //[문제] 다음 코드가 의도대로 실행될 수 있게 필요한 코딩을 추가하라

    sort(a.begin(), a.end(), Dog{});
    for (int num : a)
        cout << num<< ",";
    cout << endl; //10,9,8,7,6,5,4,3,2,1
    save("메인.cpp");
}

==============================================
저장한 시간 :2025-04-01 오후 2:03:19 화요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 20일 목요일      (3주 2일차 강의) 
// 4월 24일 중간고사 8주차 2일
//-------------------------------------------------------------------------------------------
// Callable type -호출 가능한 타입
// 1.합수
// 2.합수 포인터
// 3. 람다 - 이름 없는함수 - 실체가 있어야 한다. (VS 에서는 class로 코딩해준다)
// 4. 함수 객체(function object) - 함수호출연산자를 오버로딩 한 클래스 객체
//-------------------------------------------------------------------------------------------
// 
//-------------------------------------------------------------------------------------------
#include<iostream>
#include<array>
#include"save.h"
using namespace std;

#include<iostream>
#include<array>
#include<algorithm>
#include"save.h"
using namespace std;

class Dog {
public:
    int operator()(const int a, const int b) {
        return b - a;
    }
};

//----------
int main()
//----------
{
    array<int, 10> a{ 1,3,5,7,9,2,4,6,8,10 };

    //[문제] 다음 코드가 의도대로 실행될 수 있게 필요한 코딩을 추가하라

    sort(a.begin(), a.end(), Dog{});
    for (int num : a)
        cout << num << ",";
    cout << endl; //10,9,8,7,6,5,4,3,2,1
    save("메인.cpp");
}

==============================================
저장한 시간 :2025-04-01 오후 2:03:34 화요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 20일 목요일      (3주 2일차 강의) 
// 4월 24일 중간고사 8주차 2일
//-------------------------------------------------------------------------------------------
// Callable type -호출 가능한 타입
// 1.합수
// 2.합수 포인터
// 3. 람다 - 이름 없는함수 - 실체가 있어야 한다. (VS 에서는 class로 코딩해준다)
// 4. 함수 객체(function object) - 함수호출연산자를 오버로딩 한 클래스 객체
//-------------------------------------------------------------------------------------------
// 
//-------------------------------------------------------------------------------------------
#include<iostream>
#include<array>
#include"save.h"
using namespace std;

#include<iostream>
#include<array>
#include<algorithm>
#include"save.h"
using namespace std;

class Dog {
public:
    bool operator()(const int a,const int b) {
        return a > b;
    }
};

//----------
int main()
//----------
{
    array<int, 10> a{ 1,3,5,7,9,2,4,6,9,10 };

    //[문제] 다음 코드가 의도대로 실행될 수 있게 필요한 코딩을 추가하라

    sort(a.begin(), a.end(), Dog{});
    for (int num : a)
        cout << num<< " ,";
    cout << endl; //10,9,8,7,6,5,4,3,2,1
    save("메인.cpp");
}

==============================================
저장한 시간 :2025-04-01 오후 2:03:45 화요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 20일 목요일      (3주 2일차 강의) 
// 4월 24일 중간고사 8주차 2일
//-------------------------------------------------------------------------------------------
// Callable type -호출 가능한 타입
// 1.합수
// 2.합수 포인터
// 3. 람다 - 이름 없는함수 - 실체가 있어야 한다. (VS 에서는 class로 코딩해준다)
// 4. 함수 객체(function object) - 함수호출연산자를 오버로딩 한 클래스 객체
//-------------------------------------------------------------------------------------------
// 
//-------------------------------------------------------------------------------------------
#include<iostream>
#include<array>
#include"save.h"
using namespace std;

#include<iostream>
#include<array>
#include<algorithm>
#include"save.h"
using namespace std;

class Dog {
public:
    bool operator()(const int a,const int b) {
        return a > b;
    }
};

//----------
int main()
//----------
{
    array<int, 10> a{ 1,3,5,7,9,2,4,6,9,10 };

    //[문제] 다음 코드가 의도대로 실행될 수 있게 필요한 코딩을 추가하라

    sort(a.begin(), a.end(), Dog{});
    for (int num : a)
        cout << num<< " ";
    cout << endl; //10,9,8,7,6,5,4,3,2,1
    save("메인.cpp");
}

==============================================
저장한 시간 :2025-04-01 오후 2:05:20 화요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 20일 목요일      (3주 2일차 강의) 
// 4월 24일 중간고사 8주차 2일
//-------------------------------------------------------------------------------------------
// Callable type -호출 가능한 타입
// 1.합수
// 2.합수 포인터
// 3. 람다 - 이름 없는함수 - 실체가 있어야 한다. (VS 에서는 class로 코딩해준다)
// 4. 함수 객체(function object) - 함수호출연산자를 오버로딩 한 클래스 객체
//-------------------------------------------------------------------------------------------
// 
//-------------------------------------------------------------------------------------------
#include<iostream>
#include<array>
#include"save.h"
using namespace std;

#include<iostream>
#include<array>
#include<algorithm>
#include"save.h"
using namespace std;

class Dog {
public:
    int operator()(const int a,const int b) {
        return a > b;
    }
};

//----------
int main()
//----------
{
    array<int, 10> a{ 1,3,5,7,9,2,4,6,8,10 };

    //[문제] 다음 코드가 의도대로 실행될 수 있게 필요한 코딩을 추가하라

    sort(a.begin(), a.end(), Dog{});
    for (int num : a)
        cout << num<< " ";
    cout << endl; //10,9,8,7,6,5,4,3,2,1
    save("메인.cpp");
}

==============================================
저장한 시간 :2025-04-01 오후 2:05:31 화요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 20일 목요일      (3주 2일차 강의) 
// 4월 24일 중간고사 8주차 2일
//-------------------------------------------------------------------------------------------
// Callable type -호출 가능한 타입
// 1.합수
// 2.합수 포인터
// 3. 람다 - 이름 없는함수 - 실체가 있어야 한다. (VS 에서는 class로 코딩해준다)
// 4. 함수 객체(function object) - 함수호출연산자를 오버로딩 한 클래스 객체
//-------------------------------------------------------------------------------------------
// 
//-------------------------------------------------------------------------------------------
#include<iostream>
#include<array>
#include"save.h"
using namespace std;

#include<iostream>
#include<array>
#include<algorithm>
#include"save.h"
using namespace std;

class Dog {
public:
    int operator()(const int a,const int b) {
        return a - b;
    }
};

//----------
int main()
//----------
{
    array<int, 10> a{ 1,3,5,7,9,2,4,6,8,10 };

    //[문제] 다음 코드가 의도대로 실행될 수 있게 필요한 코딩을 추가하라

    sort(a.begin(), a.end(), Dog{});
    for (int num : a)
        cout << num<< " ";
    cout << endl; //10,9,8,7,6,5,4,3,2,1
    save("메인.cpp");
}

==============================================
저장한 시간 :2025-04-01 오후 2:05:39 화요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 20일 목요일      (3주 2일차 강의) 
// 4월 24일 중간고사 8주차 2일
//-------------------------------------------------------------------------------------------
// Callable type -호출 가능한 타입
// 1.합수
// 2.합수 포인터
// 3. 람다 - 이름 없는함수 - 실체가 있어야 한다. (VS 에서는 class로 코딩해준다)
// 4. 함수 객체(function object) - 함수호출연산자를 오버로딩 한 클래스 객체
//-------------------------------------------------------------------------------------------
// 
//-------------------------------------------------------------------------------------------
#include<iostream>
#include<array>
#include"save.h"
using namespace std;

#include<iostream>
#include<array>
#include<algorithm>
#include"save.h"
using namespace std;

class Dog {
public:
    int operator()(const int a,const int b) {
        return a > b;
    }
};

//----------
int main()
//----------
{
    array<int, 10> a{ 1,3,5,7,9,2,4,6,8,10 };

    //[문제] 다음 코드가 의도대로 실행될 수 있게 필요한 코딩을 추가하라

    sort(a.begin(), a.end(), Dog{});
    for (int num : a)
        cout << num<< " ";
    cout << endl; //10,9,8,7,6,5,4,3,2,1
    save("메인.cpp");
}

==============================================
저장한 시간 :2025-04-01 오후 2:06:18 화요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 20일 목요일      (3주 2일차 강의) 
// 4월 24일 중간고사 8주차 2일
//-------------------------------------------------------------------------------------------
// Callable type -호출 가능한 타입
// 1.합수
// 2.합수 포인터
// 3. 람다 - 이름 없는함수 - 실체가 있어야 한다. (VS 에서는 class로 코딩해준다)
// 4. 함수 객체(function object) - 함수호출연산자를 오버로딩 한 클래스 객체
//-------------------------------------------------------------------------------------------
// 
//-------------------------------------------------------------------------------------------
#include<iostream>
#include<array>
#include"save.h"
using namespace std;

#include<iostream>
#include<array>
#include<algorithm>
#include"save.h"
using namespace std;

class Dog {
public:
    int operator()(const int a,const int b) {
        if (a > b)
            return 1;
        else if (a < b)
            return -1;
        else
            return 0;
    }
};

//----------
int main()
//----------
{
    array<int, 10> a{ 1,3,5,7,9,2,4,6,8,10 };

    //[문제] 다음 코드가 의도대로 실행될 수 있게 필요한 코딩을 추가하라

    sort(a.begin(), a.end(), Dog{});
    for (int num : a)
        cout << num<< " ";
    cout << endl; //10,9,8,7,6,5,4,3,2,1
    save("메인.cpp");
}

==============================================
저장한 시간 :2025-04-01 오후 2:06:45 화요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 20일 목요일      (3주 2일차 강의) 
// 4월 24일 중간고사 8주차 2일
//-------------------------------------------------------------------------------------------
// Callable type -호출 가능한 타입
// 1.합수
// 2.합수 포인터
// 3. 람다 - 이름 없는함수 - 실체가 있어야 한다. (VS 에서는 class로 코딩해준다)
// 4. 함수 객체(function object) - 함수호출연산자를 오버로딩 한 클래스 객체
//-------------------------------------------------------------------------------------------
// 
//-------------------------------------------------------------------------------------------
#include<iostream>
#include<array>
#include"save.h"
using namespace std;

#include<iostream>
#include<array>
#include<algorithm>
#include"save.h"
using namespace std;

class Dog {
public:
    int operator()(const int a,const int b) {
        if (a > b)
            return 1;
        else if (a < b)
            return 0;
        else
            return 0;
        return a > b;
    }
};

//----------
int main()
//----------
{
    array<int, 10> a{ 1,3,5,7,9,2,4,6,8,10 };

    //[문제] 다음 코드가 의도대로 실행될 수 있게 필요한 코딩을 추가하라

    sort(a.begin(), a.end(), Dog{});
    for (int num : a)
        cout << num<< " ";
    cout << endl; //10,9,8,7,6,5,4,3,2,1
    save("메인.cpp");
}

==============================================
저장한 시간 :2025-04-01 오후 2:06:57 화요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 20일 목요일      (3주 2일차 강의) 
// 4월 24일 중간고사 8주차 2일
//-------------------------------------------------------------------------------------------
// Callable type -호출 가능한 타입
// 1.합수
// 2.합수 포인터
// 3. 람다 - 이름 없는함수 - 실체가 있어야 한다. (VS 에서는 class로 코딩해준다)
// 4. 함수 객체(function object) - 함수호출연산자를 오버로딩 한 클래스 객체
//-------------------------------------------------------------------------------------------
// 
//-------------------------------------------------------------------------------------------
#include<iostream>
#include<array>
#include"save.h"
using namespace std;

#include<iostream>
#include<array>
#include<algorithm>
#include"save.h"
using namespace std;

class Dog {
public:
    int operator()(const int a,const int b) {
        if (a > b)
            return 1;
        else
            return 0;

    }
};

//----------
int main()
//----------
{
    array<int, 10> a{ 1,3,5,7,9,2,4,6,8,10 };

    //[문제] 다음 코드가 의도대로 실행될 수 있게 필요한 코딩을 추가하라

    sort(a.begin(), a.end(), Dog{});
    for (int num : a)
        cout << num<< " ";
    cout << endl; //10,9,8,7,6,5,4,3,2,1
    save("메인.cpp");
}

==============================================
저장한 시간 :2025-04-01 오후 2:09:49 화요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 20일 목요일      (3주 2일차 강의) 
// 4월 24일 중간고사 8주차 2일
//-------------------------------------------------------------------------------------------
// Callable type -호출 가능한 타입
// 1.합수
// 2.합수 포인터
// 3. 람다 - 이름 없는함수 - 실체가 있어야 한다. (VS 에서는 class로 코딩해준다)
// 4. 함수 객체(function object) - 함수호출연산자를 오버로딩 한 클래스 객체
//-------------------------------------------------------------------------------------------
// 
//-------------------------------------------------------------------------------------------
#include<iostream>
#include<array>
#include<algorithm>
#include"save.h"
using namespace std;

#include<iostream>
#include<array>
#include<algorithm>
#include"save.h"
using namespace std;



//----------
int main()
//----------
{
    array<int, 10> a{ 1,3,5,7,9,2,4,6,8,10 };
    class Dog {
    public:
        bool operator()( int a,  int b) const {
            return a > b; //a에서 b쪽으로 내려가게
        }
    };
    //[문제] 다음 코드가 의도대로 실행될 수 있게 필요한 코딩을 추가하라

    sort(a.begin(), a.end(), Dog{});
    for (int num : a)
        cout << num<< " ";
    cout << endl; //10,9,8,7,6,5,4,3,2,1
    save("메인.cpp");
}

==============================================
저장한 시간 :2025-04-01 오후 2:13:28 화요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 20일 목요일      (3주 2일차 강의) 
// 4월 24일 중간고사 8주차 2일
//-------------------------------------------------------------------------------------------
// Callable type -호출 가능한 타입
// 1.합수
// 2.합수 포인터
// 3. 람다 - 이름 없는함수 - 실체가 있어야 한다. (VS 에서는 class로 코딩해준다)
// 4. 함수 객체(function object) - 함수호출연산자를 오버로딩 한 클래스 객체
//-------------------------------------------------------------------------------------------
// 
//-------------------------------------------------------------------------------------------
#include<iostream>
#include<array>
#include<algorithm>
#include"save.h"
using namespace std;

#include<iostream>
#include<array>
#include<algorithm>
#include"save.h"
using namespace std;



//----------
int main()
//----------
{
    array<int, 10> a{ 1,3,5,7,9,2,4,6,8,10 };
 

    auto Dog = [](int a, int b)->bool{return a > b;};  //이게 정식형태
    
    //[문제] 다음 코드가 의도대로 실행될 수 있게 필요한 코딩을 추가하라

    sort(a.begin(), a.end(), Dog);
    for (int num : a)
        cout << num<< " ";
    cout << endl; //10 9 8 7 6 5 4 3 2 1
    save("메인.cpp");
}

==============================================
저장한 시간 :2025-04-01 오후 2:27:14 화요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 20일 목요일      (3주 2일차 강의) 
// 4월 24일 중간고사 8주차 2일
//-------------------------------------------------------------------------------------------
// Callable type -호출 가능한 타입
// 1.합수
// 2.합수 포인터
// 3. 람다 - 이름 없는함수 - 실체가 있어야 한다. (VS 에서는 class로 코딩해준다)
// 4. 함수 객체(function object) - 함수호출연산자를 오버로딩 한 클래스 객체
// 5. 맴버함수 - 반드시 객체의 .을 찍어서 호출 하는 것
//-------------------------------------------------------------------------------------------
// 
//-------------------------------------------------------------------------------------------
#include<iostream>
#include<array>
#include<algorithm>
#include"save.h"
using namespace std;

#include<iostream>
#include<array>
#include<algorithm>
#include"save.h"
using namespace std;



//----------
int main()
//----------
{
    auto p =[](int a, int b) {return a > b; }; //이름은 없지만 번지수를 저장하면 부를 수 있다.
    cout << boolalpha << p(3, 4) << endl;
    save("메인.cpp");
}

==============================================
저장한 시간 :2025-04-01 오후 2:39:13 화요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 20일 목요일      (3주 2일차 강의) 
// 4월 24일 중간고사(30) 8주차 2일
// 과제    (30) - 4월 10일 설명
//-------------------------------------------------------------------------------------------
// Callable type 
// 
//-------------------------------------------------------------------------------------------
// 
//-------------------------------------------------------------------------------------------
#include<iostream>
#include<random>
#include<print>
#include<array>
#include"save.h"
using namespace std;

default_random_engine dre;
uniform_int_distribution<int> uidName{ 'a','z' };
uniform_int_distribution uidNameLen{ 3,30 };
uniform_int_distribution uidId{ };

class Dog {
public:
    Dog() {
        int len = uidNameLen(dre);
        for (int i = 0; i < len; ++i)
            name += uidName(dre);
        id = uidId(dre);
    }

    void show()const {
        println("{:12} - {}", id, name);
    }
private:
    string name;
    int id;
};


//----------
int main()
//----------
{
    array<Dog, 10> dogs;
    for (const Dog& dog : dogs)
        dog.show();
    save("메인.cpp");
}

==============================================
저장한 시간 :2025-04-01 오후 2:39:29 화요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 20일 목요일      (3주 2일차 강의) 
// 4월 24일 중간고사(30) 8주차 2일
// 과제    (30) - 4월 10일 설명
//-------------------------------------------------------------------------------------------
// Callable type 
// 
//-------------------------------------------------------------------------------------------
// 
//-------------------------------------------------------------------------------------------
#include<iostream>
#include<random>
#include<print>
#include<array>
#include"save.h"
using namespace std;

default_random_engine dre;
uniform_int_distribution<int> uidName{ 'a','z' };
uniform_int_distribution uidNameLen{ 3,30 };
uniform_int_distribution uidId{ };

class Dog {
public:
    Dog() {
        cout << "설마 생성자가??" << endl;
        int len = uidNameLen(dre);
        for (int i = 0; i < len; ++i)
            name += uidName(dre);
        id = uidId(dre);
    }

    void show()const {
        println("{:12} - {}", id, name);
    }
private:
    string name;
    int id;
};


//----------
int main()
//----------
{
    array<Dog, 10> dogs;
    for (const Dog& dog : dogs)
        dog.show();
    save("메인.cpp");
}

==============================================
저장한 시간 :2025-04-01 오후 2:45:07 화요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 20일 목요일      (3주 2일차 강의) 
// 4월 24일 중간고사(30) 8주차 2일
// 과제    (30) - 4월 10일 설명
//-------------------------------------------------------------------------------------------
// Callable type 
// 
//-------------------------------------------------------------------------------------------
// 
//-------------------------------------------------------------------------------------------
#include<iostream>
#include<random>
#include<print>
#include<array>
#include<fstream>
#include"save.h"
using namespace std;

default_random_engine dre;
uniform_int_distribution<int> uidName{ 'a','z' };
uniform_int_distribution uidNameLen{ 3,30 };
uniform_int_distribution uidId{ };

class Dog {
public:
    Dog() {
        //cout << "설마 생성자가??" << endl;
        int len = uidNameLen(dre);
        for (int i = 0; i < len; ++i)
            name += uidName(dre);
        id = uidId(dre);
    }

    void show()const {
        println("{:12} - {}", id, name);
    }
private:
    string name;
    int id;

    friend ostream& operator<<(ostream& os, const Dog& dog) {
        return os <<dog.id<<" "<<dog.name<< " ";
    }
};
//[문제] Dog 10만마리를 다음과 같이 파일 "Dog 십만마리"에 저장하였다.
// 저장한 방식
// ofstream out( "Dog 십만마리" );
// Dog dog;
// out<<dog;
// ostream& operator<<(ostream& os , const Dog& dog) {
//      return os <<dog.id<<" "<<dog.name<< " ";
// }
// 
//----------
int main()
//----------
{
   ofstream out( "Dog 십만마리" );
   for (int i = 0; i < 10'0000; ++i) {
       Dog dog;
       out << dog;
   }

    save("메인.cpp");
}

==============================================
저장한 시간 :2025-04-01 오후 2:56:05 화요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 20일 목요일      (3주 2일차 강의) 
// 4월 24일 중간고사(30) 8주차 2일
// 과제    (30) - 4월 10일 설명
//-------------------------------------------------------------------------------------------
// Callable type 
// 
//-------------------------------------------------------------------------------------------
// 
//-------------------------------------------------------------------------------------------
#include<iostream>
#include<fstream>
#include<array>
#include"save.h"
using namespace std;



class Dog {
  
private:
    string name;
    int id;

    friend ostream& operator<<(ostream& os, const Dog& dog) {
        return os <<dog.id<<" "<<dog.name<< " ";
    }
    friend istream& operator>>(istream& is, Dog& dog) {
        return is >> dog.id >> dog.name;
    }
};
//[설명] Dog 10만마리를 다음과 같이 파일 "Dog 십만마리"에 저장하였다.
// 파일은 다음 코드로 열었다
//ofstream out("Dog 십만마리");
// 
// Dog 객체는 class Dog의 friend operator<< 를 사용하여 저장하였다.
// 
//[문제] 이 파일에는 정확하게 10만개의 Dog 객체가 저장되어 있다.
// 파일에 저장된 Dog 객체를 모두 읽어 메모리에 저장하라.
// 제일 마지막 객체의 정보를 화면에 출력하고 답지에도 출력 내용을 적어라.
// 메모리에 저장된 Dog 객체를 멤버  name , 길이 기준 오름차순으로 정렬하라.
// 정렬된 Dog 객체를 앞에서부터 100개를 화면에 출력하라.
 
array<Dog, 10'0000> da;
//----------
int main()
//----------
{
    
    ifstream in("Dog 십만마리");
    in.read((char*)da.data(), da.size() * sizeof(Dog));

    cout << "가장 뒤에 있는 Dog :" << da.back() << endl;

    save("메인.cpp");
}

==============================================
저장한 시간 :2025-04-01 오후 2:57:32 화요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 20일 목요일      (3주 2일차 강의) 
// 4월 24일 중간고사(30) 8주차 2일
// 과제    (30) - 4월 10일 설명
//-------------------------------------------------------------------------------------------
// Callable type 
// 
//-------------------------------------------------------------------------------------------
// 
//-------------------------------------------------------------------------------------------
#include<iostream>
#include<fstream>
#include<array>
#include"save.h"
using namespace std;



class Dog {
  
private:
    string name;
    int id;

    friend ostream& operator<<(ostream& os, const Dog& dog) {
        return os <<dog.id<<" "<<dog.name<< " ";
    }
    friend istream& operator>>(istream& is, Dog& dog) {
        return is >> dog.id >> dog.name;
    }
};
//[설명] Dog 10만마리를 다음과 같이 파일 "Dog 십만마리"에 저장하였다.
// 파일은 다음 코드로 열었다
//ofstream out("Dog 십만마리");
// 
// Dog 객체는 class Dog의 friend operator<< 를 사용하여 저장하였다.
// 
//[문제] 이 파일에는 정확하게 10만개의 Dog 객체가 저장되어 있다.
// 파일에 저장된 Dog 객체를 모두 읽어 메모리에 저장하라.
// 제일 마지막 객체의 정보를 화면에 출력하고 답지에도 출력 내용을 적어라.
// 메모리에 저장된 Dog 객체를 멤버  name , 길이 기준 오름차순으로 정렬하라.
// 정렬된 Dog 객체를 앞에서부터 100개를 화면에 출력하라.
 
array<Dog, 10'0000> da;
//----------
int main()
//----------
{
    
    ifstream in("Dog 십만마리");
    for (Dog& dogs : da) {
        in >> dogs;
    }

    cout << "가장 뒤에 있는 Dog :" << da.back() << endl;

    save("메인.cpp");
}

==============================================
저장한 시간 :2025-04-01 오후 3:04:54 화요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 20일 목요일      (3주 2일차 강의) 
// 4월 24일 중간고사(30) 8주차 2일
// 과제    (30) - 4월 10일 설명
//-------------------------------------------------------------------------------------------
// Callable type 
// 
//-------------------------------------------------------------------------------------------
// 
//-------------------------------------------------------------------------------------------
#include<iostream>
#include<fstream>
#include<array>
#include<algorithm>
#include<string>
#include<print>
#include<ranges>
#include"save.h"
using namespace std;



class Dog {
public:
    bool operator()(Dog a, Dog b) const {
        return a.name.length() > b.name.length();
    }
private:
    string name;
    int id;

    friend ostream& operator<<(ostream& os, const Dog& dog) {
        return os <<dog.id<<" "<<dog.name<< " ";
    }
    friend istream& operator>>(istream& is, Dog& dog) {
        return is >> dog.id >> dog.name;
    }
};
//[설명] Dog 10만마리를 다음과 같이 파일 "Dog 십만마리"에 저장하였다.
// 파일은 다음 코드로 열었다
//ofstream out("Dog 십만마리");
// 
// Dog 객체는 class Dog의 friend operator<< 를 사용하여 저장하였다.
// 
//[문제] 이 파일에는 정확하게 10만개의 Dog 객체가 저장되어 있다.
// 파일에 저장된 Dog 객체를 모두 읽어 메모리에 저장하라.
// 제일 마지막 객체의 정보를 화면에 출력하고 답지에도 출력 내용을 적어라.
// 메모리에 저장된 Dog 객체를 멤버  name , 길이 기준 오름차순으로 정렬하라.
// 정렬된 Dog 객체를 앞에서부터 100개를 화면에 출력하라.
 
array<Dog, 10'0000> da;
//----------
int main()
//----------
{
    
    ifstream in("Dog 십만마리");
    for (Dog& dogs : da) {
        in >> dogs;
    }

    cout << "가장 뒤에 있는 Dog :" << da.back() << endl;
    sort(da.begin(), da.end(), Dog{});
    for (Dog& dogs : da |views::take(1000))
        cout << dogs << endl;

    save("메인.cpp");
}

==============================================
저장한 시간 :2025-04-01 오후 3:05:21 화요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 20일 목요일      (3주 2일차 강의) 
// 4월 24일 중간고사(30) 8주차 2일
// 과제    (30) - 4월 10일 설명
//-------------------------------------------------------------------------------------------
// Callable type 
// 
//-------------------------------------------------------------------------------------------
// 
//-------------------------------------------------------------------------------------------
#include<iostream>
#include<fstream>
#include<array>
#include<algorithm>
#include<string>
#include<print>
#include<ranges>
#include"save.h"
using namespace std;



class Dog {
public:
    bool operator()(Dog a, Dog b) const {
        return a.name.length() > b.name.length();
    }
private:
    string name;
    int id;

    friend ostream& operator<<(ostream& os, const Dog& dog) {
        return os <<dog.id<<" "<<dog.name<< " ";
    }
    friend istream& operator>>(istream& is, Dog& dog) {
        return is >> dog.id >> dog.name;
    }
};
//[설명] Dog 10만마리를 다음과 같이 파일 "Dog 십만마리"에 저장하였다.
// 파일은 다음 코드로 열었다
//ofstream out("Dog 십만마리");
// 
// Dog 객체는 class Dog의 friend operator<< 를 사용하여 저장하였다.
// 
//[문제] 이 파일에는 정확하게 10만개의 Dog 객체가 저장되어 있다.
// 파일에 저장된 Dog 객체를 모두 읽어 메모리에 저장하라.
// 제일 마지막 객체의 정보를 화면에 출력하고 답지에도 출력 내용을 적어라.
// 메모리에 저장된 Dog 객체를 멤버  name , 길이 기준 오름차순으로 정렬하라.
// 정렬된 Dog 객체를 앞에서부터 100개를 화면에 출력하라.
 
array<Dog, 10'0000> da;
//----------
int main()
//----------
{
    
    ifstream in("Dog 십만마리");
    for (Dog& dogs : da) {
        in >> dogs;
    }

    cout << "가장 뒤에 있는 Dog :" << da.back() << endl;
    sort(da.begin(), da.end(), Dog{});
    for (Dog& dogs : da |views::take(100))
        cout << dogs << endl;

    save("메인.cpp");
}

==============================================
저장한 시간 :2025-04-01 오후 3:05:36 화요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 20일 목요일      (3주 2일차 강의) 
// 4월 24일 중간고사(30) 8주차 2일
// 과제    (30) - 4월 10일 설명
//-------------------------------------------------------------------------------------------
// Callable type 
// 
//-------------------------------------------------------------------------------------------
// 
//-------------------------------------------------------------------------------------------
#include<iostream>
#include<fstream>
#include<array>
#include<algorithm>
#include<string>
#include<print>
#include<ranges>
#include"save.h"
using namespace std;



class Dog {
public:
    bool operator()(Dog a, Dog b) const {
        return a.name.length() < b.name.length();
    }
private:
    string name;
    int id;

    friend ostream& operator<<(ostream& os, const Dog& dog) {
        return os <<dog.id<<" "<<dog.name<< " ";
    }
    friend istream& operator>>(istream& is, Dog& dog) {
        return is >> dog.id >> dog.name;
    }
};
//[설명] Dog 10만마리를 다음과 같이 파일 "Dog 십만마리"에 저장하였다.
// 파일은 다음 코드로 열었다
//ofstream out("Dog 십만마리");
// 
// Dog 객체는 class Dog의 friend operator<< 를 사용하여 저장하였다.
// 
//[문제] 이 파일에는 정확하게 10만개의 Dog 객체가 저장되어 있다.
// 파일에 저장된 Dog 객체를 모두 읽어 메모리에 저장하라.
// 제일 마지막 객체의 정보를 화면에 출력하고 답지에도 출력 내용을 적어라.
// 메모리에 저장된 Dog 객체를 멤버  name , 길이 기준 오름차순으로 정렬하라.
// 정렬된 Dog 객체를 앞에서부터 100개를 화면에 출력하라.
 
array<Dog, 10'0000> da;
//----------
int main()
//----------
{
    
    ifstream in("Dog 십만마리");
    for (Dog& dogs : da) {
        in >> dogs;
    }

    cout << "가장 뒤에 있는 Dog :" << da.back() << endl;
    sort(da.begin(), da.end(), Dog{});
    for (Dog& dogs : da |views::take(100))
        cout << dogs << endl;

    save("메인.cpp");
}

==============================================
저장한 시간 :2025-04-01 오후 3:06:34 화요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 20일 목요일      (3주 2일차 강의) 
// 4월 24일 중간고사(30) 8주차 2일
// 과제    (30) - 4월 10일 설명
//-------------------------------------------------------------------------------------------
// Callable type 
// 
//-------------------------------------------------------------------------------------------
// 
//-------------------------------------------------------------------------------------------
#include<iostream>
#include<fstream>
#include<array>
#include<algorithm>
#include<string>
#include<print>
#include<ranges>
#include"save.h"
using namespace std;



class Dog {
public:
    bool operator()(Dog a, Dog b) const {
        if (a.name.length() == b.name.length()) {
            return a.id < b.id;
        }
        else
            return a.name.length() < b.name.length();
    }
private:
    string name;
    int id;

    friend ostream& operator<<(ostream& os, const Dog& dog) {
        return os <<dog.id<<" "<<dog.name<< " ";
    }
    friend istream& operator>>(istream& is, Dog& dog) {
        return is >> dog.id >> dog.name;
    }
};
//[설명] Dog 10만마리를 다음과 같이 파일 "Dog 십만마리"에 저장하였다.
// 파일은 다음 코드로 열었다
//ofstream out("Dog 십만마리");
// 
// Dog 객체는 class Dog의 friend operator<< 를 사용하여 저장하였다.
// 
//[문제] 이 파일에는 정확하게 10만개의 Dog 객체가 저장되어 있다.
// 파일에 저장된 Dog 객체를 모두 읽어 메모리에 저장하라.
// 제일 마지막 객체의 정보를 화면에 출력하고 답지에도 출력 내용을 적어라.
// 메모리에 저장된 Dog 객체를 멤버  name , 길이 기준 오름차순으로 정렬하라.
// 정렬된 Dog 객체를 앞에서부터 100개를 화면에 출력하라.
 
array<Dog, 10'0000> da;
//----------
int main()
//----------
{
    
    ifstream in("Dog 십만마리");
    for (Dog& dogs : da) {
        in >> dogs;
    }

    cout << "가장 뒤에 있는 Dog :" << da.back() << endl;
    sort(da.begin(), da.end(), Dog{});
    for (Dog& dogs : da |views::take(100))
        cout << dogs << endl;

    save("메인.cpp");
}

==============================================
저장한 시간 :2025-04-01 오후 3:09:13 화요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 20일 목요일      (3주 2일차 강의) 
// 4월 24일 중간고사(30) 8주차 2일
// 과제    (30) - 4월 10일 설명
//-------------------------------------------------------------------------------------------
// Callable type 
// 
//-------------------------------------------------------------------------------------------
// 
//-------------------------------------------------------------------------------------------
#include<iostream>
#include<fstream>
#include<array>
#include<algorithm>
#include<string>
#include<print>
#include<ranges>
#include"save.h"
using namespace std;



class Dog {
public:
    bool operator()(Dog a, Dog b) const {
        if (a.name.length() == b.name.length()) {
            return a.id < b.id;
        }
        else
            return a.name.length() < b.name.length();
    }
private:
    string name;
    int id;
    friend ostream& operator<<(ostream& os, const Dog& dog) {
        return os <<dog.id<<" "<<dog.name<< " ";
    }
    friend istream& operator>>(istream& is, Dog& dog) {
        return is >> dog.id >> dog.name;
    }
};
//[설명] Dog 10만마리를 다음과 같이 파일 "Dog 십만마리"에 저장하였다.
// 파일은 다음 코드로 열었다
//ofstream out("Dog 십만마리");
// 
// Dog 객체는 class Dog의 friend operator<< 를 사용하여 저장하였다.
// 
//[문제] 이 파일에는 정확하게 10만개의 Dog 객체가 저장되어 있다.
// 파일에 저장된 Dog 객체를 모두 읽어 메모리에 저장하라.
// 제일 마지막 객체의 정보를 화면에 출력하고 답지에도 출력 내용을 적어라.
// 메모리에 저장된 Dog 객체를 멤버  name , 길이 기준 오름차순으로 정렬하라.
// 정렬된 Dog 객체를 앞에서부터 100개를 화면에 출력하라.
 
array<Dog, 10'0000> da;
//----------
int main()
//----------
{
    
    ifstream in("Dog 십만마리");
    for (Dog& dogs : da) {
        in >> dogs;
    }

    cout << "가장 뒤에 있는 Dog :" << da.back() << endl;

    sort(da.begin(), da.end(), Dog{});
    for (Dog& dogs : da |views::take(100))
        cout << dogs << endl;

    save("메인.cpp");
}

==============================================
저장한 시간 :2025-04-01 오후 6:40:19 화요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 20일 목요일      (3주 2일차 강의) 
// 4월 24일 중간고사(30) 8주차 2일
// 과제    (30) - 4월 10일 설명
//-------------------------------------------------------------------------------------------
// Callable type 
// 
//-------------------------------------------------------------------------------------------
// 
//-------------------------------------------------------------------------------------------
#include<iostream>
#include<fstream>
#include<array>
#include<algorithm>
#include<string>
#include<print>
#include<ranges>
#include"save.h"
using namespace std;



class Dog {
public:
    bool operator()(Dog a, Dog b) const {
        if (a.name.length() == b.name.length()) {
            return a.id < b.id;
        }
        else
            return a.name.length() < b.name.length();
    }
private:
    string name;
    int id;
    friend ostream& operator<<(ostream& os, const Dog& dog) {
        return os <<dog.id<<" "<<dog.name<< " ";
    }
    friend istream& operator>>(istream& is, Dog& dog) {
        return is >> dog.id >> dog.name;
    }
};
//[설명] Dog 10만마리를 다음과 같이 파일 "Dog 십만마리"에 저장하였다.
// 파일은 다음 코드로 열었다
//ofstream out("Dog 십만마리");
// 
// Dog 객체는 class Dog의 friend operator<< 를 사용하여 저장하였다.
// 
//[문제] 이 파일에는 정확하게 10만개의 Dog 객체가 저장되어 있다.
// 파일에 저장된 Dog 객체를 모두 읽어 메모리에 저장하라.
// 제일 마지막 객체의 정보를 화면에 출력하고 답지에도 출력 내용을 적어라.
// 메모리에 저장된 Dog 객체를 멤버  name , 길이 기준 오름차순으로 정렬하라.
// 정렬된 Dog 객체를 앞에서부터 100개를 화면에 출력하라.
 
array<Dog, 10'0000> da;
//----------
int main()
//----------
{
    
    ifstream in("Dog 십만마리");

    for (Dog& dogs : da) {
        in >> dogs;
    }

    cout << "가장 뒤에 있는 Dog :" << da.back() << endl;

    sort(da.begin(), da.end(), Dog{});
    for (Dog& dogs : da |views::take(100))
        cout << dogs << endl;

    save("메인.cpp");
}

==============================================
저장한 시간 :2025-04-03 오전 10:56:39 목요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 20일 목요일      (3주 2일차 강의) 
// 4월 24일 중간고사(30) 8주차 2일
// 과제    (30) - 4월 10일 설명
//-------------------------------------------------------------------------------------------
// Callable type 
// 
//-------------------------------------------------------------------------------------------
// 
//-------------------------------------------------------------------------------------------
#include<iostream>
#include<fstream>
#include<array>
#include<algorithm>
#include<string>
#include<print>
#include<ranges>
#include"save.h"
using namespace std;



class Dog {
public:
    bool operator()(Dog a, Dog b) const {
        if (a.name.length() == b.name.length()) {
            return a.id < b.id;
        }
        else
            return a.name.length() < b.name.length();
    }
private:
    string name;
    int id;
    friend ostream& operator<<(ostream& os, const Dog& dog) {
        return os <<dog.id<<" "<<dog.name<< " ";
    }
    friend istream& operator>>(istream& is, Dog& dog) {
        return is >> dog.id >> dog.name;
    }
};
//[설명] Dog 10만마리를 다음과 같이 파일 "Dog 십만마리"에 저장하였다.
// 파일은 다음 코드로 열었다
//ofstream out("Dog 십만마리");
// 
// Dog 객체는 class Dog의 friend operator<< 를 사용하여 저장하였다.
// 
//[문제] 이 파일에는 정확하게 10만개의 Dog 객체가 저장되어 있다.
// 파일에 저장된 Dog 객체를 모두 읽어 메모리에 저장하라.
// 제일 마지막 객체의 정보를 화면에 출력하고 답지에도 출력 내용을 적어라.
// 메모리에 저장된 Dog 객체를 멤버  name , 길이 기준 오름차순으로 정렬하라.
// 정렬된 Dog 객체를 앞에서부터 100개를 화면에 출력하라.
 
array<Dog, 10'0000> da;
//----------
int main()
//----------
{
    
    ifstream in("Dog 십만마리");

    for (Dog& dogs : da) {
        in >> dogs;
    }

    cout << "가장 뒤에 있는 Dog :" << da.back() << endl;

    sort(da.begin(), da.end(), Dog{});
    for (Dog& dogs : da |views::take(100))
        cout << dogs << endl;

    save("메인.cpp");
}

==============================================
저장한 시간 :2025-04-03 오후 3:32:49 목요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 20일 목요일      (5주 2일차 강의) 
// 4월 24일 중간고사(30) 8주차 2일
// 과제    (30) - 4월 10일 설명
//-------------------------------------------------------------------------------------------
// Callable type 
// 
//-------------------------------------------------------------------------------------------
// 
//-------------------------------------------------------------------------------------------
#include<iostream>
#include<fstream>
#include<array>
#include<algorithm>
#include<string>
#include<print>
#include<ranges>
#include"save.h"
using namespace std;



class Dog {
public:
    bool operator()(Dog a, Dog b) const {
        if (a.name.length() == b.name.length()) {
            return a.id < b.id;
        }
        else
            return a.name.length() < b.name.length();
    }
private:
    string name;
    int id;
    friend ostream& operator<<(ostream& os, const Dog& dog) {
        return os <<dog.id<<" "<<dog.name<< " ";
    }
    friend istream& operator>>(istream& is, Dog& dog) {
        return is >> dog.id >> dog.name;
    }
};
//[설명] Dog 10만마리를 다음과 같이 파일 "Dog 십만마리"에 저장하였다.
// 파일은 다음 코드로 열었다
//ofstream out("Dog 십만마리");
// 
// Dog 객체는 class Dog의 friend operator<< 를 사용하여 저장하였다.
// 
//[문제] 파일 "Dog 십만마리" 에는 정확하게 10만개의 Dog 객체가 저장되어 있다.
// 파일에 저장된 Dog 객체를 모두 읽어 메모리에 저장하라.
// 제일 마지막 객체의 정보를 화면에 출력하고 답지에도 출력 내용을 적어라.
// 메모리에 저장된 Dog 객체를 멤버  name , 길이 기준 오름차순으로 정렬하라.
// 정렬된 Dog 객체를 앞에서부터 100개를 화면에 출력하라.
 
array<Dog, 10'0000> da;
//----------
int main()
//----------
{
    
    ifstream in("Dog 십만마리");
    if (not in)
        return 1234;

    for (Dog& dogs : da) {
        in >> dogs;
    }

    cout << "가장 뒤에 있는 Dog :" << da.back() << endl;

    sort(da.begin(), da.end(), Dog{});
    for (Dog& dogs : da |views::take(100))
        cout << dogs << endl;

    save("메인.cpp");
}

==============================================
저장한 시간 :2025-04-03 오후 3:39:12 목요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 20일 목요일      (5주 2일차 강의) 
// 4월 24일 중간고사(30) 8주차 2일
// 과제    (30) - 4월 10일 설명
//-------------------------------------------------------------------------------------------
// Callable type 
// 
//-------------------------------------------------------------------------------------------
// 
//-------------------------------------------------------------------------------------------
#include<iostream>
#include<fstream>
#include<array>
#include<algorithm>
#include<string>
#include<print>
#include<ranges>
#include"save.h"
using namespace std;



class Dog {
public:
    bool operator()(Dog a, Dog b) const {
        if (a.name.length() == b.name.length()) {
            return a.id < b.id;
        }
        else
            return a.name.length() < b.name.length();
    }
private:
    string name;
    int id;
    friend ostream& operator<<(ostream& os, const Dog& dog) {
        return os <<dog.id<<" "<<dog.name<< " ";
    }
    friend istream& operator>>(istream& is, Dog& dog) {
        return is >> dog.id >> dog.name;
    }
};
//[설명] Dog 10만마리를 다음과 같이 파일 "Dog 십만마리"에 저장하였다.
// 파일은 다음 코드로 열었다
//ofstream out("Dog 십만마리");
// 
// Dog 객체는 class Dog의 friend operator<< 를 사용하여 저장하였다.
// 
//[문제] 파일 "Dog 십만마리" 에는 정확하게 10만개의 Dog 객체가 저장되어 있다.
// 파일에 저장된 Dog 객체를 모두 읽어 메모리에 저장하라.
// 제일 마지막 객체의 정보를 화면에 출력하고 답지에도 출력 내용을 적어라.
// 메모리에 저장된 Dog 객체를 멤버  name , 길이 기준 오름차순으로 정렬하라.
// 정렬된 Dog 객체를 앞에서부터 100개를 화면에 출력하라.
 
array<Dog, 10'0000> da;
//----------
int main()
//----------
{
    
    ifstream in("Dog 십만마리"); //똑같이 text 모드로 열어야 한다.
    if (not in)
        return 1234;
    string name;
    int num{};
    int cnt{};
    while (in >> num >> name) {
        println("[{:7}] - {:12}{}", cnt, num, name);
        ++cnt;
    }

    save("메인.cpp");
}

==============================================
저장한 시간 :2025-04-03 오후 3:39:34 목요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 20일 목요일      (5주 2일차 강의) 
// 4월 24일 중간고사(30) 8주차 2일
// 과제    (30) - 4월 10일 설명
//-------------------------------------------------------------------------------------------
// Callable type 
// 
//-------------------------------------------------------------------------------------------
// 
//-------------------------------------------------------------------------------------------
#include<iostream>
#include<fstream>
#include<array>
#include<algorithm>
#include<string>
#include<print>
#include<ranges>
#include"save.h"
using namespace std;



class Dog {
public:
    bool operator()(Dog a, Dog b) const {
        if (a.name.length() == b.name.length()) {
            return a.id < b.id;
        }
        else
            return a.name.length() < b.name.length();
    }
private:
    string name;
    int id;
    friend ostream& operator<<(ostream& os, const Dog& dog) {
        return os <<dog.id<<" "<<dog.name<< " ";
    }
    friend istream& operator>>(istream& is, Dog& dog) {
        return is >> dog.id >> dog.name;
    }
};
//[설명] Dog 10만마리를 다음과 같이 파일 "Dog 십만마리"에 저장하였다.
// 파일은 다음 코드로 열었다
//ofstream out("Dog 십만마리");
// 
// Dog 객체는 class Dog의 friend operator<< 를 사용하여 저장하였다.
// 
//[문제] 파일 "Dog 십만마리" 에는 정확하게 10만개의 Dog 객체가 저장되어 있다.
// 파일에 저장된 Dog 객체를 모두 읽어 메모리에 저장하라.
// 제일 마지막 객체의 정보를 화면에 출력하고 답지에도 출력 내용을 적어라.
// 메모리에 저장된 Dog 객체를 멤버  name , 길이 기준 오름차순으로 정렬하라.
// 정렬된 Dog 객체를 앞에서부터 100개를 화면에 출력하라.
 
array<Dog, 10'0000> da;
//----------
int main()
//----------
{
    
    ifstream in("Dog 십만마리"); //똑같이 text 모드로 열어야 한다.
    if (not in)
        return 1234;
    string name;
    int num{};
    int cnt{};
    while (in >> num >> name) {
        println("[{:7}] - {:12} {}", ++cnt, num, name);

    }

    save("메인.cpp");
}

==============================================
저장한 시간 :2025-04-03 오후 3:43:16 목요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 20일 목요일      (5주 2일차 강의) 
// 4월 24일 중간고사(30) 8주차 2일
// 과제    (30) - 4월 10일 설명
//-------------------------------------------------------------------------------------------
// Callable type 
// 
//-------------------------------------------------------------------------------------------
// 
//-------------------------------------------------------------------------------------------
#include<iostream>
#include<fstream>
#include<array>
#include<algorithm>
#include<string>
#include<print>
#include<ranges>
#include"save.h"
using namespace std;



class Dog {
public:
    bool operator()(Dog a, Dog b) const {
        if (a.name.length() == b.name.length()) {
            return a.id < b.id;
        }
        else
            return a.name.length() < b.name.length();
    }
private:
    string name;
    int id;
    friend ostream& operator<<(ostream& os, const Dog& dog) {
        return os <<dog.id<<" "<<dog.name<< " ";
    }
    friend istream& operator>>(istream& is, Dog& dog) {
        return is >> dog.id >> dog.name;
    }
};
//[설명] Dog 10만마리를 다음과 같이 파일 "Dog 십만마리"에 저장하였다.
// 파일은 다음 코드로 열었다
//ofstream out("Dog 십만마리");
// 
// Dog 객체는 class Dog의 friend operator<< 를 사용하여 저장하였다.
// 
//[문제] 파일 "Dog 십만마리" 에는 정확하게 10만개의 Dog 객체가 저장되어 있다.
// 파일에 저장된 Dog 객체를 모두 읽어 메모리에 저장하라.
// 제일 마지막 객체의 정보를 화면에 출력하고 답지에도 출력 내용을 적어라.
// 메모리에 저장된 Dog 객체를 멤버  name , 길이 기준 오름차순으로 정렬하라.
// 정렬된 Dog 객체를 앞에서부터 100개를 화면에 출력하라.
 
array<Dog, 10'0000> dogs;
//----------
int main()
//----------
{
    
    ifstream in("Dog 십만마리"); //똑같이 text 모드로 열어야 한다.
    if (not in)
        return 1234;
    for (int i = 0; i < 10'0000; ++i) {
        in >> dogs[i];
    }
    cout << "마지막 개" << dogs.back() << endl;
    //마지막 [ 100000] -   1970393199 etpyzzulctbtq
    save("메인.cpp");
}

==============================================
저장한 시간 :2025-04-03 오후 3:48:03 목요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 20일 목요일      (5주 2일차 강의) 
// 4월 24일 중간고사(30) 8주차 2일
// 과제    (30) - 4월 10일 설명
//-------------------------------------------------------------------------------------------
// Callable type 
// 
//-------------------------------------------------------------------------------------------
// 
//-------------------------------------------------------------------------------------------
#include<iostream>
#include<fstream>
#include<array>
#include<algorithm>
#include<string>
#include<print>
#include<ranges>
#include"save.h"
using namespace std;



class Dog {
public:
    void show() const {
        println("[{:12}] - {}", id, name);
    }
private:
    string name;
    int id;
    friend ostream& operator<<(ostream& os, const Dog& dog) {
        return os <<dog.id<<" "<<dog.name<< " ";
    }
    friend istream& operator>>(istream& is, Dog& dog) {
        return is >> dog.id >> dog.name;
    }
};
//[설명] Dog 10만마리를 다음과 같이 파일 "Dog 십만마리"에 저장하였다.
// 파일은 다음 코드로 열었다
//ofstream out("Dog 십만마리");
// 
// Dog 객체는 class Dog의 friend operator<< 를 사용하여 저장하였다.
// 
//[문제] 파일 "Dog 십만마리" 에는 정확하게 10만개의 Dog 객체가 저장되어 있다.
// 파일에 저장된 Dog 객체를 모두 읽어 메모리에 저장하라.
// 제일 마지막 객체의 정보를 화면에 출력하고 답지에도 출력 내용을 적어라.
// 메모리에 저장된 Dog 객체를 멤버  name , 길이 기준 오름차순으로 정렬하라.
// 정렬된 Dog 객체를 앞에서부터 100개를 화면에 출력하라.
 
array<Dog, 10'0000> dogs;
//----------
int main()
//----------
{
    
    ifstream in("Dog 십만마리"); //똑같이 text 모드로 열어야 한다.
    if (not in)
        return 1234;
    for (int i = 0; i < 10'0000; ++i) {
        in >> dogs[i];
    }
    cout << "제일 마지막 객체의 정보 : "<< endl;
    dogs.back().show();
    //마지막 [ 100000] -   1970393199 etpyzzulctbtq
    save("메인.cpp");
}

==============================================
저장한 시간 :2025-04-03 오후 3:56:04 목요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 20일 목요일      (5주 2일차 강의) 
// 4월 24일 중간고사(30) 8주차 2일
// 과제    (30) - 4월 10일 설명
//-------------------------------------------------------------------------------------------
// Callable type 
// 
//-------------------------------------------------------------------------------------------
// 
//-------------------------------------------------------------------------------------------
#include<iostream>
#include<fstream>
#include<array>
#include<algorithm>
#include<string>
#include<print>
#include<ranges>
#include"save.h"
using namespace std;



class Dog {
public:
    void show() const {
        println("[{:12}] - {}", id, name);
    }

    size_t getNameLen( )const {
        return name.length();
    }
private:
    string name;
    int id;
    friend ostream& operator<<(ostream& os, const Dog& dog) {
        return os <<dog.id<<" "<<dog.name<< " ";
    }
    friend istream& operator>>(istream& is, Dog& dog) {
        return is >> dog.id >> dog.name;
    }
};
//[설명] Dog 10만마리를 다음과 같이 파일 "Dog 십만마리"에 저장하였다.
// 파일은 다음 코드로 열었다
//ofstream out("Dog 십만마리");
// 
// Dog 객체는 class Dog의 friend operator<< 를 사용하여 저장하였다.
// 
//[문제] 파일 "Dog 십만마리" 에는 정확하게 10만개의 Dog 객체가 저장되어 있다.
// 파일에 저장된 Dog 객체를 모두 읽어 메모리에 저장하라.
// 제일 마지막 객체의 정보를 화면에 출력하고 답지에도 출력 내용을 적어라.
// 메모리에 저장된 Dog 객체를 멤버  name , 길이 기준 오름차순으로 정렬하라.
// 정렬된 Dog 객체를 앞에서부터 100개를 화면에 출력하라.
 
array<Dog, 10'0000> dogs;
//----------
int main()
//----------
{
    
    ifstream in("Dog 십만마리"); //똑같이 text 모드로 열어야 한다.
    if (not in)
        return 1234;
    for (int i = 0; i < 10'0000; ++i) {
        in >> dogs[i];
    }
    cout << "제일 마지막 객체의 정보 : "<< endl;
    dogs.back().show();

    cout << "Dog name 길이기준 오름차순( ascending order) 으로 정렬합니다" << endl;
    sort(dogs.begin(), dogs.end(), [](const Dog dog1 ,const Dog dog2) {
        return dog1.getNameLen()< dog2.getNameLen();
        }); 
    
    for (const Dog& dog : dogs)
        dog.show();
    save("메인.cpp");
}

==============================================
저장한 시간 :2025-04-03 오후 3:58:10 목요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 20일 목요일      (5주 2일차 강의) 
// 4월 24일 중간고사(30) 8주차 2일
// 과제    (30) - 4월 10일 설명
//-------------------------------------------------------------------------------------------
// Callable type 
// 
//-------------------------------------------------------------------------------------------
// 
//-------------------------------------------------------------------------------------------
#include<iostream>
#include<fstream>
#include<array>
#include<algorithm>
#include<string>
#include<print>
#include<ranges>
#include"save.h"
using namespace std;



class Dog {
public:
    void show() const {
        println("[{:12}] - {}", id, name);
    }

    size_t getNameLen( )const {
        return name.length();
    }
private:
    string name;
    int id;
    friend ostream& operator<<(ostream& os, const Dog& dog) {
        return os <<dog.id<<" "<<dog.name<< " ";
    }
    friend istream& operator>>(istream& is, Dog& dog) {
        return is >> dog.id >> dog.name;
    }
};
//[설명] Dog 10만마리를 다음과 같이 파일 "Dog 십만마리"에 저장하였다.
// 파일은 다음 코드로 열었다
//ofstream out("Dog 십만마리");
// 
// Dog 객체는 class Dog의 friend operator<< 를 사용하여 저장하였다.
// 
//[문제] 파일 "Dog 십만마리" 에는 정확하게 10만개의 Dog 객체가 저장되어 있다.
// 파일에 저장된 Dog 객체를 모두 읽어 메모리에 저장하라.
// 제일 마지막 객체의 정보를 화면에 출력하고 답지에도 출력 내용을 적어라.
// 메모리에 저장된 Dog 객체를 멤버  name , 길이 기준 오름차순으로 정렬하라.
// 정렬된 Dog 객체를 앞에서부터 100개를 화면에 출력하라.
 
array<Dog, 10'0000> dogs;
//----------
int main()
//----------
{
    
    ifstream in("Dog 십만마리"); //똑같이 text 모드로 열어야 한다.
    if (not in)
        return 1234;
    for (int i = 0; i < 10'0000; ++i) {
        in >> dogs[i];
    }
    cout << "제일 마지막 객체의 정보 : "<< endl;
    dogs.back().show();

    cout << "Dog name 길이기준 오름차순( ascending order) 으로 정렬합니다" << endl;
    sort(dogs.begin(), dogs.end(), [](const Dog dog1 ,const Dog dog2) {
        return dog1.getNameLen()< dog2.getNameLen();
        }); 
    
    for (const Dog& dog : dogs |views::take(1000))
        dog.show();
    save("메인.cpp");
}

==============================================
저장한 시간 :2025-04-03 오후 3:59:15 목요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 20일 목요일      (5주 2일차 강의) 
// 4월 24일 중간고사(30) 8주차 2일
// 과제    (30) - 4월 10일 설명
//-------------------------------------------------------------------------------------------
// Callable type 
// 
//-------------------------------------------------------------------------------------------
// 
//-------------------------------------------------------------------------------------------
#include<iostream>
#include<fstream>
#include<array>
#include<algorithm>
#include<string>
#include<print>
#include<ranges>
#include"save.h"
using namespace std;



class Dog {
public:
    void show() const {
        println("[{:12}] - {}", id, name);
    }

    size_t getNameLen( )const {
        return name.length();
    }
private:
    string name;
    int id;
    friend ostream& operator<<(ostream& os, const Dog& dog) {
        return os <<dog.id<<" "<<dog.name<< " ";
    }
    friend istream& operator>>(istream& is, Dog& dog) {
        return is >> dog.id >> dog.name;
    }
};
//[설명] Dog 10만마리를 다음과 같이 파일 "Dog 십만마리"에 저장하였다.
// 파일은 다음 코드로 열었다
//ofstream out("Dog 십만마리");
// 
// Dog 객체는 class Dog의 friend operator<< 를 사용하여 저장하였다.
// 
//[문제] 파일 "Dog 십만마리" 에는 정확하게 10만개의 Dog 객체가 저장되어 있다.
// 파일에 저장된 Dog 객체를 모두 읽어 메모리에 저장하라.
// 제일 마지막 객체의 정보를 화면에 출력하고 답지에도 출력 내용을 적어라.
// 메모리에 저장된 Dog 객체를 멤버  name , 길이 기준 오름차순으로 정렬하라.
// 정렬된 Dog 객체를 앞에서부터 100개를 화면에 출력하라.
 
array<Dog, 10'0000> dogs;
//----------
int main()
//----------
{
    
    ifstream in("Dog 십만마리"); //똑같이 text 모드로 열어야 한다.
    if (not in)
        return 1234;
    for (int i = 0; i < 10'0000; ++i) {
        in >> dogs[i];
    }
    cout << "제일 마지막 객체의 정보 : "<< endl;
    dogs.back().show();

    cout << "Dog name 길이기준 오름차순( ascending order) 으로 정렬합니다" << endl;
    sort(dogs.begin(), dogs.end(), [](const Dog dog1 ,const Dog dog2) {
        return dog1.getNameLen()< dog2.getNameLen();
        }); 
    
    for (const Dog& dog : dogs | views::reverse)
        dog.show();
    save("메인.cpp");
}

==============================================
저장한 시간 :2025-04-03 오후 4:06:02 목요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 20일 목요일      (5주 2일차 강의) 
// 4월 24일 중간고사(30) 8주차 2일
// 과제    (30) - 4월 10일 설명
//-------------------------------------------------------------------------------------------
// Callable type 
// 
//-------------------------------------------------------------------------------------------
// 
//-------------------------------------------------------------------------------------------
#include<iostream>
#include<fstream>
#include<array>
#include<algorithm>
#include<string>
#include<print>
#include<ranges>
#include"save.h"
using namespace std;



class Dog {
public:
    void show() const {
        println("[{:12}] - {}", id, name);
    }

    size_t getNameLen( )const {
        return name.length();
    }

    bool operator<(const Dog& other) const {
        return name.size() < other.name.size();
    }
private:
    string name;
    int id;
    friend ostream& operator<<(ostream& os, const Dog& dog) {
        return os <<dog.id<<" "<<dog.name<< " ";
    }
    friend istream& operator>>(istream& is, Dog& dog) {
        return is >> dog.id >> dog.name;
    }
};
//[설명] Dog 10만마리를 다음과 같이 파일 "Dog 십만마리"에 저장하였다.
// 파일은 다음 코드로 열었다
//ofstream out("Dog 십만마리");
// 
// Dog 객체는 class Dog의 friend operator<< 를 사용하여 저장하였다.
// 
//[문제] 파일 "Dog 십만마리" 에는 정확하게 10만개의 Dog 객체가 저장되어 있다.
// 파일에 저장된 Dog 객체를 모두 읽어 메모리에 저장하라.
// 제일 마지막 객체의 정보를 화면에 출력하고 답지에도 출력 내용을 적어라.
// 메모리에 저장된 Dog 객체를 멤버  name , 길이 기준 오름차순으로 정렬하라.
// 정렬된 Dog 객체를 앞에서부터 100개를 화면에 출력하라.
 
array<Dog, 10'0000> dogs;
//----------
int main()
//----------
{
    
    ifstream in("Dog 십만마리"); //똑같이 text 모드로 열어야 한다.
    if (not in)
        return 1234;
    for (int i = 0; i < 10'0000; ++i) {
        in >> dogs[i];
    }
    cout << "제일 마지막 객체의 정보 : "<< endl;
    dogs.back().show();

    cout << "Dog name 길이기준 오름차순( ascending order) 으로 정렬합니다" << endl;

    sort(dogs.begin(), dogs.end());
    
    for (const Dog& dog : dogs | views::reverse)
        dog.show();
    save("메인.cpp");
}

==============================================
저장한 시간 :2025-04-03 오후 4:37:57 목요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 20일 목요일      (5주 2일차 강의) 
// 4월 24일 중간고사(30) 8주차 2일
// 과제    (30) - 4월 10일 설명
//-------------------------------------------------------------------------------------------
// STRING - std::stromg과 유사한 클래스, STL 표준 container가 되도록 발전시켜나갈것임
//-------------------------------------------------------------------------------------------
#include<iostream>
#include<string>
#include"save.h"
using namespace std;
class STRING {

};
 
//----------
int main()
//------------------------------------------------------------
{
    string s{ "std::string과 유사한 클래스" };
    cout << s.size() << endl; //s가 확보한 자원의 바이트 수
    cout << s << endl;
    save("메인.cpp");
}

==============================================
저장한 시간 :2025-04-03 오후 5:10:45 목요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 20일 목요일      (5주 2일차 강의) 
// 4월 24일 중간고사(30) 8주차 2일
// 과제    (30) - 4월 10일 설명
//-------------------------------------------------------------------------------------------
// STRING - std::stromg과 유사한 클래스, STL 표준 container가 되도록 발전시켜나갈것임
//-------------------------------------------------------------------------------------------
#include<iostream>
#include<string>
#include<memory>
#include"save.h"
using namespace std;
class STRING {
public:
    STRING(const char* s) : len{ strlen(s) } {   //[] -> *로 collapsing 된다.
        p.reset();
        p= make_unique<char[]>(len); //p에 주소를 저장하도록
        memcpy(p.get(), s, len);  //p에다가 s의 내용을 len만큼 DMA 다이렉트 메모리 어섹스  이거보다 빠른 메모리끼리의 전송은 없다.
    }


    size_t size( )const {
        return len;
    }


private:
    size_t len{}; //null char를 쓰지 않겠다는 소리
    unique_ptr<char[]> p{};



    friend ostream& operator<<(ostream& os, const STRING& str) {
        for (int i = 0; i < str.len; ++i) {
            os << str.p[i];
        }
        return os;
    }
};

//----------
int main()
//------------------------------------------------------------
{
    STRING s{ "std::string과 유사한 클래스" };
    cout << s.size() << endl; //s가 확보한 자원의 바이트 수
    cout << s << endl;
    save("메인.cpp");
}

==============================================
저장한 시간 :2025-04-08 오후 1:37:59 화요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 20일 목요일      (6주 1일차 강의) 
// 4월 24일 중간고사(30) 8주차 2일
// 과제    (30) - 4월 10일 설명
//-------------------------------------------------------------------------------------------
// STRING - std::stromg과 유사한 클래스, STL 표준 container가 되도록 발전시켜나갈것임
//-------------------------------------------------------------------------------------------
#include<iostream>
#include<string>
#include<memory>
#include"save.h"
#include"STRING.h"
using namespace std;


//----------
int main()
//------------------------------------------------------------
{
    STRING s{ "std::string과 유사한 클래스" };
    cout << s.size() << endl; //s가 확보한 자원의 바이트 수
    cout << s << endl;
    save("메인.cpp");
}

==============================================
저장한 시간 :2025-04-08 오후 1:53:50 화요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 20일 목요일      (6주 1일차 강의) 
// 4월 24일 중간고사(30) 8주차 2일
// 과제    (30) - 4월 10일 설명
//-------------------------------------------------------------------------------------------
// STRING - std::stromg과 유사한 클래스, STL 표준 container가 되도록 발전시켜나갈것임
//-------------------------------------------------------------------------------------------
#include<iostream>
#include<string>
#include<memory>
#include"save.h"
#include"STRING.h"
using namespace std;


//----------
int main()
//------------------------------------------------------------
{
    STRING s{ "std::string과 유사한 클래스" };
    cout << s.size() << endl; //s가 확보한 자원의 바이트 수
    cout << s << endl;

    STRING t;
    t = s;

    STRING u = s;

    cout << t << endl;
    cout << s << endl;
    save("메인.cpp");
}

==============================================
저장한 시간 :2025-04-08 오후 2:13:54 화요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 20일 목요일      (6주 1일차 강의) 
// 4월 24일 중간고사(30) 8주차 2일
// 과제    (30) - 4월 10일 설명
//-------------------------------------------------------------------------------------------
// STRING - std::stromg과 유사한 클래스, STL 표준 container가 되도록 발전시켜나갈것임
//-------------------------------------------------------------------------------------------
#include<iostream>
#include<string>
#include<memory>
#include"save.h"
#include"STRING.h"
using namespace std;


//----------
int main()
//------------------------------------------------------------
{
    STRING s{ "std::string과 유사한 클래스" };
    cout << s.size() << endl; //s가 확보한 자원의 바이트 수
    cout << s << endl;

    STRING t;
    t = s;

    STRING u = s;

    cout << t << endl;
    cout << s << endl;
    save("메인.cpp");
}

==============================================
저장한 시간 :2025-04-08 오후 2:14:41 화요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 20일 목요일      (6주 1일차 강의) 
// 4월 24일 중간고사(30) 8주차 2일
// 과제    (30) - 4월 10일 설명
//-------------------------------------------------------------------------------------------
// STRING - std::stromg과 유사한 클래스, STL 표준 container가 되도록 발전시켜나갈것임
//-------------------------------------------------------------------------------------------
#include<iostream>
#include<string>
#include<memory>
#include"save.h"
#include"STRING.h"
using namespace std;


//----------
int main()
//------------------------------------------------------------
{
    STRING s{ "std::string과 유사한 클래스" };
    cout << s.size() << endl; //s가 확보한 자원의 바이트 수
    cout << s << endl;

    STRING t;
    t = s;

    STRING u = s;

    cout << t << endl;
    cout << u << endl;
    save("메인.cpp");
}

==============================================
저장한 시간 :2025-04-08 오후 2:37:14 화요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 20일 목요일      (6주 1일차 강의) 
// 4월 24일 중간고사(30) 8주차 2일
// 과제    (30) - 4월 10일 설명
//-------------------------------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 container가 되도록 발전시켜나갈것임
//          내부 동작을 관찰할 수 있게 하자.
//-------------------------------------------------------------------------------------------
#include<iostream>
#include<string>
#include<memory>
#include"save.h"
#include"STRING.h"
using namespace std;


//----------
int main()
//------------------------------------------------------------
{
    STRING s{ "std::string과 유사한 클래스" };
    cout << s.size() << endl; //s가 확보한 자원의 바이트 수
    cout << s << endl;

    STRING t;
    t = s;

    STRING u = s;

    cout << t << endl;
    cout << u << endl;
    save("메인.cpp");
}

==============================================
저장한 시간 :2025-04-08 오후 2:50:49 화요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 20일 목요일      (6주 1일차 강의) 
// 4월 24일 중간고사(30) 8주차 2일
// 과제    (30) - 4월 10일 설명
//-------------------------------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 container가 되도록 발전시켜나갈것임
//          내부 동작을 관찰할 수 있게 하자.
//-------------------------------------------------------------------------------------------
#include<iostream>
#include<string>
#include<memory>
#include"save.h"
#include"STRING.h"
using namespace std;

extern bool 관찰; // 관찰하려면 true로
//----------
int main()
//------------------------------------------------------------
{


    STRING t;

    cout << t << endl;
    save("메인.cpp");
}

==============================================
저장한 시간 :2025-04-08 오후 2:51:34 화요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 20일 목요일      (6주 1일차 강의) 
// 4월 24일 중간고사(30) 8주차 2일
// 과제    (30) - 4월 10일 설명
//-------------------------------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 container가 되도록 발전시켜나갈것임
//          내부 동작을 관찰할 수 있게 하자.
//-------------------------------------------------------------------------------------------
#include<iostream>
#include<string>
#include<memory>
#include"save.h"
#include"STRING.h"
using namespace std;

STRING s{ "이제 준비가 끝났다" };

extern bool 관찰; // 관찰하려면 true로
//----------
int main()
//------------------------------------------------------------
{


    STRING t;
    t = s;

    cout << t << endl;
    save("메인.cpp");
}

==============================================
저장한 시간 :2025-04-08 오후 2:52:21 화요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 20일 목요일      (6주 1일차 강의) 
// 4월 24일 중간고사(30) 8주차 2일
// 과제    (30) - 4월 10일 설명
//-------------------------------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 container가 되도록 발전시켜나갈것임
//          내부 동작을 관찰할 수 있게 하자.
//-------------------------------------------------------------------------------------------
#include<iostream>
#include<string>
#include<memory>
#include"save.h"
#include"STRING.h"
using namespace std;

STRING s{ "이제 준비가 끝났다" };

extern bool 관찰; // 관찰하려면 true로
//----------
int main()
//------------------------------------------------------------
{


    STRING t;
    t = s;

    cout << t << endl;
    save("메인.cpp");
}

==============================================
저장한 시간 :2025-04-08 오후 2:53:11 화요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 20일 목요일      (6주 1일차 강의) 
// 4월 24일 중간고사(30) 8주차 2일
// 과제    (30) - 4월 10일 설명
//-------------------------------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 container가 되도록 발전시켜나갈것임
//          내부 동작을 관찰할 수 있게 하자.
//-------------------------------------------------------------------------------------------
#include<iostream>
#include<string>
#include<memory>
#include"save.h"
#include"STRING.h"
using namespace std;

STRING s{ "이제 준비가 끝났다" };

extern bool 관찰; // 관찰하려면 true로
//----------
int main()
//------------------------------------------------------------
{


    STRING t;
    t = s;

    cout << t << endl;
    save("메인.cpp");
}

==============================================
저장한 시간 :2025-04-08 오후 2:53:36 화요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 20일 목요일      (6주 1일차 강의) 
// 4월 24일 중간고사(30) 8주차 2일
// 과제    (30) - 4월 10일 설명
//-------------------------------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 container가 되도록 발전시켜나갈것임
//          내부 동작을 관찰할 수 있게 하자.
//-------------------------------------------------------------------------------------------
#include<iostream>
#include<string>
#include<memory>
#include"save.h"
#include"STRING.h"
using namespace std;

STRING s{ "이제 준비가 끝났다" };

extern bool 관찰; // 관찰하려면 true로
//----------
int main()
//------------------------------------------------------------
{
    cout << "메인시작" << endl;

    STRING t = s;


    cout << t << endl;
    save("메인.cpp");
}

==============================================
저장한 시간 :2025-04-08 오후 2:54:21 화요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 20일 목요일      (6주 1일차 강의) 
// 4월 24일 중간고사(30) 8주차 2일
// 과제    (30) - 4월 10일 설명
//-------------------------------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 container가 되도록 발전시켜나갈것임
//          내부 동작을 관찰할 수 있게 하자.
//-------------------------------------------------------------------------------------------
#include<iostream>
#include<string>
#include<memory>
#include"save.h"
#include"STRING.h"
using namespace std;

STRING s{ "이제 준비가 끝났다" };

extern bool 관찰; // 관찰하려면 true로
//----------
int main()
//------------------------------------------------------------
{
    cout << "메인시작" << endl;

    STRING t = s;


    cout << t << endl;
    save("메인.cpp");
}

==============================================
저장한 시간 :2025-04-08 오후 2:56:01 화요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 20일 목요일      (6주 1일차 강의) 
// 4월 24일 중간고사(30) 8주차 2일
// 과제    (30) - 4월 10일 설명
//-------------------------------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 container가 되도록 발전시켜나갈것임
//          내부 동작을 관찰할 수 있게 하자.
//-------------------------------------------------------------------------------------------
#include<iostream>
#include<string>
#include<memory>
#include"save.h"
#include"STRING.h"
using namespace std;

STRING s{ "이제 준비가 끝났다" };

extern bool 관찰; // 관찰하려면 true로
//----------
int main()
//------------------------------------------------------------
{
    cout << "메인시작" << endl;

    STRING t = s;


    cout << t << endl;
    save("메인.cpp");
}

==============================================
저장한 시간 :2025-04-08 오후 2:57:19 화요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 20일 목요일      (6주 1일차 강의) 
// 4월 24일 중간고사(30) 8주차 2일
// 과제    (30) - 4월 10일 설명
//-------------------------------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 container가 되도록 발전시켜나갈것임
//          내부 동작을 관찰할 수 있게 하자.
//-------------------------------------------------------------------------------------------
#include<iostream>
#include<string>
#include<memory>
#include"save.h"
#include"STRING.h"
using namespace std;

STRING s{ "이제 준비가 끝났다" };

extern bool 관찰; // 관찰하려면 true로

//----------
int main()
//------------------------------------------------------------
{
    관찰 = false;
    cout << "메인시작" << endl;

    STRING t = s;


    cout << t << endl;
    save("메인.cpp");
}

==============================================
저장한 시간 :2025-04-08 오후 3:02:42 화요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 20일 목요일      (6주 1일차 강의) 
// 4월 24일 중간고사(30) 8주차 2일
// 과제    (30) - 4월 10일 설명
//-------------------------------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 container가 되도록 발전시켜나갈것임
//          내부 동작을 관찰할 수 있게 하자.
//-------------------------------------------------------------------------------------------
#include<iostream>
#include<array>
#include<string>
#include<memory>
#include<algorithm>
#include"save.h"
#include"STRING.h"
using namespace std;



extern bool 관찰; // 관찰하려면 true로

//----------
int main()
//------------------------------------------------------------
{
    array<STRING, 5> a{ "1","333","22","5555","4444" };
    
    // 길이기준 오름차순 정렬하고 출력하라
    // 정렬 수행 (operator() 활용)
    std::sort(a.begin(), a.end(), STRING());
    
    for (auto& S : a) {
        cout << S << endl;
    }
    save("메인.cpp");
}

==============================================
저장한 시간 :2025-04-08 오후 3:05:10 화요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 20일 목요일      (6주 1일차 강의) 
// 4월 24일 중간고사(30) 8주차 2일
// 과제    (30) - 4월 10일 설명
//-------------------------------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 container가 되도록 발전시켜나갈것임
//          내부 동작을 관찰할 수 있게 하자.
//-------------------------------------------------------------------------------------------
#include<iostream>
#include<array>
#include<string>
#include<memory>
#include<algorithm>
#include"save.h"
#include"STRING.h"
using namespace std;



extern bool 관찰; // 관찰하려면 true로

//----------
int main()
//------------------------------------------------------------
{
    array<STRING, 5> a{ "1","333","22","5555","4444" };
    
    // 길이기준 오름차순 정렬하고 출력하라
    // 정렬 수행 (operator() 활용)
    std::sort(a.begin(), a.end(), [](const STRING& a, STRING& b)
        {
            return a.size() < b.size();
        });
    
    for (const STRING& S : a) {
        cout << S << endl;
    }
    save("메인.cpp");
}

==============================================
저장한 시간 :2025-04-08 오후 3:05:40 화요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 20일 목요일      (6주 1일차 강의) 
// 4월 24일 중간고사(30) 8주차 2일
// 과제    (30) - 4월 10일 설명
//-------------------------------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 container가 되도록 발전시켜나갈것임
//          내부 동작을 관찰할 수 있게 하자.
//-------------------------------------------------------------------------------------------
#include<iostream>
#include<array>
#include<string>
#include<memory>
#include<algorithm>
#include"save.h"
#include"STRING.h"
using namespace std;



extern bool 관찰; // 관찰하려면 true로

//----------
int main()
//------------------------------------------------------------
{
    관찰 = false;
    array<STRING, 5> a{ "1","333","22","5555","4444" };
    
    // 길이기준 오름차순 정렬하고 출력하라
    // 정렬 수행 (operator() 활용)
    std::sort(a.begin(), a.end(), [](const STRING& a, STRING& b)
        {
            return a.size() < b.size();
        });
    
    for (const STRING& S : a) {
        cout << S << endl;
    }
    save("메인.cpp");
}

==============================================
저장한 시간 :2025-04-08 오후 3:05:49 화요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 20일 목요일      (6주 1일차 강의) 
// 4월 24일 중간고사(30) 8주차 2일
// 과제    (30) - 4월 10일 설명
//-------------------------------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 container가 되도록 발전시켜나갈것임
//          내부 동작을 관찰할 수 있게 하자.
//-------------------------------------------------------------------------------------------
#include<iostream>
#include<array>
#include<string>
#include<memory>
#include<algorithm>
#include"save.h"
#include"STRING.h"
using namespace std;



extern bool 관찰; // 관찰하려면 true로

//----------
int main()
//------------------------------------------------------------
{
    관찰 = false;
    array<STRING, 5> a{ "1","333","22","55555","4444" };
    
    // 길이기준 오름차순 정렬하고 출력하라
    // 정렬 수행 (operator() 활용)
    std::sort(a.begin(), a.end(), [](const STRING& a, STRING& b)
        {
            return a.size() < b.size();
        });
    
    for (const STRING& S : a) {
        cout << S << endl;
    }
    save("메인.cpp");
}

==============================================
저장한 시간 :2025-04-08 오후 3:06:29 화요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 20일 목요일      (6주 1일차 강의) 
// 4월 24일 중간고사(30) 8주차 2일
// 과제    (30) - 4월 10일 설명
//-------------------------------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 container가 되도록 발전시켜나갈것임
//          내부 동작을 관찰할 수 있게 하자.
//-------------------------------------------------------------------------------------------
#include<iostream>
#include<array>
#include<string>
#include<memory>
#include<algorithm>
#include"save.h"
#include"STRING.h"
using namespace std;



extern bool 관찰; // 관찰하려면 true로

//----------
int main()
//------------------------------------------------------------
{
    관찰 = false;
    array<STRING, 5> a{ "1","333","22","55555","4444" };
    
    // 길이기준 오름차순 정렬하고 출력하라
    // 정렬 수행 (operator() 활용)
    std::sort(a.begin(), a.end(), [](const STRING& a, STRING& b)
        {
            return a.size() < b.size();
        });
    관찰 = true;
    for (const STRING& S : a) {
        cout << S << endl;
    }
    관찰 = false;
    save("메인.cpp");
}

==============================================
저장한 시간 :2025-04-08 오후 3:07:25 화요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 20일 목요일      (6주 1일차 강의) 
// 4월 24일 중간고사(30) 8주차 2일
// 과제    (30) - 4월 10일 설명
//-------------------------------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 container가 되도록 발전시켜나갈것임
//          내부 동작을 관찰할 수 있게 하자.
//-------------------------------------------------------------------------------------------
#include<iostream>
#include<array>
#include<string>
#include<memory>
#include<algorithm>
#include"save.h"
#include"STRING.h"
using namespace std;



extern bool 관찰; // 관찰하려면 true로

//----------
int main()
//------------------------------------------------------------
{
    관찰 = false;
    array<STRING, 5> a{ "1","333","22","55555","4444" };
    
    // 길이기준 오름차순 정렬하고 출력하라
    // 정렬 수행 (operator() 활용)
    std::sort(a.begin(), a.end(), [](const STRING& a, STRING& b)
        {
            return a.size() < b.size();
        });
    관찰 = true;
    for (const auto& S : a) {
        cout << S << endl;
    }
    관찰 = false;
    save("메인.cpp");
}

==============================================
저장한 시간 :2025-04-08 오후 3:07:54 화요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 20일 목요일      (6주 1일차 강의) 
// 4월 24일 중간고사(30) 8주차 2일
// 과제    (30) - 4월 10일 설명
//-------------------------------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 container가 되도록 발전시켜나갈것임
//          내부 동작을 관찰할 수 있게 하자.
//-------------------------------------------------------------------------------------------
#include<iostream>
#include<array>
#include<string>
#include<memory>
#include<algorithm>
#include"save.h"
#include"STRING.h"
using namespace std;



extern bool 관찰; // 관찰하려면 true로

//----------
int main()
//------------------------------------------------------------
{
    관찰 = false;
    array<STRING, 5> a{ "1","333","22","55555","4444" };
    
    // 길이기준 오름차순 정렬하고 출력하라
    // 정렬 수행 (operator() 활용)
    std::sort(a.begin(), a.end(), [](const STRING& a, STRING& b)
        {
            return a.size() < b.size();
        });
    관찰 = true;
    for (const STRING& S : a) {
        cout << S << endl;
    }
    관찰 = false;
    save("메인.cpp");
}

==============================================
저장한 시간 :2025-04-08 오후 3:08:07 화요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 20일 목요일      (6주 1일차 강의) 
// 4월 24일 중간고사(30) 8주차 2일
// 과제    (30) - 4월 10일 설명
//-------------------------------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 container가 되도록 발전시켜나갈것임
//          내부 동작을 관찰할 수 있게 하자.
//-------------------------------------------------------------------------------------------
#include<iostream>
#include<array>
#include<string>
#include<memory>
#include<algorithm>
#include"save.h"
#include"STRING.h"
using namespace std;



extern bool 관찰; // 관찰하려면 true로

//----------
int main()
//------------------------------------------------------------
{
    관찰 = false;
    array<STRING, 5> a{ "1","333","22","55555","4444" };
    
    // 길이기준 오름차순 정렬하고 출력하라
    // 정렬 수행 (operator() 활용)
    관찰 = true;
    std::sort(a.begin(), a.end(), [](const STRING& a, STRING& b)
        {
            return a.size() < b.size();
        });
    관찰 = false;
    for (const STRING& S : a) {
        cout << S << endl;
    }
    
    save("메인.cpp");
}

==============================================
저장한 시간 :2025-04-08 오후 3:12:01 화요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 20일 목요일      (6주 1일차 강의) 
// 4월 24일 중간고사(30) 8주차 2일
// 과제    (30) - 4월 10일 설명
//-------------------------------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 container가 되도록 발전시켜나갈것임
//          내부 동작을 관찰할 수 있게 하자.
//-------------------------------------------------------------------------------------------
#include<iostream>
#include<array>
#include<string>
#include<memory>
#include<algorithm>
#include"save.h"
#include"STRING.h"
using namespace std;



extern bool 관찰; // 관찰하려면 true로

//----------
int main()
//------------------------------------------------------------
{
    //다음시간 STRING도 이렇게 동작하게 하자
    string s{ "표준 string" };
    string t = move(s);

    cout << s << endl;
    cout << t << endl;
    
    save("메인.cpp");
}

==============================================
저장한 시간 :2025-04-08 오후 3:25:18 화요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 20일 목요일      (6주 1일차 강의) 
// 4월 24일 중간고사(30) 8주차 2일
// 과제    (30) - 4월 10일 설명
//-------------------------------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 container가 되도록 발전시켜나갈것임
//          내부 동작을 관찰할 수 있게 하자.
//-------------------------------------------------------------------------------------------
#include<iostream>
#include<array>
#include<string>
#include<memory>
#include<algorithm>
#include"save.h"
#include"STRING.h"
using namespace std;



extern bool 관찰; // 관찰하려면 true로

//----------
int main()
//------------------------------------------------------------
{
    //다음시간 STRING도 이렇게 동작하게 하자
    string s{ "표준 string" };
    string t = move(s);

    cout << s << endl;
    cout << t << endl;
    
    save("메인.cpp");
}

==============================================
저장한 시간 :2025-04-08 오후 3:25:43 화요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 20일 목요일      (6주 1일차 강의) 
// 4월 24일 중간고사(30) 8주차 2일
// 과제    (30) - 4월 10일 설명
//-------------------------------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 container가 되도록 발전시켜나갈것임
//          내부 동작을 관찰할 수 있게 하자.
//-------------------------------------------------------------------------------------------
#include<iostream>
#include<array>
#include<string>
#include<memory>
#include<algorithm>
#include"save.h"
#include"STRING.h"
using namespace std;



extern bool 관찰; // 관찰하려면 true로

//----------
int main()
//------------------------------------------------------------
{
    관찰 = true;
    STRING S;
    //다음시간 STRING도 이렇게 동작하게 하자
    string s{ "표준 string" };
    string t = move(s);

    cout << s << endl;
    cout << t << endl;
    
    save("메인.cpp");
}

==============================================
저장한 시간 :2025-04-08 오후 3:26:23 화요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 20일 목요일      (6주 1일차 강의) 
// 4월 24일 중간고사(30) 8주차 2일
// 과제    (30) - 4월 10일 설명
//-------------------------------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 container가 되도록 발전시켜나갈것임
//          내부 동작을 관찰할 수 있게 하자.
//-------------------------------------------------------------------------------------------
#include<iostream>
#include<array>
#include<string>
#include<memory>
#include<algorithm>
#include"save.h"
#include"STRING.h"
using namespace std;



extern bool 관찰; // 관찰하려면 true로

//----------
int main()
//------------------------------------------------------------
{
    관찰 = true;
    STRING S;
    //다음시간 STRING도 이렇게 동작하게 하자
    string s{ "표준 string" };
    string t = move(s);

    cout << s << endl;
    cout << t << endl;
    
    save("메인.cpp");
}

==============================================
저장한 시간 :2025-04-08 오후 3:26:40 화요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 20일 목요일      (6주 1일차 강의) 
// 4월 24일 중간고사(30) 8주차 2일
// 과제    (30) - 4월 10일 설명
//-------------------------------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 container가 되도록 발전시켜나갈것임
//          내부 동작을 관찰할 수 있게 하자.
//-------------------------------------------------------------------------------------------
#include<iostream>
#include<array>
#include<string>
#include<memory>
#include<algorithm>
#include"save.h"
#include"STRING.h"
using namespace std;



extern bool 관찰; // 관찰하려면 true로

//----------
int main()
//------------------------------------------------------------
{
    관찰 = true;
    STRING S;
    S = "안녕";
    //다음시간 STRING도 이렇게 동작하게 하자
    string s{ "표준 string" };
    string t = move(s);

    cout << s << endl;
    cout << t << endl;
    
    save("메인.cpp");
}

==============================================
저장한 시간 :2025-04-08 오후 4:26:39 화요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 20일 목요일      (6주 1일차 강의) 
// 4월 24일 중간고사(30) 8주차 2일
// 과제    (30) - 4월 10일 설명
//-------------------------------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 container가 되도록 발전시켜나갈것임
//          내부 동작을 관찰할 수 있게 하자.
//-------------------------------------------------------------------------------------------
#include<iostream>
#include<array>
#include<string>
#include<memory>
#include<algorithm>
#include"save.h"
#include"STRING.h"
using namespace std;



extern bool 관찰; // 관찰하려면 true로

//----------
int main()
//------------------------------------------------------------
{
    관찰 = true;
    STRING S;
    S = "안녕";
    

    save("메인.cpp");
}

==============================================
저장한 시간 :2025-04-10 오후 3:47:35 목요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 20일 목요일      (6주 2일차 강의) 
// 4월 24일 중간고사(30) 8주차 2일
// 과제    (30) - 4월 10일 설명
//-------------------------------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 container가 되도록 발전시켜나갈것임
//          내부 동작을 관찰할 수 있게 하자.
//-------------------------------------------------------------------------------------------
#include<iostream>
#include<array>
#include<string>
#include<memory>
#include<algorithm>
#include"save.h"
#include"STRING.h"
using namespace std;



extern bool 관찰; // 관찰하려면 true로

//----------
int main()
//------------------------------------------------------------
{
    관찰 = true;
    STRING S;
    S = "안녕";
    

    save("메인.cpp");
}

==============================================
저장한 시간 :2025-04-10 오후 3:50:54 목요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 20일 목요일      (6주 2일차 강의) 
// 4월 24일 중간고사(30) 8주차 2일
// 5월 6일(화) -> 6월 19(예정)
//-------------------------------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 container가 되도록 발전시켜나갈것임
//          내부 동작을 관찰할 수 있게 하자.
//-------------------------------------------------------------------------------------------
#include<iostream>
#include<array>
#include<string>
#include<memory>
#include<algorithm>
#include"save.h"
#include"STRING.h"
using namespace std;



extern bool 관찰; // 관찰하려면 true로

//----------
int main()
//------------------------------------------------------------
{
    string s{ "표준 string" };
    string t = move(s);

    cout<<"s:" << s << endl;
    cout <<"t:" << t << endl;
    

    save("메인.cpp");
}

==============================================
저장한 시간 :2025-04-10 오후 3:51:29 목요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 20일 목요일      (6주 2일차 강의) 
// 4월 24일 중간고사(30) 8주차 2일
// 5월 6일(화) -> 6월 19(예정)
//-------------------------------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 container가 되도록 발전시켜나갈것임
//          내부 동작을 관찰할 수 있게 하자.
//-------------------------------------------------------------------------------------------
#include<iostream>
#include<array>
#include<string>
#include<memory>
#include<algorithm>
#include"save.h"
#include"STRING.h"
using namespace std;



extern bool 관찰; // 관찰하려면 true로

//----------
int main()
//------------------------------------------------------------
{
    string s{ "표준 string" };
    string t = move(s);
    string f;
    cout<<"s:" << f << endl;
    cout <<"t:" << t << endl;
    

    save("메인.cpp");
}

==============================================
저장한 시간 :2025-04-10 오후 3:51:40 목요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 20일 목요일      (6주 2일차 강의) 
// 4월 24일 중간고사(30) 8주차 2일
// 5월 6일(화) -> 6월 19(예정)
//-------------------------------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 container가 되도록 발전시켜나갈것임
//          내부 동작을 관찰할 수 있게 하자.
//-------------------------------------------------------------------------------------------
#include<iostream>
#include<array>
#include<string>
#include<memory>
#include<algorithm>
#include"save.h"
#include"STRING.h"
using namespace std;



extern bool 관찰; // 관찰하려면 true로

//----------
int main()
//------------------------------------------------------------
{
    string s{ "표준 string" };
    string t = move(s);

    cout<<"s:" << s << endl;
    cout <<"t:" << t << endl;
    

    save("메인.cpp");
}

==============================================
저장한 시간 :2025-04-10 오후 3:52:35 목요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 20일 목요일      (6주 2일차 강의) 
// 4월 24일 중간고사(30) 8주차 2일
// 5월 6일(화) -> 6월 19(예정)
//-------------------------------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 container가 되도록 발전시켜나갈것임
//          내부 동작을 관찰할 수 있게 하자.
//-------------------------------------------------------------------------------------------
#include<iostream>
#include<array>
#include<string>
#include<memory>
#include<algorithm>
#include"save.h"
#include"STRING.h"
using namespace std;



extern bool 관찰; // 관찰하려면 true로

//----------
int main()
//------------------------------------------------------------
{
    STRING s{ "표준 string" };
    STRING t = move(s);

    cout<<"s:" << s << endl;
    cout <<"t:" << t << endl;
    

    save("메인.cpp");
}

==============================================
저장한 시간 :2025-04-10 오후 3:53:04 목요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 20일 목요일      (6주 2일차 강의) 
// 4월 24일 중간고사(30) 8주차 2일
// 5월 6일(화) -> 6월 19(예정)
//-------------------------------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 container가 되도록 발전시켜나갈것임
//          내부 동작을 관찰할 수 있게 하자.
//-------------------------------------------------------------------------------------------
#include<iostream>
#include<array>
#include<string>
#include<memory>
#include<algorithm>
#include"save.h"
#include"STRING.h"
using namespace std;



extern bool 관찰; // 관찰하려면 true로

//----------
int main()
//------------------------------------------------------------
{
    관찰 = true;
    STRING s{ "표준 string" };
    STRING t = move(s);

    cout<<"s:" << s << endl;
    cout <<"t:" << t << endl;
    

    save("메인.cpp");
}

==============================================
저장한 시간 :2025-04-10 오후 4:24:10 목요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 20일 목요일      (6주 2일차 강의) 
// 4월 24일 중간고사(30) 8주차 2일
// 5월 6일(화) -> 6월 19(예정)
//-------------------------------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 container가 되도록 발전시켜나갈것임
//          내부 동작을 관찰할 수 있게 하자.
//-------------------------------------------------------------------------------------------
#include<iostream>
#include<array>
#include<string>
#include<memory>
#include<algorithm>
#include"save.h"
#include"STRING.h"
using namespace std;



extern bool 관찰; // 관찰하려면 true로

//----------
int main()
//------------------------------------------------------------
{
    관찰 = true;
    STRING s{ "표준 string" };
    STRING t = move(s);

    //cout<<"s:" << s << endl; //이동하지않기로 한 객체를 사용함
    cout <<"t:" << t << endl;
    

    save("메인.cpp");
}

==============================================
저장한 시간 :2025-04-10 오후 4:40:43 목요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 20일 목요일      (6주 2일차 강의) 
// 4월 24일 중간고사(30) 8주차 2일
// 5월 6일(화) -> 6월 19(예정)
//-------------------------------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 container가 되도록 발전시켜나갈것임
//          내부 동작을 관찰할 수 있게 하자.
//-------------------------------------------------------------------------------------------
#include<iostream>
#include<array>
#include<string>
#include<memory>
#include<algorithm>
#include"save.h"
#include"STRING.h"
using namespace std;



extern bool 관찰; // 관찰하려면 true로

//----------
int main()
//------------------------------------------------------------
{
    관찰 = true;
    STRING s{ "표준 string" };
    STRING t = move(s);

    //cout<<"s:" << s << endl; //이동하지않기로 한 객체를 사용함
    cout <<"t:" << t << endl;
    

    save("메인.cpp");
}

==============================================
저장한 시간 :2025-04-10 오후 4:40:56 목요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 20일 목요일      (6주 2일차 강의) 
// 4월 24일 중간고사(30) 8주차 2일
// 5월 6일(화) -> 6월 19(예정)
//-------------------------------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 container가 되도록 발전시켜나갈것임
//          내부 동작을 관찰할 수 있게 하자.
//-------------------------------------------------------------------------------------------
#include<iostream>
#include<array>
#include<string>
#include<memory>
#include<algorithm>
#include"save.h"
#include"STRING.h"
using namespace std;



extern bool 관찰; // 관찰하려면 true로

//----------
int main()
//------------------------------------------------------------
{
    관찰 = true;
    STRING s{ "표준 string" };
    STRING t = move(s);

    cout<<"s:" << s << endl; //이동하지않기로 한 객체를 사용함
    cout <<"t:" << t << endl;
    

    save("메인.cpp");
}

==============================================
저장한 시간 :2025-04-10 오후 4:44:05 목요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 20일 목요일      (6주 2일차 강의) 
// 4월 24일 중간고사(30) 8주차 2일
// 5월 6일(화) -> 6월 19(예정)
//-------------------------------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 container가 되도록 발전시켜나갈것임
//          내부 동작을 관찰할 수 있게 하자.
//-------------------------------------------------------------------------------------------
#include<iostream>
#include<array>
#include<string>
#include<memory>
#include<algorithm>
#include"save.h"
#include"STRING.h"
using namespace std;



extern bool 관찰; // 관찰하려면 true로

//----------
int main()
//------------------------------------------------------------
{
    array<STRING, 5> a{ "1","333","22","55555","4444" };
   
    
    관찰 = true;
    for (auto str : a)
        cout << str << endl;
    관찰 = false;
    save("메인.cpp");
}

==============================================
저장한 시간 :2025-04-10 오후 4:44:49 목요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 20일 목요일      (6주 2일차 강의) 
// 4월 24일 중간고사(30) 8주차 2일
// 5월 6일(화) -> 6월 19(예정)
//-------------------------------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 container가 되도록 발전시켜나갈것임
//          내부 동작을 관찰할 수 있게 하자.
//-------------------------------------------------------------------------------------------
#include<iostream>
#include<array>
#include<string>
#include<memory>
#include<algorithm>
#include"save.h"
#include"STRING.h"
using namespace std;



extern bool 관찰; // 관찰하려면 true로

//----------
int main()
//------------------------------------------------------------
{
    array<STRING, 5> a{ "1","333","22","55555","4444" };
   
    
    관찰 = true;
    for (auto str : a)
        cout << str << endl;
    관찰 = false;
    save("메인.cpp");
}

==============================================
저장한 시간 :2025-04-10 오후 4:45:21 목요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 20일 목요일      (6주 2일차 강의) 
// 4월 24일 중간고사(30) 8주차 2일
// 5월 6일(화) -> 6월 19(예정)
//-------------------------------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 container가 되도록 발전시켜나갈것임
//          내부 동작을 관찰할 수 있게 하자.
//-------------------------------------------------------------------------------------------
#include<iostream>
#include<array>
#include<string>
#include<memory>
#include<algorithm>
#include"save.h"
#include"STRING.h"
using namespace std;



extern bool 관찰; // 관찰하려면 true로

//----------
int main()
//------------------------------------------------------------
{
    array<STRING, 5> a{ "1","333","22","55555","4444" };
   
    
    관찰 = true;
    for (const STRING &str : a)
        cout << str << endl;
    관찰 = false;
    save("메인.cpp");
}

==============================================
저장한 시간 :2025-04-10 오후 4:45:30 목요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 20일 목요일      (6주 2일차 강의) 
// 4월 24일 중간고사(30) 8주차 2일
// 5월 6일(화) -> 6월 19(예정)
//-------------------------------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 container가 되도록 발전시켜나갈것임
//          내부 동작을 관찰할 수 있게 하자.
//-------------------------------------------------------------------------------------------
#include<iostream>
#include<array>
#include<string>
#include<memory>
#include<algorithm>
#include"save.h"
#include"STRING.h"
using namespace std;



extern bool 관찰; // 관찰하려면 true로

//----------
int main()
//------------------------------------------------------------
{
    array<STRING, 5> a{ "1","333","22","55555","4444" };
   
    
    관찰 = true;
    for (const STRING& str : a)
        cout << str << endl;
    관찰 = false;
    save("메인.cpp");
}

==============================================
저장한 시간 :2025-04-10 오후 5:01:32 목요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 20일 목요일      (6주 2일차 강의) 
// 4월 24일 중간고사(30) 8주차 2일
// 5월 6일(화) -> 6월 19(예정)
//-------------------------------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 container가 되도록 발전시켜나갈것임
//          내부 동작을 관찰할 수 있게 하자.
//-------------------------------------------------------------------------------------------
#include<iostream>
#include<array>
#include<string>
#include<memory>
#include<algorithm>
#include"save.h"
#include"STRING.h"
using namespace std;



extern bool 관찰; // 관찰하려면 true로

//----------
int main()
//------------------------------------------------------------
{
    array<STRING, 5> a{ "1","333","22","55555","4444" };
    관찰 = true;
    std::sort(a.begin(), a.end(), [](const STRING& lhs, STRING& rhs)  //가오 좀 부리자
        {
            return lhs.size() < rhs.size();
        });

    
    for (const STRING& str : a)
        cout << str << endl;
    관찰 = false;
    save("메인.cpp");
}

==============================================
저장한 시간 :2025-04-15 오후 1:29:54 화요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 20일 목요일      (6주 2일차 강의) 
// 4월 24일 중간고사(30) 8주차 2일
// 5월 6일(화) -> 6월 19(예정)
//-------------------------------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 container가 되도록 발전시켜나갈것임
//          내부 동작을 관찰할 수 있게 하자.
//-------------------------------------------------------------------------------------------
#include<iostream>
#include<array>
#include<string>
#include<memory>
#include<algorithm>
#include"save.h"
#include"STRING.h"
using namespace std;



extern bool 관찰; // 관찰하려면 true로

//----------
int main()
//------------------------------------------------------------
{
    array<STRING, 5> a{ "1","333","22","55555","4444" };
    관찰 = true;
    std::sort(a.begin(), a.end(), [](const STRING& lhs, STRING& rhs)  //가오 좀 부리자
        {
            return lhs.size() < rhs.size();
        });

    
    for (const STRING& str : a)
        cout << str << endl;
    관찰 = false;
    save("메인.cpp");
}

==============================================
저장한 시간 :2025-04-15 오후 1:45:22 화요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 20일 목요일      (7주 1일차 강의) 
// 4월 24일 중간고사(30) 8주차 2일
// 5월 6일(화) -> 6월 19(예정)
//-------------------------------------------------------------------------------------------
// STRING - std::string과 유사한 클래스, STL 표준 container가 되도록 발전시켜나갈것임
//          내부 동작을 관찰할 수 있게 하자.
//-------------------------------------------------------------------------------------------
#include<iostream>
#include<array>
#include<string>
#include<memory>
#include<algorithm>
#include<ranges>
#include"save.h"
#include"STRING.h"
using namespace std;



extern bool 관찰; // 관찰하려면 true로

//----------
int main()
//------------------------------------------------------------
{
    array<STRING, 5> a{ "1","333","22","55555","4444" };
    관찰 = true;
    ranges::sort(a, [](const STRING& lhs, STRING& rhs)  //가오 좀 부리자
        {
            return lhs.size() < rhs.size();
        });

    
    for (const STRING& str : a)
        cout << str << endl;
    관찰 = false;
    save("메인.cpp");
}

==============================================
저장한 시간 :2025-04-15 오후 2:19:36 화요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 20일 목요일      (7주 1일차 강의) 
// 4월 24일 중간고사(30) 8주차 2일
// 5월 6일(화) -> 6월 19(예정)
//-------------------------------------------------------------------------------------------
// STL Container -Containers are objects that store other objects -> 다른 객체를 담을 수 있는 객체 
//-------------------------------------------------------------------------------------------
#include<iostream>
#include<array>
#include"save.h"
#include"STRING.h"
using namespace std;



extern bool 관찰; // 관찰하려면 true로

//----------
int main()
//------------------------------------------------------------
{
    array<int, 0> a; //하나도 없는 어레이를 만들면 array.begin 은 array.end 이다.

    cout << typeid( array<int, 0>::value_type).name() << endl;
    save("메인.cpp");
}

==============================================
저장한 시간 :2025-04-15 오후 2:26:38 화요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 20일 목요일      (7주 1일차 강의) 
// 4월 24일 중간고사(30) 8주차 2일
// 5월 6일(화) -> 6월 19(예정)
//-------------------------------------------------------------------------------------------
// STL Container -Containers are objects that store other objects -> 다른 객체를 담을 수 있는 객체 
//-------------------------------------------------------------------------------------------
#include<iostream>
#include<array>
#include"save.h"
#include"STRING.h"
using namespace std;



extern bool 관찰; // 관찰하려면 true로

//----------
int main()
//------------------------------------------------------------
{
    array<int, 0> a; //하나도 없는 어레이를 만들면 array.begin 은 array.end 이다.

    cout << "빈 ㅇ레이니> -"<<boolalpha<<a.empty() << endl;
    save("메인.cpp");
}

==============================================
저장한 시간 :2025-04-15 오후 2:28:40 화요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 20일 목요일      (7주 1일차 강의) 
// 4월 24일 중간고사(30) 8주차 2일
// 5월 6일(화) -> 6월 19(예정)
//-------------------------------------------------------------------------------------------
// STL Container -Containers are objects that store other objects -> 다른 객체를 담을 수 있는 객체 
//-------------------------------------------------------------------------------------------
#include<iostream>
#include<array>
#include"save.h"
#include"STRING.h"
using namespace std;



extern bool 관찰; // 관찰하려면 true로

//----------
int main()
//------------------------------------------------------------
{
    array<int, 5> a{1,2,3,4,5}; //int a[5]를 클래스로 잘 포장해놓은 것 메모리 해킹에 취약하기 떄문에

    cout << a[5] << endl;
    save("메인.cpp");
}

==============================================
저장한 시간 :2025-04-15 오후 2:41:35 화요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 20일 목요일      (7주 1일차 강의) 
// 4월 24일 중간고사(30) 8주차 2일
// 5월 6일(화) -> 6월 19(예정)
//-------------------------------------------------------------------------------------------
// STL Container -Containers are objects that store other objects -> 다른 객체를 담을 수 있는 객체 
// 1.Sequence Containers
//      arrat<T,N>
//      vector<T> /dynamic(runtime)  array
//-------------------------------------------------------------------------------------------
#include<iostream>

#include<vector>
#include"save.h"
#include"STRING.h"
using namespace std;



extern bool 관찰; // 관찰하려면 true로

//----------
int main()
//------------------------------------------------------------
{
    vector<int> v(100); 

    //v의 정체를 밝혀보세요
    cout << sizeof(v) << endl;
    save("메인.cpp");
}

==============================================
저장한 시간 :2025-04-15 오후 2:42:57 화요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 20일 목요일      (7주 1일차 강의) 
// 4월 24일 중간고사(30) 8주차 2일
// 5월 6일(화) -> 6월 19(예정)
//-------------------------------------------------------------------------------------------
// STL Container -Containers are objects that store other objects -> 다른 객체를 담을 수 있는 객체 
// 1.Sequence Containers
//      arrat<T,N>
//      vector<T> /dynamic(runtime)  array
//-------------------------------------------------------------------------------------------
#include<iostream>

#include<vector>
#include"save.h"
#include"STRING.h"
using namespace std;



extern bool 관찰; // 관찰하려면 true로

//----------
int main()
//------------------------------------------------------------
{
    vector<int> v(100); 

    //v의 정체를 밝혀보세요
    cout<<"v의 크기 -" << sizeof(v) << endl;
    cout << "v의 주소" << addressof(v) << endl;
    cout << "v의 타입id" << typeid(v).name() << endl;
    save("메인.cpp");
}

==============================================
저장한 시간 :2025-04-15 오후 2:44:05 화요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 20일 목요일      (7주 1일차 강의) 
// 4월 24일 중간고사(30) 8주차 2일
// 5월 6일(화) -> 6월 19(예정)
//-------------------------------------------------------------------------------------------
// STL Container -Containers are objects that store other objects -> 다른 객체를 담을 수 있는 객체 
// 1.Sequence Containers
//      arrat<T,N>
//      vector<T> /dynamic(runtime)  array
//-------------------------------------------------------------------------------------------
#include<iostream>

#include<vector>
#include"save.h"
#include"STRING.h"
using namespace std;



extern bool 관찰; // 관찰하려면 true로

//----------
int main()
//------------------------------------------------------------
{
    vector<int> v(100); 

    //v의 정체를 밝혀보세요
    cout<<"v의 크기 -" << sizeof(v) << endl;
    cout << "v의 주소 - " << addressof(v) << endl;
    cout << "v의 타입 - " << typeid(v).name() << endl;
    save("메인.cpp");
}

==============================================
저장한 시간 :2025-04-15 오후 2:44:30 화요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 20일 목요일      (7주 1일차 강의) 
// 4월 24일 중간고사(30) 8주차 2일
// 5월 6일(화) -> 6월 19(예정)
//-------------------------------------------------------------------------------------------
// STL Container -Containers are objects that store other objects -> 다른 객체를 담을 수 있는 객체 
// 1.Sequence Containers
//      arrat<T,N>
//      vector<T> /dynamic(runtime)  array
//-------------------------------------------------------------------------------------------
#include<iostream>

#include<vector>
#include"save.h"
#include"STRING.h"
using namespace std;



extern bool 관찰; // 관찰하려면 true로
vector<int> v(100);
//----------
int main()
//------------------------------------------------------------
{
  

    //v의 정체를 밝혀보세요
    cout<<"v의 크기 -" << sizeof(v) << endl;
    cout << "v의 주소 - " << addressof(v) << endl;
    cout << "v의 타입 - " << typeid(v).name() << endl;
    save("메인.cpp");
}

==============================================
저장한 시간 :2025-04-15 오후 2:45:15 화요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 20일 목요일      (7주 1일차 강의) 
// 4월 24일 중간고사(30) 8주차 2일
// 5월 6일(화) -> 6월 19(예정)
//-------------------------------------------------------------------------------------------
// STL Container -Containers are objects that store other objects -> 다른 객체를 담을 수 있는 객체 
// 1.Sequence Containers
//      arrat<T,N>
//      vector<T> /dynamic(runtime)  array
//-------------------------------------------------------------------------------------------
#include<iostream>

#include<vector>
#include"save.h"
#include"STRING.h"
using namespace std;




//----------extern bool 관찰; // 관찰하려면 true로

int main()
//------------------------------------------------------------
{
  
   vector<int>* v =new vector<int> (100);
    //v의 정체를 밝혀보세요
    cout<<"v의 크기 -" << sizeof(v) << endl;
    cout << "v의 주소 - " << addressof(v) << endl;
    cout << "v의 타입 - " << typeid(v).name() << endl;
    save("메인.cpp");
}

==============================================
저장한 시간 :2025-04-15 오후 2:45:42 화요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 20일 목요일      (7주 1일차 강의) 
// 4월 24일 중간고사(30) 8주차 2일
// 5월 6일(화) -> 6월 19(예정)
//-------------------------------------------------------------------------------------------
// STL Container -Containers are objects that store other objects -> 다른 객체를 담을 수 있는 객체 
// 1.Sequence Containers
//      arrat<T,N>
//      vector<T> /dynamic(runtime)  array
//-------------------------------------------------------------------------------------------
#include<iostream>

#include<vector>
#include"save.h"
#include"STRING.h"
using namespace std;




//----------extern bool 관찰; // 관찰하려면 true로

int main()
//------------------------------------------------------------
{
  
   vector<int>* v =new vector<int> (100);
    //v의 정체를 밝혀보세요
    cout<<"v의 크기 -" << sizeof(*v) << endl;
    cout << "v의 주소 - " << addressof(*v) << endl;
    cout << "v의 타입 - " << typeid(*v).name() << endl;
    save("메인.cpp");
}

==============================================
저장한 시간 :2025-04-15 오후 2:54:32 화요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 20일 목요일      (7주 1일차 강의) 
// 4월 24일 중간고사(30) 8주차 2일
// 5월 6일(화) -> 6월 19(예정)
//-------------------------------------------------------------------------------------------
// STL Container -Containers are objects that store other objects -> 다른 객체를 담을 수 있는 객체 
// 1.Sequence Containers
//      arrat<T,N>
//      vector<T> /dynamic(runtime)  array
//-------------------------------------------------------------------------------------------
#include<iostream>

#include<vector>
#include"save.h"
#include"STRING.h"
using namespace std;



extern bool 관찰; // 관찰하려면 true로

//----------
int main()
//------------------------------------------------------------
{
    vector<int> v{ 1,2,3, };
    //반복자를 사용하여 access

    for (vector<int>::iterator i= v.begin(); i != v.end(); ++i) {
        cout << *i << endl;
    }

    save("메인.cpp");
}

==============================================
저장한 시간 :2025-04-15 오후 3:03:11 화요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 20일 목요일      (7주 1일차 강의) 
// 4월 24일 중간고사(30) 8주차 2일
// 5월 6일(화) -> 6월 19(예정)
//-------------------------------------------------------------------------------------------
// STL Container -Containers are objects that store other objects -> 다른 객체를 담을 수 있는 객체 
// 1.Sequence Containers
//      arrat<T,N>
//      vector<T> /dynamic(runtime)  array
//-------------------------------------------------------------------------------------------
#include<iostream>

#include<vector>
#include"save.h"
#include"STRING.h"
using namespace std;



extern bool 관찰; // 관찰하려면 true로

//----------
int main()
//------------------------------------------------------------
{
    vector<int> v{ 1,2,3, };
    //반복자를 사용하여 access

    for (int i = 4; i < 10; ++i) {
        v.push_back(i);
        cout << v.data() << endl;
    }

    for ( auto i= v.cbegin(); i != v.cend(); ++i) { //이때는 오토를 사용하는 것을 권장한다.
        cout << *i << endl;
    }

    save("메인.cpp");
}

==============================================
저장한 시간 :2025-04-15 오후 3:03:35 화요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 20일 목요일      (7주 1일차 강의) 
// 4월 24일 중간고사(30) 8주차 2일
// 5월 6일(화) -> 6월 19(예정)
//-------------------------------------------------------------------------------------------
// STL Container -Containers are objects that store other objects -> 다른 객체를 담을 수 있는 객체 
// 1.Sequence Containers
//      arrat<T,N>
//      vector<T> /dynamic(runtime)  array
//-------------------------------------------------------------------------------------------
#include<iostream>

#include<vector>
#include"save.h"
#include"STRING.h"
using namespace std;



extern bool 관찰; // 관찰하려면 true로

//----------
int main()
//------------------------------------------------------------
{
    vector<int> v{ 1,2,3, };
    //반복자를 사용하여 access

    for (int i = 4; i < 10; ++i) {
        v.push_back(i);
        cout << v.data() << endl;
    }

    for ( auto i= v.crbegin(); i != v.crend(); ++i) { //이때는 오토를 사용하는 것을 권장한다.
        cout << *i << endl;
    }

    save("메인.cpp");
}

==============================================
저장한 시간 :2025-04-15 오후 3:07:58 화요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 20일 목요일      (7주 1일차 강의) 
// 4월 24일 중간고사(30) 8주차 2일
// 5월 6일(화) -> 6월 19(예정)
//-------------------------------------------------------------------------------------------
// STL Container -Containers are objects that store other objects -> 다른 객체를 담을 수 있는 객체 
// 1.Sequence Containers
//      arrat<T,N>
//      vector<T> /dynamic(runtime)  array
//-------------------------------------------------------------------------------------------
#include<iostream>
#include<numeric>
#include<vector>
#include"save.h"
#include"STRING.h"
using namespace std;



extern bool 관찰; // 관찰하려면 true로

// [문제] 키보드에서 입력한 정수값의 합계와 평균을 출력하시오.

//----------
int main()
//------------------------------------------------------------
{
    cout << "점수를 마음껏 입력하시오.";
    vector<int> v{ istream_iterator<int>{cin} ,{} };

    cout << "합계 -" << accumulate(v.cbegin(), v.cend(), 0LL) << endl;

    save("메인.cpp");
}

==============================================
저장한 시간 :2025-04-15 오후 3:09:35 화요일 
==============================================

//-------------------------------------------------------------------------------------------
// 2025 STL 화56 목78  3월 20일 목요일      (7주 1일차 강의) 
// 4월 24일 중간고사(30) 8주차 2일
// 5월 6일(화) -> 6월 19(예정)
//-------------------------------------------------------------------------------------------
// STL Container -Containers are objects that store other objects -> 다른 객체를 담을 수 있는 객체 
// 1.Sequence Containers
//      arrat<T,N>
//      vector<T> /dynamic(runtime)  array
//-------------------------------------------------------------------------------------------
#include<iostream>
#include<numeric>
#include<vector>
#include"save.h"
#include"STRING.h"
using namespace std;



extern bool 관찰; // 관찰하려면 true로

// [문제] 키보드에서 입력한 정수값의 합계와 평균을 출력하시오.

//----------
int main()
//------------------------------------------------------------
{
    cout << "점수를 마음껏 입력하시오.";
    vector<int> v{ istream_iterator<int>{cin} ,{} };

    long long sum = accumulate(v.cbegin(), v.cend(), 0LL);
    cout << "합계 -" << accumulate(v.cbegin(), v.cend(), 0LL) << endl;
    cout << "합계 -" << (double)sum/v.size() << endl;

    save("메인.cpp");
}