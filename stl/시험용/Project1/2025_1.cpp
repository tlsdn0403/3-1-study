//-----------------------------------------------------------------------------
// STL 중간시험
//-----------------------------------------------------------------------------
// 환경 - VS 17.12.4 이상, C++언어 표준 - /std:c++latest, 미리보기Release x64
// 헤더 파일을 추가할 필요는 없다.
// 각 문제에서 요구하는 답을 구분하여 적어라.	
//-----------------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include <memory>
#include <array>
#include <vector>
#include <algorithm>
#include <numeric>
#include <string>
using namespace std;


//-----------------------------------------------------------------------------
// Test는 num개의 int를 free-store에 확보한 contiguous 메모리에 저장한다.
//-----------------------------------------------------------------------------

class Test {
public:
	Test( ) = default;

	void show( ) const {
		cout << num << " - ";
		for ( int i = 0; i < 3; ++i )
			cout << p[ i ] << " ";
		cout << endl;
	}

private:
	int num {};					// free-store에 저장한 int의 개수	
	unique_ptr<int[]> p {};		// num개의 int가 저장되어 있는 contiguous 메모리를 관리하는 포인터

public:
	friend ostream& operator<<( ostream& os, const Test& t ) {
		os << t.num << " ";
		for ( int i = 0; i < t.num; ++i ) {
			os << t.p[ i ] << " ";
			if ( 0 == (i % 12)  )
				os << '\n';
		}
		return os;
	}
	// Test 클래스에 추가한 멤버 함수:
	void read(istream& is) {
		is >> num;
		p = make_unique<int[]>(num);
		for (int i = 0; i < num; ++i) {
			is >> p[i];
		}
	}
	int max() {
		return *max_element(p.get(), p.get() + num);
	}
};

//-----------------------------------------------------------------------------
// main에 있는 문제를 순서대로 해결하며 요구하는 답을 답지에 적어 제출한다.
//-----------------------------------------------------------------------------

//---------
int main( )
//---------
{
	ifstream in { "2025_1.dat" };
	if (not in) {
		cout << "파일을 열 수 없습니다" << endl;
		return 20250424;
	}
    // [문제 1] 파일 "시험.dat"에 저장된 Test 객체를 읽어 컨테이너에 저장하라.

    // 사용한 컨테이너: vector<Test>
    // 이유: Test 객체의 개수가 파일을 읽어봐야 알 수 있으므로 동적 크기 조정이 가능한 vector가 적합하다.

    

    // 실제 읽어서 저장하는 코드:
    vector<Test> tests; 
	Test t{};
	while (in) {
		t.read(in);
		if(in){
			tests.push_back(move(t));
		}
		
	}

    // 개수를 화면에 출력하는 코드:
    cout << "읽은 Test 객체의 개수: " << tests.size() << endl;
	cout << tests.back();

	//-------------------------------------------------------------------------
	// [문제 1] 파일 "시험.dat"에 저장된 Test 객체를 읽어 컨테이너에 저장하라.
	//-------------------------------------------------------------------------
	// "시험.dat" 파일은 text 모드로 열었다.
	// Test 객체는 << 연산자를 사용하여 기록하였다.
	// Test 객체가 몇 개인지는 파일을 읽어봐야 알 수 있는 상황이다.
	// 읽기 위해 추가한 내용을 답지에 적어라.
	// 모두 몇 개를 읽었는지 화면에 출력하고 답지에도 적어라. 
	//-------------------------------------------------------------------------
	// 답지에는 다음 내용을 적으면 된다.
	// - 사용한 컨테이너와 이유											(10)
	// - 읽기 위해 추가한 Test의 멤버함수와 관련 함수	 				(30+)
	// - 실제 읽어서 저장하는 코드										(10)
	// - 개수를 화면에 출력하는 코드와 출력된 내용						(10)
	//-------------------------------------------------------------------------







	//-------------------------------------------------------------------------
       
	// [문제 2] 각 Test 객체에 저장된 int값 중에 가장 큰 값을 찾는 함수 max를 
	// 작성하라.
	//-------------------------------------------------------------------------
	// 답지에 함수 max의 정의를 적어라.									(10)
	//-------------------------------------------------------------------------
	// 다음과 같은 형식의 코드가 문제 없도록 하자.
	//-------------------------------------------------------------------------


	// int 최대값 = 컨테이너[ 0 ].max( );

	// 이와 같은 형식으로 max를 사용한다
	// 이 코드에서 컨테이너는 [문제 1]에서 만든 컨테이너이다.


	// [ 문제 2 ]의 출력 예는 다음과 같다.
	//	첫 Test 객체의 최댓값 - 996461
	int 최대값 = tests[0].max();
	cout << 최대값 << endl;




	//-------------------------------------------------------------------------
    // [문제 3] [문제 2]에서 작성한 max()를 사용하면 컨테이너에 저장된 
    // 모든 Test 객체의 최댓값을 알 수 있다.
    // 각 Test 객체의 최댓값들을 저장하는 컨테이너를 새로 만들어 
    // 여기에 모든 Test 객체의 최댓값을 저장하라.						

    // 새 컨테이너 생성 및 최댓값 저장
    vector<int> maxValues;
    for (Test& t : tests) {
    maxValues.push_back(t.max());
    }

    // 결과 출력
    cout << "[문제 3]에서 만든 컨테이너에 저장된 최댓값들 - 앞에서 부터 10개만 출력" << endl;
    for (size_t i = 0; i < 10; ++i) {
    cout << maxValues[i] << " ";
    }
    cout << endl;
	//-------------------------------------------------------------------------

	// 여기에 들어갈 코드를 답지에 적어라.								(10)		


	// [ 문제 3 ]의 출력 예는 다음과 같다
	// [문제 3]에서 만든 컨테이너에 저장된 최댓값들 - 앞에서 부터 10개만 출력
	// 996461 996135 981724 990110 993535 987983 978682 999080 974756 994505





	//-------------------------------------------------------------------------
    // [문제 4] sort를 사용하여 [문제 3]의 컨테이너에 저장된 최댓값을 
    // 홀수와 짝수로 분리하라.
    // 컨테이너를 처음부터 순회할때 홀수가 먼저 나온 후에 짝수가 나와야 한다.

    // sort를 사용하여 홀수와 짝수로 분리
    sort(maxValues.begin(), maxValues.end(), [](int a, int b) {
					// 홀수는 짝수보다 앞에 오도록 정렬
					if ((a % 2 != 0) && (b % 2 == 0)) return true;
					if ((a % 2 == 0) && (b % 2 != 0)) return false;
					return false; // 기존 순서 유지
    });

    // 결과 출력
    cout << "컨테이너에 저장된 최댓값들을 홀수와 짝수로 분리 - 앞에서 부터 10개만 출력" << endl;
    for (size_t i = 0; i < 10; ++i) {
					cout << maxValues[i] << " ";
    }
    cout << endl;
	//-------------------------------------------------------------------------

	// 여기에 들어갈 sort 코드를 답지에 적어라.							(10+)


	// [ 문제 4 ]의 출력 예는 다음과 같다
	// 컨테이너에 저장된 최댓값들을 홀수와 짝수로 분리 - 앞에서 부터 10개만 출력
	// 980999 995213 979767 797537 992907 986969 991953 971227 998041 996081





	//-------------------------------------------------------------------------
	// [문제 5] [문제 1]에서 만든 컨테이너에 저장된 Test 객체를 predicate을
	// 사용하지 않더라도 Test 객체의 최댓값 기준으로 오름차순 정렬되게 하고
	// 싶다. 
	// 어떻게 하면 되는 지 설명하라. (설명만 할 것)						(10)	 
	//-------------------------------------------------------------------------

	// sort( [문제 1]컨테이너.begin( ), [문제 1]컨테이너.end( ) );

	// 이와 같은 형식으로 코딩하면 최댓값 기준으로 오름차순 정렬되어야 한다.




	//-------------------------------------------------------------------------
	// [문제 6] [문제 5]의 sort가 충분히 빠르게 실행된다고 생각하는가?  
	// 더 빠르게 실행될 방법은 없는가?  
	// 이미 빠르다고 생각하거나 더 빠르게 할 방법이 있다면 이유를 설명하라.	(10)
	//-------------------------------------------------------------------------
}